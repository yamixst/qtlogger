#!/usr/bin/env python3

# Copyright (C) 2024 Mikhail Yatsenko <mikhail.yatsenko@gmail.com>
# SPDX-License-Identifier: MIT

import glob
import logging
import os
import re
from datetime import datetime

logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s %(levelname)s: %(message)s",
    handlers=[logging.StreamHandler()],
)

root_dir = os.path.abspath(
    os.path.join(os.path.dirname(__file__), "..", "src", "qtlogger")
)
include_dir = ""
included_files = set()


def include_replace(match):
    global include_dir

    include_path = match.group(1)

    path = os.path.abspath(os.path.join(include_dir, include_path))
    if not os.path.exists(path):
        path = os.path.abspath(os.path.join(include_dir, "..", include_path))
    if not os.path.exists(path):
        return match.group(0)

    if path in included_files:
        return ""

    included_files.add(path)

    logging.info("include " + path)

    content = f"\n// {os.path.basename(path)}\n"
    content += process_includes(path)
    content += f"\n// end {os.path.basename(path)}\n"
    return content


def process_includes(path):
    try:
        with open(path, "r") as file:
            content = file.read()
    except IOError:
        return ""

    global include_dir
    include_dir = os.path.dirname(path)
    content = re.sub(r"// SPDX.*", "", content)
    content = re.sub(r"// Copyright.*", "", content)
    content = re.sub(r'#\s*include "([^"]+)"', include_replace, content)
    return content


def main():
    sources = [os.path.join(root_dir, "qtlogger.h")]
    all_cpp = sorted(glob.glob(os.path.join(root_dir, "**", "*.cpp"), recursive=True))
    # Exclude build directory (contains CMake and moc-generated files)
    sources += [f for f in all_cpp if "/build/" not in f and not f.endswith("/build")]

    result_code = []
    for path in sources:
        logging.info("append  " + path)
        result_code.append(f"\n// {os.path.basename(path)}\n")
        result_code.append(process_includes(path) + "\n")

    result_code = "\n".join(result_code)
    result_code = result_code.replace("#pragma once", "")
    result_code = re.sub(r"\n{3,}", "\n\n", result_code)

    output_path = os.path.join(root_dir, "..", "..", "qtlogger.h")
    with open(output_path, "w") as file:
        file.write("// Copyright (C) 2024 Mikhail Yatsenko <mikhail.yatsenko@gmail.com>\n")
        file.write("// SPDX-License-Identifier: MIT\n\n")
        file.write("// QtLogger - Advanced thread-safe logging library for Qt 5 & Qt 6.\n")
        file.write("// Features: Async, JSON, HTTP sinks, Rotating files, and Colored console output.\n")
        file.write("// Easy integration with existing qDebug(), qInfo(), qWarning(), qCritical() calls.\n")
        file.write("//\n")
        file.write("// Documentation: https://github.com/yamixst/qtlogger\n\n")
        file.write("// This file is automatically generated. Please don't edit it.\n\n")
        file.write("#pragma once\n\n")
        file.write("// #define QTLOGGER_NO_THREAD\n")
        file.write("// #define QTLOGGER_NETWORK\n")
        file.write("// #define QTLOGGER_IOSLOG\n")
        file.write("// #define QTLOGGER_ANDROIDLOG\n")
        file.write("// #define QTLOGGER_SYSLOG\n")
        file.write("// #define QTLOGGER_JOURNAL\n")
        file.write("\n")
        file.write("#define QTLOGGER_DECL_SPEC inline\n")
        file.write(result_code)


if __name__ == "__main__":
    main()
