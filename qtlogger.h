// Copyright (C) 2024 Mikhail Yatsenko <mikhail.yatsenko@gmail.com>
// SPDX-License-Identifier: MIT

// QtLogger - Advanced thread-safe logging library for Qt 5 & Qt 6.
// Features: Async, JSON, HTTP sinks, Rotating files, and Colored console output.
// Easy integration with existing qDebug(), qInfo(), qWarning(), qCritical() calls.
//
// Documentation: https://github.com/yamixst/qtlogger

// This file is automatically generated. Please don't edit it.

#pragma once

// #define QTLOGGER_NO_THREAD
// #define QTLOGGER_NETWORK
// #define QTLOGGER_IOSLOG
// #define QTLOGGER_ANDROIDLOG
// #define QTLOGGER_SYSLOG
// #define QTLOGGER_JOURNAL

#define QTLOGGER_DECL_SPEC inline

// qtlogger.h

// version.h

#define QTLOGGER_VERSION 0.9.0

// end version.h

// attrhandler.h

#include <QSharedPointer>

// handler.h

#include <QSharedPointer>

// logger_global.h

#include <QtCore/qglobal.h>

#if defined(QTLOGGER_STATIC)
#    define QTLOGGER_EXPORT
#elif defined(QTLOGGER_LIBRARY)
#    define QTLOGGER_EXPORT Q_DECL_EXPORT
#else
#    define QTLOGGER_EXPORT Q_DECL_IMPORT
#endif

#if !defined(QTLOGGER_DECL_SPEC)
#    define QTLOGGER_DECL_SPEC
#endif

// end logger_global.h

// logmessage.h

#include <QDateTime>
#include <QVariant>
#include <qlogging.h>
#include <chrono>

#ifndef QTLOGGER_NO_THREAD
#    include <QThread>
#endif

namespace QtLogger {

class QTLOGGER_EXPORT LogMessage
{
public:
    LogMessage() noexcept = default;

    LogMessage(QtMsgType type, const QMessageLogContext &context, const QString &message) noexcept
        : m_type(type),
          m_context(context.file, context.line, context.function, context.category),
          m_message(message)
    {
    }

    inline LogMessage(const LogMessage &lmsg) noexcept
        : m_file(lmsg.m_context.file),
          m_function(lmsg.m_context.function),
          m_category(lmsg.m_context.category),
          m_type(lmsg.m_type),
          m_context(m_file.constData(), lmsg.m_context.line, m_function.constData(),
                    m_category.constData()),
          m_message(lmsg.m_message),
          m_time(lmsg.m_time),
          m_steadyTime(lmsg.m_steadyTime),
#ifndef QTLOGGER_NO_THREAD
          m_qthreadptr(lmsg.m_qthreadptr),
#endif
          m_formattedMessage(lmsg.m_formattedMessage),
          m_attributes(lmsg.m_attributes)
    {
    }

    inline QtMsgType type() const { return m_type; }
    inline const QMessageLogContext &context() const { return m_context; }
    inline QString message() const { return m_message; }

    // Context members

    inline int line() const { return m_context.line; }
    inline const char *file() const { return m_context.file; }
    inline const char *function() const { return m_context.function; }
    inline const char *category() const { return m_context.category; }

    // System attributes

    inline QDateTime time() const { return m_time; }
    inline std::chrono::steady_clock::time_point steadyTime() const { return m_steadyTime; }

    inline quint64 threadId() const
    {
#ifndef QTLOGGER_NO_THREAD
        return m_qthreadptr;
#else
        return 0;
#endif
    }
    inline quintptr qthreadptr() const
    {
#ifndef QTLOGGER_NO_THREAD
        return m_qthreadptr;
#else
        return 0;
#endif
    }

    // Formatted message

    inline QString formattedMessage() const
    {
        return isFormatted() ? m_formattedMessage : m_message;
    }
    inline void setFormattedMessage(const QString &formattedMessage)
    {
        m_formattedMessage = formattedMessage;
    }
    inline bool isFormatted() const { return !m_formattedMessage.isNull(); }

    // Custom attributes

    inline QVariant attribute(const QString &name) const { return m_attributes.value(name); }
    inline void setAttribute(const QString &name, const QVariant &value)
    {
        m_attributes.insert(name, value);
    }
    inline void setAttributes(const QVariantHash &attrs)
    {
        m_attributes = attrs;
    }
    inline void updateAttributes(const QVariantHash &attrs)
    {
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
        m_attributes.insert(attrs);
#else
        m_attributes.unite(attrs);
#endif
    }
    inline void removeAttribute(const QString &name)
    {
        m_attributes.remove(name);
    }
    inline bool hasAttribute(const QString &name) const { return m_attributes.contains(name); }
    inline QVariantHash attributes() const { return m_attributes; }

    // All message attributes including: type, line, file, function, category, message,
    // time, threadId and all custom attributes
    QVariantHash allAttributes() const;

private:
    // m_context string buffers
    const QByteArray m_file;
    const QByteArray m_function;
    const QByteArray m_category;

    const QtMsgType m_type = QtDebugMsg;
    const QMessageLogContext m_context;
    const QString m_message;

    const QDateTime m_time = QDateTime::currentDateTime();
    const std::chrono::steady_clock::time_point m_steadyTime = std::chrono::steady_clock::now();
#ifndef QTLOGGER_NO_THREAD
    const quintptr m_qthreadptr = reinterpret_cast<quintptr>(QThread::currentThreadId());
#endif

    QString m_formattedMessage;
    QVariantHash m_attributes;
};

inline QString qtMsgTypeToString(QtMsgType type, const QString &a_default = QStringLiteral("debug"))
{
    static const auto map = QHash<QtMsgType, QString> {
        { QtDebugMsg, QStringLiteral("debug") },
        { QtInfoMsg, QStringLiteral("info") },
        { QtWarningMsg, QStringLiteral("warning") },
        { QtCriticalMsg, QStringLiteral("critical") },
        { QtFatalMsg, QStringLiteral("fatal") },
    };
    return map.value(type, a_default);
}

inline QtMsgType stringToQtMsgType(const QString &str, QtMsgType a_default= QtDebugMsg)
{
    static const auto map = QHash<QString, QtMsgType> {
        { QStringLiteral("debug"), QtDebugMsg },
        { QStringLiteral("info"), QtInfoMsg },
        { QStringLiteral("warning"), QtWarningMsg },
        { QStringLiteral("critical"), QtCriticalMsg },
        { QStringLiteral("fatal"), QtFatalMsg },
    };
    return map.value(str, a_default);
}

inline QVariantHash LogMessage::allAttributes() const
{
    auto attrs = QVariantHash {
        { QStringLiteral("type"), qtMsgTypeToString(type()) },
        { QStringLiteral("line"), line() },
        { QStringLiteral("file"), file() },
        { QStringLiteral("function"), function() },
        { QStringLiteral("category"), category() },
        { QStringLiteral("message"), message() },
        { QStringLiteral("time"), time() },
#ifndef QTLOGGER_NO_THREAD
        { QStringLiteral("threadId"), threadId() },
#endif
    };

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    attrs.insert(m_attributes);
#else
    attrs.unite(m_attributes);
#endif

    return attrs;
}

} // namespace QtLogger

// end logmessage.h

namespace QtLogger {

class QTLOGGER_EXPORT Handler
{
public:
    enum class HandlerType { Handler, AttrHandler, Filter, Formatter, Sink, Pipeline };

    virtual ~Handler() = default;

    virtual HandlerType type() const { return HandlerType::Handler; }

    virtual bool process(LogMessage &lmsg) = 0;
};

using HandlerPtr = QSharedPointer<Handler>;

inline uint qHash(Handler::HandlerType key, uint seed = 0) noexcept {
    return ::qHash(static_cast<uint>(key), seed);
}

} // namespace QtLogger

// end handler.h

namespace QtLogger {

class QTLOGGER_EXPORT AttrHandler : public Handler
{
public:
    virtual ~AttrHandler() = default;

    virtual QVariantHash attributes(const LogMessage &lmsg) = 0;

    HandlerType type() const override { return HandlerType::AttrHandler; }

    bool process(LogMessage &lmsg) override
    {
        lmsg.updateAttributes(attributes(lmsg));
        return true;
    }
};

using AttrHandlerPtr = QSharedPointer<AttrHandler>;

} // namespace QtLogger

// end attrhandler.h

// appinfoattrs.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT AppInfoAttrs : public AttrHandler
{
public:
    AppInfoAttrs();

    QVariantHash attributes(const LogMessage &lmsg) override;

private:
    QVariantHash m_attrs;
};

using AppInfoAttrsPtr = QSharedPointer<AppInfoAttrs>;

} // namespace QtLogger

// end appinfoattrs.h

// functionattrhandler.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT FunctionAttrHandler : public AttrHandler
{
public:
    using Function = std::function<QVariantHash(const LogMessage &lmsg)>;

    FunctionAttrHandler(const Function &function) : m_function(function) { }

    QVariantHash attributes(const LogMessage &lmsg) override { return m_function(lmsg); }

private:
    Function m_function;
};

using FunctionAttrHandlerPtr = QSharedPointer<FunctionAttrHandler>;

} // namespace QtLogger

// end functionattrhandler.h

// seqnumberattr.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT SeqNumberAttr : public AttrHandler
{
public:
    explicit SeqNumberAttr(const QString &name = QStringLiteral("seq_number"));
    QVariantHash attributes(const LogMessage &lmsg) override;

private:
    QString m_name;
    int m_count = 0;
};

using SeqNumberAttrPtr = QSharedPointer<SeqNumberAttr>;

} // namespace QtLogger

// end seqnumberattr.h

// sysinfoattrs.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT SysInfoAttrs : public AttrHandler
{
public:
    SysInfoAttrs();

    QVariantHash attributes(const LogMessage &lmsg) override;

private:
    QVariantHash m_attrs;
};

using SysInfoAttrsPtr = QSharedPointer<SysInfoAttrs>;

} // namespace QtLogger
// end sysinfoattrs.h

// filter.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Filter : public Handler
{
public:
    virtual ~Filter() = default;

    virtual bool filter(const LogMessage &lmsg) = 0;

    HandlerType type() const override final { return HandlerType::Filter; }

    bool process(LogMessage &lmsg) override final { return filter(lmsg); }
};

using FilterPtr = QSharedPointer<Filter>;

} // namespace QtLogger

// end filter.h

// categoryfilter.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT CategoryFilter : public Filter
{
public:
    CategoryFilter(const QString &rules);

    bool filter(const LogMessage &lmsg) override;

private:
    struct Rule;
    void parseRules(const QString &rules);
    QList<QSharedPointer<Rule>> m_rules;
};

using CategoryFilterPtr = QSharedPointer<CategoryFilter>;

} // namespace QtLogger

// end categoryfilter.h

// duplicatefilter.h

namespace QtLogger {

class QTLOGGER_EXPORT DuplicateFilter : public Filter
{
public:
    bool filter(const LogMessage &lmsg) override;

private:
    QString m_lastMessage;
};

using DuplicateFilterPtr = QSharedPointer<DuplicateFilter>;

} // namespace QtLogger

// end duplicatefilter.h

// functionfilter.h

#include <functional>

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT FunctionFilter : public Filter
{
public:
    using Function = std::function<bool(const LogMessage &)>;

    FunctionFilter(const Function &function) : m_function(function) { }

    bool filter(const LogMessage &lmsg) override { return m_function(lmsg); }

private:
    Function m_function;
};

using FunctionFilterPtr = QSharedPointer<FunctionFilter>;

} // namespace QtLogger

// end functionfilter.h

// levelfilter.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT LevelFilter : public Filter
{
public:
    explicit LevelFilter(QtMsgType minLevel = QtDebugMsg) : m_minLevel(minLevel) { }

    bool filter(const LogMessage &lmsg) override {
        return priority(lmsg.type()) >= priority(m_minLevel);
    }

private:
    static int priority(QtMsgType type) {
        switch (type) {
            case QtDebugMsg:    return 0;
            case QtInfoMsg:     return 1;
            case QtWarningMsg:  return 2;
            case QtCriticalMsg: return 3;
            case QtFatalMsg:    return 4;
        }
        return -1;
    }

    QtMsgType m_minLevel;
};

using LevelFilterPtr = QSharedPointer<LevelFilter>;

} // namespace QtLogger

// end levelfilter.h

// regexpfilter.h

#include <QRegularExpression>
#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT RegExpFilter : public Filter
{
public:
    explicit RegExpFilter(const QRegularExpression &regExp);
    explicit RegExpFilter(const QString &regExp);

    bool filter(const LogMessage &lmsg) override;

private:
    QRegularExpression m_regExp;
};

using RegExpFilterPtr = QSharedPointer<RegExpFilter>;

} // namespace QtLogger

// end regexpfilter.h

// formatter.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Formatter : public Handler
{
public:
    virtual ~Formatter() = default;

    virtual QString format(const LogMessage &lmsg) = 0;

    HandlerType type() const override final { return HandlerType::Formatter; }

    bool process(LogMessage &lmsg) override final
    {
        lmsg.setFormattedMessage(format(lmsg));
        return true;
    }
};

using FormatterPtr = QSharedPointer<Formatter>;

} // namespace QtLogger

// end formatter.h

// functionformatter.h

#include <functional>

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT FunctionFormatter : public Formatter
{
public:
    using Function = std::function<QString(const LogMessage &)>;

    FunctionFormatter(const Function &func) : m_func(func) { }

    QString format(const LogMessage &lmsg) override { return m_func(lmsg); }

private:
    Function m_func;
};

using FunctionFormatterPtr = QSharedPointer<FunctionFormatter>;

} // namespace QtLogger

// end functionformatter.h

// jsonformatter.h

#include <QSharedPointer>

namespace QtLogger {

using JsonFormatterPtr = QSharedPointer<class JsonFormatter>;

class QTLOGGER_EXPORT JsonFormatter : public Formatter
{
public:
    explicit JsonFormatter(bool compact = false);

    static JsonFormatterPtr instance()
    {
        static const auto s_instance = JsonFormatterPtr::create();
        return s_instance;
    }

    QString format(const LogMessage &lmsg) override;

private:
    bool m_compact = false;
};

} // namespace QtLogger

// end jsonformatter.h

// patternformatter.h

#include <QSharedPointer>
#include <QScopedPointer>

namespace QtLogger {

using PatternFormatterPtr = QSharedPointer<class PatternFormatter>;

class QTLOGGER_EXPORT PatternFormatter : public Formatter
{
public:
    explicit PatternFormatter(const QString &pattern);
    ~PatternFormatter() override;

    QString format(const LogMessage &lmsg) override;

private:
    class PatternFormatterPrivate;
    QScopedPointer<PatternFormatterPrivate> d;
    Q_DISABLE_COPY(PatternFormatter)
};

} // namespace QtLogger

// end patternformatter.h

// prettyformatter.h

#include <QHash>

namespace QtLogger {

using PrettyFormatterPtr = QSharedPointer<class PrettyFormatter>;

class QTLOGGER_EXPORT PrettyFormatter : public Formatter
{
public:
    static PrettyFormatterPtr instance()
    {
        static const auto s_instance = PrettyFormatterPtr::create(0, false);
        return s_instance;
    }

    explicit PrettyFormatter(bool colorize = false, int maxCategoryWidth = 15);

    QString format(const LogMessage &lmsg) override;

private:
    bool m_colorize = false;
    int m_maxCategoryWidth = 15;

    QHash<int, int> m_threads;
    int m_threadsIndex = 0;
    int m_categoryWidth = 0;
};

} // namespace QtLogger

// end prettyformatter.h

// qtlogmessageformatter.h

#include <QSharedPointer>

namespace QtLogger {

using QtLogMessageFormatterPtr = QSharedPointer<class QtLogMessageFormatter>;

class QTLOGGER_EXPORT QtLogMessageFormatter : public Formatter
{
public:
    static QtLogMessageFormatterPtr instance()
    {
        static const auto s_instance = QtLogMessageFormatterPtr(new QtLogMessageFormatter());
        return s_instance;
    }

    QString format(const LogMessage &lmsg) override
    {
        return qFormatLogMessage(lmsg.type(), lmsg.context(), lmsg.message());
    }

private:
    QtLogMessageFormatter() { }
};

} // namespace QtLogger

// end qtlogmessageformatter.h

// sentryformatter.h

#include <QSharedPointer>

namespace QtLogger {

using SentryFormatterPtr = QSharedPointer<class SentryFormatter>;

class QTLOGGER_EXPORT SentryFormatter : public Formatter
{
public:
    explicit SentryFormatter(const QString &sdkName = QStringLiteral("qtlogger.sentry"),
                             const QString &sdkVersion = QStringLiteral("1.0.0"));

    static SentryFormatterPtr instance()
    {
        static const auto s_instance = SentryFormatterPtr::create();
        return s_instance;
    }

    QString format(const LogMessage &lmsg) override;

private:
    QString m_sdkName;
    QString m_sdkVersion;
};

} // namespace QtLogger
// end sentryformatter.h

// functionhandler.h

#include <functional>

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT FunctionHandler : public Handler
{
public:
    using Function = std::function<bool(LogMessage &)>;

    FunctionHandler(Function function) : m_function(std::move(function)) { }

    bool process(LogMessage &lmsg) override { return m_function(lmsg); }

private:
    Function m_function;
};

using FunctionHandlerPtr = QSharedPointer<FunctionHandler>;

} // namespace QtLogger

// end functionhandler.h

// sentry.h

#include <QList>
#include <QPair>
#include <QString>
#include <QUrl>

namespace QtLogger {

inline QString sentryUrl(const QString &sentryDsn)
{
    QUrl dsn(sentryDsn);
    auto publicKey = dsn.userName();
    auto host = dsn.host();
    auto projectId = dsn.path().mid(1); // Remove leading '/'

    return QString("https://%1/api/%2/store/?sentry_version=7&sentry_key=%3")
            .arg(host, projectId, publicKey);
}

inline QString sentryUrl(const QString &sentryHost,
                         const QString &sentryProjectId,
                         const QString &sentryPublicKey)
{
    return QString("https://%1/api/%2/store/?sentry_version=7&sentry_key=%3")
            .arg(sentryHost, sentryProjectId, sentryPublicKey);
}

inline QString sentryUrl()
{
    auto dsn = qEnvironmentVariable("SENTRY_DSN");
    if (!dsn.isEmpty()) {
        return sentryUrl(dsn);
    }

    return sentryUrl(qEnvironmentVariable("SENTRY_HOST"),
                     qEnvironmentVariable("SENTRY_PROJECT_ID"),
                     qEnvironmentVariable("SENTRY_PUBLIC_KEY"));
}

inline bool checkSentryEnv()
{
    if (!qEnvironmentVariable("SENTRY_DSN").isEmpty()) {
        return true;
    }

    return !qEnvironmentVariable("SENTRY_HOST").isEmpty()
           && !qEnvironmentVariable("SENTRY_PROJECT_ID").isEmpty()
           && !qEnvironmentVariable("SENTRY_PUBLIC_KEY").isEmpty();
}

inline QList<QPair<QByteArray, QByteArray>> sentryHeaders()
{
    return {
        { "Content-Type", "application/json; charset=utf-8" }
    };
}

} // namespace QtLogger
// end sentry.h

// logger.h

#include <QFlags>
#include <QSettings>

#ifndef QTLOGGER_NO_THREAD
#    include <QMutex>
#endif

// configure.h

#include <QFlags>
#include <QSettings>
#include <QString>

// rotatingfilesink.h

#include <QScopedPointer>
#include <QSharedPointer>

// filesink.h

#include <QSharedPointer>

// iodevicesink.h

#include <QIODevice>
#include <QSharedPointer>

// sink.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Sink : public Handler
{
public:
    virtual void send(const LogMessage &lmsg) = 0;
    virtual bool flush() { return true; }

    HandlerType type() const override final { return HandlerType::Sink; }

    bool process(LogMessage &lmsg) override final
    {
        send(lmsg);
        return true;
    }
};

using SinkPtr = QSharedPointer<Sink>;

} // namespace QtLogger

// end sink.h

namespace QtLogger {

using QIODevicePtr = QSharedPointer<QIODevice>;

class QTLOGGER_EXPORT IODeviceSink : public Sink
{
public:
    explicit IODeviceSink(const QIODevicePtr &device);

    void send(const LogMessage &lmsg) override;

protected:
    const QIODevicePtr &device() const;
    void setDevice(const QIODevicePtr &device);

private:
    QIODevicePtr m_device;
};

using IODeviceSinkPtr = QSharedPointer<IODeviceSink>;

} // namespace QtLogger

// end iodevicesink.h

QT_FORWARD_DECLARE_CLASS(QFile)

namespace QtLogger {

class QTLOGGER_EXPORT FileSink : public IODeviceSink
{
public:
    explicit FileSink(const QString &path);
    ~FileSink() override;

    bool flush() override;

protected:
    QFile *file() const;
};

using FileSinkPtr = QSharedPointer<FileSink>;

} // namespace QtLogger

// end filesink.h

namespace QtLogger {

class QTLOGGER_EXPORT RotatingFileSink : public FileSink
{
public:
    constexpr static int DefaultMaxFileSize = 1 * 1024 * 1024; // 1 MB
    constexpr static int DefaultMaxFileCount = 5;

    enum Option
    {
        None = 0x00,
        RotationOnStartup = 0x01,
        RotationDaily = 0x02,
        Compression = 0x04
    };

    Q_DECLARE_FLAGS(Options, Option)

    explicit RotatingFileSink(const QString &path,
                              int maxFileSize = DefaultMaxFileSize,
                              int maxFileCount = DefaultMaxFileCount,
                              Options options = Option::None);
    ~RotatingFileSink() override;

    void send(const LogMessage &lmsg) override;

private:
    class RotatingFileSinkPrivate;
    QScopedPointer<RotatingFileSinkPrivate> d;
    Q_DISABLE_COPY(RotatingFileSink)
};

using RotatingFileSinkPtr = QSharedPointer<RotatingFileSink>;

} // namespace QtLogger

Q_DECLARE_OPERATORS_FOR_FLAGS(QtLogger::RotatingFileSink::Options)
// end rotatingfilesink.h

namespace QtLogger {

class Logger;
class Pipeline;

QTLOGGER_EXPORT void configure(Pipeline *pipeline, const QString &path = {}, int maxFileSize = 0,
                               int maxFileCount = 0,
                               RotatingFileSink::Options options = RotatingFileSink::Option::None,
                               bool async = true);

QTLOGGER_EXPORT void configure(Pipeline *pipeline, const QSettings &settings,
                               const QString &group = QStringLiteral("logger"));

QTLOGGER_EXPORT void configureFromIniFile(Pipeline *pipeline, const QString &path,
                                          const QString &group = QStringLiteral("logger"));
} // namespace QtLogger

// end configure.h

// simplepipeline.h

#include <QList>
#include <QSharedPointer>

// sortedpipeline.h

#include <QSet>

// pipeline.h

#include <initializer_list>

#include <QList>
#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Pipeline : public Handler
{
public:
    explicit Pipeline(bool scoped = false) : m_scoped(scoped) {};
    Pipeline(std::initializer_list<HandlerPtr> handlers, bool scoped = false);

    HandlerType type() const override final { return HandlerType::Pipeline; }

    void append(const HandlerPtr &handler);
    void append(std::initializer_list<HandlerPtr> handlers);
    void remove(const HandlerPtr &handler);
    void clear();

    Pipeline &operator<<(const HandlerPtr &handler);

    bool process(LogMessage &lmsg) override;

    QList<HandlerPtr> const& handlers() const { return m_handlers; }

protected:
    QList<HandlerPtr> &handlers() { return m_handlers; }

private:
    QList<HandlerPtr> m_handlers;
    bool m_scoped = false;
};

using PipelinePtr = QSharedPointer<Pipeline>;

inline Pipeline &operator<<(Pipeline *pipeline, const HandlerPtr &handler)
{
    return *pipeline << handler;
}

inline Pipeline &operator<<(PipelinePtr pipeline, const HandlerPtr &handler)
{
    return *pipeline << handler;
}

} // namespace QtLogger

// end pipeline.h

namespace QtLogger {

class QTLOGGER_EXPORT SortedPipeline : public Pipeline
{
public:
    explicit SortedPipeline(bool scoped = false) : Pipeline(scoped) { }

    void insertBetweenNearLeft(const QSet<HandlerType> &leftType,
                               const QSet<HandlerType> &rightType, const HandlerPtr &handler);
    void insertBetweenNearRight(const QSet<HandlerType> &leftType,
                                const QSet<HandlerType> &rightType, const HandlerPtr &handler);
    void clear(HandlerType type);
    void clear();

    void appendAttrHandler(const AttrHandlerPtr &attrHandler);
    void clearAttrHandlers();

    void appendFilter(const FilterPtr &filter);
    void clearFilters();

    void setFormatter(const FormatterPtr &formatter);
    void clearFormatters();

    void appendSink(const SinkPtr &sink);
    void clearSinks();

    void appendPipeline(const PipelinePtr &pipeline);
    void clearPipelines();
};

using SortedPipelinePtr = QSharedPointer<SortedPipeline>;

} // namespace QtLogger

// end sortedpipeline.h

QT_FORWARD_DECLARE_CLASS(QIODevice)

namespace QtLogger {

class QTLOGGER_EXPORT SimplePipeline : public SortedPipeline
{
public:
    explicit SimplePipeline(bool scoped = false, SimplePipeline *parent = nullptr)
        : SortedPipeline(scoped), m_parent(parent)
    {
    }

    SimplePipeline &addSeqNumber(const QString &name = QStringLiteral("seq_number"));
    SimplePipeline &addAppInfo();
    SimplePipeline &addSysInfo();
#ifdef QTLOGGER_NETWORK
    SimplePipeline &addHostInfo();
#endif
    SimplePipeline &attrHandler(std::function<QVariantHash(const LogMessage &lmsg)> func);

    SimplePipeline &filter(std::function<bool(const LogMessage &)> func);
    SimplePipeline &filter(const QString &regexp);
    SimplePipeline &filterLevel(QtMsgType minLevel);
    SimplePipeline &filterCategory(const QString &rules);
    SimplePipeline &filterDuplicate();

    SimplePipeline &format(std::function<QString(const LogMessage &)> func);
    SimplePipeline &format(const QString &pattern);
    SimplePipeline &formatByQt();
    SimplePipeline &formatPretty(bool colorize = false, int maxCategoryWidth = 15);
    SimplePipeline &formatToJson(bool compact = false);
    SimplePipeline &formatToSentry(const QString &sdkName = QStringLiteral("qtlogger.sentry"),
                                   const QString &sdkVersion = QStringLiteral("1.0.0"));

    SimplePipeline &sendToStdOut(bool colorize = false);
    SimplePipeline &sendToStdErr(bool colorize = false);
#ifdef QTLOGGER_SYSLOG
    SimplePipeline &sendToSyslog();
#endif
#ifdef QTLOGGER_SDJOURNAL
    SimplePipeline &sendToSdJournal();
#endif
    SimplePipeline &sendToPlatformStdLog();
    SimplePipeline &sendToFile(const QString &fileName, int maxFileSize = 0, int maxFileCount = 0, RotatingFileSink::Options options = RotatingFileSink::None);
    SimplePipeline &sendToIODevice(const QIODevicePtr &device);
    SimplePipeline &sendToSignal(QObject *receiver, const char *method);
#ifdef QTLOGGER_NETWORK
    SimplePipeline &sendToHttp(const QString &url);
    SimplePipeline &sendToHttp(const QString &url,
                               const QList<QPair<QByteArray, QByteArray>> &headers);
#endif
#ifdef Q_OS_WIN
    SimplePipeline &sendToWinDebug();
#endif
#ifdef QTLOGGER_ANDROIDLOG
    SimplePipeline &sendToAndroidLog();
#endif
#ifdef QTLOGGER_OSLOG
    SimplePipeline &sendToOsLog();
#endif

    SimplePipeline &pipeline();
    SimplePipeline &end();

    SimplePipeline &handler(std::function<bool(LogMessage &)> func);

    virtual void flush();

private:
    static void recursiveFlush(const Pipeline *pipeline);

    SimplePipeline *m_parent = nullptr;
};

using SimplePipelinePtr = QSharedPointer<SimplePipeline>;

} // namespace QtLogger

// end simplepipeline.h

#ifndef QTLOGGER_NO_THREAD

// ownthreadhandler.h

#include <type_traits>

#include <QAtomicInt>
#include <QCoreApplication>
#include <QEvent>
#include <QMutexLocker>
#include <QObject>
#include <QPointer>
#include <QThread>

namespace QtLogger {

template<typename BaseHandler>
class QTLOGGER_EXPORT OwnThreadHandler : public BaseHandler
{
    static_assert(std::is_base_of<Handler, BaseHandler>::value,
                  "BaseHandler must inherit from Handler");

public:
    template<typename... Args>
    OwnThreadHandler(Args &&...args) : BaseHandler(std::forward<Args>(args)...)
    {
        static auto __once = qRegisterMetaType<QtLogger::LogMessage>("QtLogger::LogMessage");
        Q_UNUSED(__once)
    }

    ~OwnThreadHandler() override { resetOwnThread(); }

    QThread *ownThread() const { return m_thread; }

    bool ownThreadIsRunning() const { return m_thread && m_thread->isRunning(); }

    OwnThreadHandler<BaseHandler> &moveToOwnThread()
    {
        QMutexLocker locker(&m_mutex);

        if (m_thread)
            return *this;

        m_thread = new QThread();

        if (qApp) {
            // The thread object must be guaranteed to be attached to the main thread regardless of
            // where this method was called from
            if (qApp->thread() != m_thread->thread()) {
                m_thread->moveToThread(qApp->thread());
            }
            QObject::connect(qApp, &QCoreApplication::aboutToQuit, m_thread,
                             [this]() { resetOwnThread(); });
        }

        QObject::connect(m_thread, &QThread::finished, m_thread, &QThread::deleteLater);

        m_worker = new Worker(/* handler (not parent!) */ this);
        m_worker->moveToThread(m_thread);

        // The deletion of the worker occurs only in this place after the thread stops, so we can
        // keep a pointer to it via closures
        const auto worker = m_worker;
        QObject::connect(m_thread, &QThread::finished, [worker]() {
            // We cannot delete worker via deleteLater because m_thread will not process incoming
            // events anymore
            delete worker;
        });

        m_thread->start();

        return *this;
    }

    void resetOwnThread()
    {
        QMutexLocker locker(&m_mutex);

        if (!m_thread)
            return;

        while (m_pendingCount.loadAcquire() > 0) {
            locker.unlock();
            QThread::msleep(10);
            locker.relock();
        }

        m_thread->quit();

        if (!m_thread->wait(3000)) {
            m_thread->terminate();
            m_thread->wait();
        }

        m_thread.clear();
        m_worker = nullptr;
    }

    bool process(LogMessage &lmsg) override
    {
        QMutexLocker locker(&m_mutex);

        if (m_worker) {
            m_pendingCount.fetchAndAddOrdered(1);
            QCoreApplication::postEvent(m_worker, new LogEvent(lmsg));
        } else {
            BaseHandler::process(lmsg);
        }
        return true;
    }

private:
    struct LogEvent : public QEvent
    {
        LogEvent(const LogMessage &lmsg) : QEvent(type()), lmsg(lmsg) { }

        static QEvent::Type type()
        {
            static QEvent::Type _type = static_cast<QEvent::Type>(QEvent::registerEventType());
            return _type;
        }

        LogMessage lmsg;
    };

    class Worker : public QObject
    {
    public:
        explicit Worker(OwnThreadHandler<BaseHandler> *handler) : QObject(), m_handler(handler) { }

        void customEvent(QEvent *event) override
        {
            if (event->type() == LogEvent::type()) {
                auto logEvent = dynamic_cast<LogEvent *>(event);
                if (logEvent) {
                    m_handler->BaseHandler::process(logEvent->lmsg);
                    m_handler->m_pendingCount.fetchAndSubOrdered(1);
                }
            }
        }

    private:
        OwnThreadHandler<BaseHandler> *m_handler;
    };

private:
    QPointer<QThread> m_thread;
    Worker *m_worker = nullptr;
    QMutex m_mutex;
    QAtomicInt m_pendingCount;
};

} // namespace QtLogger

// end ownthreadhandler.h

#endif

#define gQtLogger (*QtLogger::Logger::instance())

#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
#    define QRMUTEX QRecursiveMutex
#else
#    define QRMUTEX QMutex
#endif

namespace QtLogger {

class QTLOGGER_EXPORT Logger :
#ifndef QTLOGGER_NO_THREAD
    public OwnThreadHandler<SimplePipeline>
#else
    public SimplePipeline
#endif
{
public:
    static Logger *instance();

    Logger() = default;
    ~Logger() override;

    void configure(const QString &path = {}, int maxFileSize = 0, int maxFileCount = 0,
                   RotatingFileSink::Options options = RotatingFileSink::Option::None,
                   bool async = true);

    void configure(const QSettings &settings, const QString &group = QStringLiteral("logger"));
    void configureFromIniFile(const QString &path, const QString &group = QStringLiteral("logger"));

    Logger &operator<<(const HandlerPtr &handler);

public:
    void installMessageHandler();
    static void restorePreviousMessageHandler();

    void processMessage(QtMsgType type, const QMessageLogContext &context, const QString &message);

    static void messageHandler(QtMsgType type, const QMessageLogContext &context,
                               const QString &message);

#ifndef QTLOGGER_NO_THREAD
public:
    void lock() const;
    void unlock() const;
    inline QRMUTEX *mutex() const { return &m_mutex; }

private:
#    if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
    mutable QRecursiveMutex m_mutex;
#    else
    mutable QMutex m_mutex { QMutex::Recursive };
#    endif
#endif
};

inline Logger &operator<<(Logger *logger, const HandlerPtr &handler)
{
    return *logger << handler;
}

inline Logger &operator<<(Logger *logger, const Pipeline &pipeline)
{
    return *logger << PipelinePtr::create(pipeline);
}

} // namespace QtLogger

// end logger.h

// messagepatterns.h

namespace QtLogger {

constexpr char DefaultMessagePattern[] = "%{if-category}%{category}: %{endif}"
                                         "%{message}";

constexpr char PrettyMessagePattern[] = "%{time dd.MM.yyyy hh:mm:ss.zzz} "
                                        "%{if-debug} %{endif}"
                                        "%{if-info}I%{endif}"
                                        "%{if-warning}W%{endif}"
                                        "%{if-critical}E%{endif}"
                                        "%{if-fatal}F%{endif} "
                                        "[%{category}] %{message}";

} // namespace QtLogger

// end messagepatterns.h

// platformstdsink.h

#include <QSharedPointer>

#if defined(QTLOGGER_ANDROIDLOG)

// androidlogsink.h

#ifdef QTLOGGER_ANDROIDLOG

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT AndroidLogSink : public Sink
{
public:
    void send(const LogMessage &lmsg) override;
};

using AndroidLogSinkPtr = QSharedPointer<AndroidLogSink>;

} // namespace QtLogger

#endif // QTLOGGER_ANDROIDLOG

// end androidlogsink.h

#elif defined(QTLOGGER_OSLOG)

// oslogsink.h

#ifdef QTLOGGER_OSLOG

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT OslogSink : public Sink
{
public:
    void send(const LogMessage &lmsg);
};

using OslogSinkPtr = QSharedPointer<OslogSink>;

} // namespace QtLogger

#endif // QTLOGGER_OSLOG

// end oslogsink.h

#else

// stderrsink.h

#include <QSharedPointer>

// coloredconsole.h

#include <QString>
#include <qlogging.h>

namespace QtLogger {

enum class ColorMode {
    Auto, // Enable colors if output is a TTY
    Always, // Always enable colors
    Never // Never use colors
};

class QTLOGGER_EXPORT ColoredConsole
{
public:
    explicit ColoredConsole(ColorMode colorMode = ColorMode::Auto);
    virtual ~ColoredConsole();

    void setColorMode(ColorMode mode);
    ColorMode colorMode() const;
    bool colorsEnabled() const;

    static QString colorPrefix(QtMsgType type);
    static QString colorReset();
    static QString colorize(const QString &message, QtMsgType type);
    static bool isStdOutTty();
    static bool isStdErrTty();

protected:
    virtual bool isTty() const = 0;

    void updateColorsEnabled();

    ColorMode m_colorMode = ColorMode::Auto;
    bool m_colorsEnabled = false;
};

} // namespace QtLogger

// end coloredconsole.h

namespace QtLogger {

class QTLOGGER_EXPORT StdErrSink : public Sink, public ColoredConsole
{
public:
    explicit StdErrSink(ColorMode colorMode = ColorMode::Never);

    void send(const LogMessage &lmsg) override;
    bool flush() override;

protected:
    bool isTty() const override;
};

using StdErrSinkPtr = QSharedPointer<StdErrSink>;

} // namespace QtLogger

// end stderrsink.h

#endif

namespace QtLogger {

#if defined(QTLOGGER_ANDROIDLOG)
using PlatformStdSink = AndroidLogSink;
#elif defined(QTLOGGER_OSLOG)
using PlatformStdSink = OslogSink;
#else
using PlatformStdSink = StdErrSink;
#endif

using PlatformStdSinkPtr = QSharedPointer<PlatformStdSink>;

}

// end platformstdsink.h

// signalsink.h

#include <QObject>

namespace QtLogger {

class QTLOGGER_EXPORT SignalSink : public QObject, public Sink
{
    Q_OBJECT

public:
    explicit SignalSink(QObject *parent = nullptr);

    void send(const LogMessage &lmsg) override;

Q_SIGNALS:
    void message(const QtLogger::LogMessage &lmsg);
};

using SignalSinkPtr = QSharedPointer<SignalSink>;

} // namespace QtLogger

// end signalsink.h

// stdoutsink.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT StdOutSink : public Sink, public ColoredConsole
{
public:
    explicit StdOutSink(ColorMode colorMode = ColorMode::Never);

    void send(const LogMessage &lmsg) override;
    bool flush() override;

protected:
    bool isTty() const override;
};

using StdOutSinkPtr = QSharedPointer<StdOutSink>;

} // namespace QtLogger

// end stdoutsink.h

// utils.h

#include <qlogging.h>

namespace QtLogger {

/** Set global filter rules
 *
 *  Format:  "[<category>|*].[debug|info|warning|critical]=true|false;..."
 *  Example: "app.*.debug=false;app.logger.debug=true"
 */

QTLOGGER_EXPORT void setFilterRules(const QString &rules);

/** Set global message pattern
 *
 * Following placeholders are supported:
 * %{appname} %{category} %{file} %{function} %{line} %{message} %{pid} %{threadid}
 * %{qthreadptr} %{type} %{time process} %{time boot} %{time [format]} %{backtrace [depth=N]
 * [separator="..."]}
 */

QTLOGGER_EXPORT QString setMessagePattern(const QString &messagePattern);

QTLOGGER_EXPORT QString restorePreviousMessagePattern();

} // namespace QtLogger

// end utils.h

#ifdef QTLOGGER_NETWORK

// hostinfoattrs.h

#ifdef QTLOGGER_NETWORK

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT HostInfoAttrs : public AttrHandler
{
public:
    HostInfoAttrs();

    QVariantHash attributes(const LogMessage &lmsg) override;

private:
    QVariantHash m_attrs;
};

using HostInfoAttrsPtr = QSharedPointer<HostInfoAttrs>;

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// end hostinfoattrs.h

// httpsink.h

#ifdef QTLOGGER_NETWORK

#include <QNetworkRequest>
#include <QSharedPointer>
#include <QPointer>
#include <QUrl>

QT_FORWARD_DECLARE_CLASS(QNetworkAccessManager)

namespace QtLogger {

class QTLOGGER_EXPORT HttpSink : public Sink
{
public:
    using Headers = QList<QPair<QByteArray, QByteArray>>;

    explicit HttpSink(const QUrl &url);
    HttpSink(const QUrl &url, const Headers &headers);
    ~HttpSink();

    void send(const LogMessage &lmsg) override;

    void setNetworkAccessManager(QNetworkAccessManager *manager);
    void setRequest(const QNetworkRequest &request);
    void setHeaders(const Headers &headers);

private:
    void init();

    QUrl m_url;
    Headers m_headers;
    QPointer<QNetworkAccessManager> m_manager;
    QNetworkRequest m_request;
};

using HttpSinkPtr = QSharedPointer<HttpSink>;

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// end httpsink.h

#endif

#ifdef Q_OS_WIN

// windebugsink.h

#ifdef Q_OS_WIN

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT WinDebugSink : public Sink
{
public:
    void send(const LogMessage &lmsg) override;
};

using WinDebugSinkPtr = QSharedPointer<WinDebugSink>;

} // namespace QtLogger

#endif

// end windebugsink.h

#endif

#ifdef QTLOGGER_IOSLOG

#endif

#ifdef QTLOGGER_ANDROIDLOG

#endif

#ifdef QTLOGGER_SYSLOG

// syslogsink.h

#ifdef QTLOGGER_SYSLOG

#include <QSharedPointer>

// Syslog options
// See syslog.h for more information
#define QTLOGGER_SYSLOG_LOG_PID  0x01
#define QTLOGGER_SYSLOG_LOG_USER (1 << 3)

namespace QtLogger {

class QTLOGGER_EXPORT SyslogSink : public Sink
{
public:
    explicit SyslogSink(const QString &ident, int option = QTLOGGER_SYSLOG_LOG_PID,
                        int facility = QTLOGGER_SYSLOG_LOG_USER);
    ~SyslogSink();

    void send(const LogMessage &lmsg) override;
};

using SyslogSinkPtr = QSharedPointer<SyslogSink>;

} // namespace QtLogger

#endif // QTLOGGER_SYSLOG

// end syslogsink.h

#endif

#ifdef QTLOGGER_SDJOURNAL

// sdjournalsink.h

#ifdef QTLOGGER_SDJOURNAL

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT SdJournalSink : public Sink
{
public:
    void send(const LogMessage &lmsg) override;
};

using SdJournalSinkPtr = QSharedPointer<SdJournalSink>;

} // namespace QtLogger

#endif // QTLOGGER_SDJOURNAL

// end sdjournalsink.h

#endif

// appinfoattrs.cpp

#include <QCoreApplication>

namespace QtLogger {

QTLOGGER_DECL_SPEC
AppInfoAttrs::AppInfoAttrs()
{
    m_attrs = QVariantHash {
        { QStringLiteral("appname"), QCoreApplication::applicationName() },
        { QStringLiteral("appversion"), QCoreApplication::applicationVersion() },
        { QStringLiteral("appdir"), QCoreApplication::applicationDirPath() },
        { QStringLiteral("apppath"), QCoreApplication::applicationFilePath() },
        { QStringLiteral("pid"), QCoreApplication::applicationPid() },
    };
}

QTLOGGER_DECL_SPEC
QVariantHash AppInfoAttrs::attributes(const LogMessage &lmsg)
{
    Q_UNUSED(lmsg)
    return m_attrs;
}

} // namespace QtLogger

// hostinfoattrs.cpp

#ifdef QTLOGGER_NETWORK

#    include <QHostInfo>

namespace QtLogger {

QTLOGGER_DECL_SPEC
HostInfoAttrs::HostInfoAttrs()
{
    m_attrs = QVariantHash {
        { QStringLiteral("host_name"), QHostInfo::localHostName() },
    };
}

QTLOGGER_DECL_SPEC
QVariantHash HostInfoAttrs::attributes(const LogMessage &lmsg)
{
    Q_UNUSED(lmsg)
    return m_attrs;
}

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// seqnumberattr.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
SeqNumberAttr::SeqNumberAttr(const QString &name) : m_name(name) { }

QTLOGGER_DECL_SPEC
QVariantHash SeqNumberAttr::attributes(const LogMessage &lmsg)
{
    Q_UNUSED(lmsg)
    return { { m_name, m_count++ } };
}

} // namespace QtLogger

// sysinfoattrs.cpp

#include <QSysInfo>

namespace QtLogger {

QTLOGGER_DECL_SPEC
SysInfoAttrs::SysInfoAttrs()
{
    m_attrs = QVariantHash {
        { QStringLiteral("os_name"), QSysInfo::productType() },
        { QStringLiteral("os_version"), QSysInfo::productVersion() },
        { QStringLiteral("kernel_type"), QSysInfo::kernelType() },
        { QStringLiteral("kernel_version"), QSysInfo::kernelVersion() },
        { QStringLiteral("cpu_arch"), QSysInfo::currentCpuArchitecture() },
        { QStringLiteral("build_abi"), QSysInfo::buildAbi() },
        { QStringLiteral("build_cpu_arch"), QSysInfo::buildCpuArchitecture() },
        { QStringLiteral("pretty_product_name"), QSysInfo::prettyProductName() },
    };
}

QTLOGGER_DECL_SPEC
QVariantHash SysInfoAttrs::attributes(const LogMessage &lmsg)
{
    Q_UNUSED(lmsg)
    return m_attrs;
}

} // namespace QtLogger

// configure.cpp

#include <QLoggingCategory>
#include <QRegularExpression>
#include <QUrl>
#include <QtCore/QtGlobal>

#ifdef QTLOGGER_NETWORK

#endif

#ifdef QTLOGGER_SYSLOG

#endif

#ifdef QTLOGGER_SDJOURNAL

#endif

#ifdef QTLOGGER_OSLOG

#endif

#ifdef QTLOGGER_ANDROIDLOG

#endif

#ifndef QTLOGGER_NO_THREAD

#endif

namespace QtLogger {

QTLOGGER_DECL_SPEC
void configure(Pipeline *pipeline, const QString &path, int maxFileSize, int maxFileCount,
               RotatingFileSink::Options options, bool async)
{
    if (!pipeline) {
        return;
    }

    *pipeline << PrettyFormatterPtr::create(true);
    *pipeline << PlatformStdSinkPtr::create();

    if (!path.isEmpty()) {
        *pipeline << FunctionFormatterPtr::create([](const LogMessage &lmsg) {
            auto fmsg = lmsg.formattedMessage();
            static const QRegularExpression ansiEscape(QStringLiteral("\033\\[[0-9;]*m"));
            fmsg.remove(ansiEscape);
            return fmsg;
        });

        if (maxFileSize > 0 || options.testFlag(RotatingFileSink::RotationOnStartup)
            || options.testFlag(RotatingFileSink::RotationDaily)) {
            *pipeline << RotatingFileSinkPtr::create(path, maxFileSize, maxFileCount, options);
        } else {
            *pipeline << FileSinkPtr::create(path);
        }
    }

#ifndef QTLOGGER_NO_THREAD
    if (async) {
        auto *ownThreadLogger = dynamic_cast<OwnThreadHandler<SimplePipeline> *>(pipeline);
        if (ownThreadLogger) {
            ownThreadLogger->moveToOwnThread();
        }
    }
#else
    Q_UNUSED(async)
#endif
}

QTLOGGER_DECL_SPEC
void configure(Pipeline *pipeline, const QSettings &settings, const QString &group)
{
    if (!pipeline) {
        return;
    }

    const auto filterRules = settings.value(group + QStringLiteral("/filter_rules")).toString();
    if (!filterRules.isEmpty()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: filterRules: " << filterRules.toStdString() << std::endl;
#endif
        *pipeline << CategoryFilterPtr::create(filterRules);
    }

    const auto regExpFilter = settings.value(group + QStringLiteral("/regexp_filter")).toString();
    if (!regExpFilter.isEmpty()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: filter: " << regExpFilter.toStdString() << std::endl;
#endif
        *pipeline << RegExpFilterPtr::create(regExpFilter);
    }

    const auto messagePattern =
            settings.value(group + QStringLiteral("/message_pattern")).toString();
    if (!messagePattern.isEmpty()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: messagePattern: " << messagePattern.toStdString() << std::endl;
#endif
        *pipeline << PatternFormatterPtr::create(messagePattern);
    } else {
        *pipeline << PrettyFormatter::instance();
    }

    const auto stdout = settings.value(group + QStringLiteral("/stdout"), false).toBool();
    const auto stdoutColor =
            settings.value(group + QStringLiteral("/stdout_color"), false).toBool();
    if (stdout || stdoutColor) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: stdout (color=" << stdoutColor << ")" << std::endl;
#endif
        *pipeline << StdOutSinkPtr::create(stdoutColor ? ColorMode::Auto : ColorMode::Never);
    }

    const auto stderr = settings.value(group + QStringLiteral("/stderr"), false).toBool();
    const auto stderrColor =
            settings.value(group + QStringLiteral("/stderr_color"), false).toBool();
    if (stderr || stderrColor) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: stderr (color=" << stderrColor << ")" << std::endl;
#endif
        *pipeline << StdErrSinkPtr::create(stderrColor ? ColorMode::Auto : ColorMode::Never);
    }

    if (settings.value(group + QStringLiteral("/platform_std_log"), true).toBool()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: platform_std_log" << std::endl;
#endif
        *pipeline << PlatformStdSinkPtr::create();
    }

#ifdef QTLOGGER_SYSLOG
    const auto syslogIdent = settings.value(group + QStringLiteral("/syslog_ident")).toString();
    if (!syslogIdent.isEmpty()) {
#    ifdef QTLOGGER_DEBUG
        std::cerr << "configure: syslogIdent: " << syslogIdent.toStdString() << std::endl;
#    endif
        *pipeline << SyslogSinkPtr::create(syslogIdent);
    }
#endif

#ifdef QTLOGGER_SDJOURNAL
    if (settings.value(group + QStringLiteral("/sdjournal"), false).toBool()) {
#    ifdef QTLOGGER_DEBUG
        std::cerr << "configure: sd-journal" << std::endl;
#    endif
        *pipeline << SdJournalSinkPtr::create();
    }
#endif

    const auto path = settings.value(group + QStringLiteral("/path")).toString();
    if (!path.isEmpty()) {
        const auto maxFileSize = settings.value(group + QStringLiteral("/max_file_size"),
                                                RotatingFileSink::DefaultMaxFileSize)
                                         .toInt();

        const auto maxFileCount = settings.value(group + QStringLiteral("/max_file_count"),
                                                 RotatingFileSink::DefaultMaxFileCount)
                                          .toInt();

        const auto rotateOnStartup =
                settings.value(group + QStringLiteral("/rotate_on_startup"), true).toBool();

        const auto rotateDaily =
                settings.value(group + QStringLiteral("/rotate_daily"), false).toBool();

        const auto compress =
                settings.value(group + QStringLiteral("/compress_old_files"), false).toBool();

#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: path: " << path.toStdString() << " maxFileSize: " << maxFileSize
                  << " maxFileCount: " << maxFileCount << " rotateOnStartup: " << rotateOnStartup
                  << " rotateDaily: " << rotateDaily << " compress: " << compress << std::endl;
#endif

        RotatingFileSink::Options options = RotatingFileSink::Option::None;
        if (rotateOnStartup)
            options |= RotatingFileSink::RotationOnStartup;
        if (rotateDaily)
            options |= RotatingFileSink::RotationDaily;
        if (compress)
            options |= RotatingFileSink::Option::Compression;

        *pipeline << RotatingFileSinkPtr::create(path, maxFileSize, maxFileCount, options);
    }

#ifdef QTLOGGER_NETWORK
    const auto httpUrl = settings.value(group + QStringLiteral("/http_url")).toString();
    if (!httpUrl.isEmpty()) {
        const auto httpMsgFormat = settings.value(group + QStringLiteral("/http_msg_format"),
                                                  QStringLiteral("default"))
                                           .toString();
        // TODO: add support for http_msg_format (json)
        *pipeline << HttpSinkPtr::create(QUrl(httpUrl));
    }
#endif

#ifndef QTLOGGER_NO_THREAD
    if (settings.value(group + QStringLiteral("/async"), false).toBool()) {
#    ifdef QTLOGGER_DEBUG
        std::cerr << "configure: async" << std::endl;
#    endif
        auto *ownThreadLogger = dynamic_cast<OwnThreadHandler<SimplePipeline> *>(pipeline);
        if (ownThreadLogger) {
            ownThreadLogger->moveToOwnThread();
        }
    }
#endif
}

QTLOGGER_DECL_SPEC
void configureFromIniFile(Pipeline *pipeline, const QString &path, const QString &group)
{
    configure(pipeline, QSettings(path, QSettings::IniFormat), group);
}

} // namespace QtLogger

// categoryfilter.cpp

#include <QRegularExpression>
#include <qlogging.h>

namespace QtLogger {

struct CategoryFilter::Rule
{
    QRegularExpression category;
    QtMsgType type;
    bool typeMatch;
    bool enabled;

    bool matches(const QString &category, QtMsgType messageType) const;
};

QTLOGGER_DECL_SPEC
CategoryFilter::CategoryFilter(const QString &a_rules)
{
    auto rules = a_rules;
    rules.replace(";", "\n");
    parseRules(rules);
}

QTLOGGER_DECL_SPEC
void CategoryFilter::parseRules(const QString &rules)
{
#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
    const auto lines = rules.split('\n', Qt::SkipEmptyParts);
#else
    const auto lines = rules.split('\n', QString::SkipEmptyParts);
#endif
    for (const auto &line : lines) {
        const auto ruleRegex = QRegularExpression(
                R"(^\s*(\S+?)(?:\.(debug|info|warning|critical))?\s*=\s*(true|false)\s*$)");

        const auto match = ruleRegex.match(line);

        if (!match.hasMatch())
            continue;

        auto rule = QSharedPointer<Rule>::create();

        auto category = match.captured(1);
        category = QRegularExpression::escape(category);
        category.replace("\\*", ".*");

        rule->category = QRegularExpression("^" + category + "$");
        rule->type = stringToQtMsgType(match.captured(2));
        rule->typeMatch = !match.captured(2).isEmpty();
        rule->enabled = match.captured(3) == "true";

        m_rules.append(rule);
    }
}

QTLOGGER_DECL_SPEC
bool CategoryFilter::Rule::matches(const QString &category, QtMsgType messageType) const
{
    return this->category.match(category).hasMatch() && (!typeMatch || type == messageType);
}

QTLOGGER_DECL_SPEC
bool CategoryFilter::filter(const LogMessage &lmsg)
{
    bool enabled = true;
    for (const auto &rule : std::as_const(m_rules)) {
        if (rule->matches(lmsg.category(), lmsg.type())) {
            enabled = rule->enabled;
        }
    }
    return enabled;
}

} // namespace QtLogger

// duplicatefilter.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
bool DuplicateFilter::filter(const LogMessage &lmsg)
{
    if (lmsg.message() == m_lastMessage) {
        return false;
    }

    m_lastMessage = lmsg.message();

    return true;
}

} // namespace QtLogger

// regexpfilter.cpp

#include <QRegularExpression>

namespace QtLogger {

QTLOGGER_DECL_SPEC
RegExpFilter::RegExpFilter(const QRegularExpression &regExp) : m_regExp(regExp) { }

QTLOGGER_DECL_SPEC
QtLogger::RegExpFilter::RegExpFilter(const QString &regExp) : m_regExp(QRegularExpression(regExp))
{
}

QTLOGGER_DECL_SPEC
bool RegExpFilter::filter(const LogMessage &lmsg)
{
    return m_regExp.match(lmsg.message()).hasMatch();
}

} // namespace QtLogger

// jsonformatter.cpp

#include <QCoreApplication>
#include <QJsonDocument>
#include <QJsonObject>

namespace QtLogger {

JsonFormatter::JsonFormatter(bool compact)
    : m_compact(compact)
{
}

QTLOGGER_DECL_SPEC
QString JsonFormatter::format(const LogMessage &lmsg)
{
    QJsonObject obj;

    const auto attrs = lmsg.allAttributes();
    for (auto it = attrs.cbegin(); it != attrs.cend(); ++it) {
        obj.insert(it.key(), QJsonValue::fromVariant(it.value()));
    }

    return QString::fromUtf8(QJsonDocument(obj).toJson(m_compact ? QJsonDocument::Compact
                                                                 : QJsonDocument::Indented));
}

} // namespace QtLogger

// patternformatter.cpp

#include <optional>

#include <QSharedPointer>

namespace QtLogger {

namespace {

static const auto g_processStartTime = std::chrono::steady_clock::now();

static const QChar DEL_MARKER = QChar(0x200B);

class Token
{
public:
    virtual ~Token() = default;
    virtual size_t estimatedLength() const = 0;
    virtual bool checkCondition(const LogMessage &) const { return true; }
    virtual void appendToString(const LogMessage &lmsg, QString &dest) const = 0;
};

class ConditionToken : public Token
{
public:
    bool checkCondition(const LogMessage &lmsg) const override
    {
        if (!m_hasCondition) {
            return true;
        }
        return lmsg.type() == m_condition;
    }

    QtMsgType condition() const { return m_condition; }

    void setCondition(QtMsgType condition)
    {
        m_condition = condition;
        m_hasCondition = true;
    }

private:
    QtMsgType m_condition = QtDebugMsg;
    bool m_hasCondition = false;
};

class FormattedToken : public ConditionToken
{
public:
    enum class Alignment { None, Left, Right, Center };
    enum class TruncateMode { None, Truncate, TruncateOnly };

    struct FormatSpec
    {
        QChar fill = QLatin1Char(' ');
        Alignment align = Alignment::None;
        int width = 0;
        TruncateMode truncateMode = TruncateMode::None;
    };

    void setFormatSpec(const FormatSpec &spec) { m_spec = spec; }

    static std::optional<FormatSpec> parseFormatSpec(const QString &specString)
    {
        if (specString.isEmpty())
            return std::nullopt;

        QString s = specString;
        int pos = 0;
        FormatSpec spec;
        bool hasExplicitFill = false;
        bool hasTruncateSuffix = false;

        if (s.endsWith(QLatin1Char('!'))) {
            hasTruncateSuffix = true;
            s.chop(1);
            if (s.isEmpty())
                return std::nullopt;
        }

        // Check if we have fill + align (fill is any char, align is <, >, ^)
        if (s.length() >= 2) {
            QChar possibleAlign = s.at(1);
            if (QStringLiteral("<^>").contains(possibleAlign)) {
                spec.fill = s.at(0);
                spec.align = charToAlignment(possibleAlign);
                hasExplicitFill = true;
                pos = 2;
            }
        }

        // If no fill+align found, check for just align
        if (spec.align == Alignment::None && !s.isEmpty()) {
            QChar possibleAlign = s.at(0);
            if (QStringLiteral("<^>").contains(possibleAlign)) {
                spec.align = charToAlignment(possibleAlign);
                pos = 1;
            }
        }

        // If no align found, check if it's just a number (only valid with !)
        if (spec.align == Alignment::None && hasTruncateSuffix) {
            // Try to parse entire remaining string as width
            bool ok;
            spec.width = s.toInt(&ok);
            if (ok && spec.width > 0) {
                spec.truncateMode = TruncateMode::TruncateOnly;
                return spec;
            }
            return std::nullopt;
        }

        // If no align found at all (and not truncate-only), this is not a valid format spec
        if (spec.align == Alignment::None)
            return std::nullopt;

        // Parse width (remaining characters should be digits)
        if (pos >= s.length())
            return std::nullopt;

        QString widthStr = s.mid(pos);
        bool ok;
        spec.width = widthStr.toInt(&ok);
        if (!ok || spec.width <= 0)
            return std::nullopt;

        // Determine truncate mode
        if (hasTruncateSuffix) {
            spec.truncateMode = hasExplicitFill ? TruncateMode::Truncate : TruncateMode::TruncateOnly;
        }

        return spec;
    }

    bool hasFormatSpec() const
    {
        return m_spec.width > 0
               && (m_spec.align != Alignment::None
                   || m_spec.truncateMode == TruncateMode::TruncateOnly);
    }

    static Alignment charToAlignment(QChar ch)
    {
        switch (ch.unicode()) {
        case '<':
            return Alignment::Left;
        case '>':
            return Alignment::Right;
        case '^':
            return Alignment::Center;
        default:
            return Alignment::None;
        }
    }

    int formatWidth() const { return m_spec.width; }

protected:
    QString applyPadding(const QString &value) const
    {
        if (m_spec.width <= 0) {
            return value;
        }

        if (m_spec.truncateMode == TruncateMode::TruncateOnly) {
            if (value.length() <= m_spec.width) {
                return value;
            }
            if (m_spec.align == Alignment::Right) {
                return value.right(m_spec.width);
            } else {
                return value.left(m_spec.width);
            }
        }

        if (m_spec.align == Alignment::None) {
            return value;
        }

        QString val = value;

        if (m_spec.truncateMode == TruncateMode::Truncate
            && val.length() > m_spec.width) {
            if (m_spec.align == Alignment::Right) {
                val = val.right(m_spec.width);
            } else {
                val = val.left(m_spec.width);
            }
        }

        if (val.length() >= m_spec.width) {
            return val;
        }

        int padding = m_spec.width - val.length();
        QString result;
        result.reserve(m_spec.width);

        switch (m_spec.align) {
        case Alignment::Left:
            result.append(val);
            result.append(QString(padding, m_spec.fill));
            break;
        case Alignment::Right:
            result.append(QString(padding, m_spec.fill));
            result.append(val);
            break;
        case Alignment::Center: {
            int leftPad = padding / 2;
            int rightPad = padding - leftPad;
            result.append(QString(leftPad, m_spec.fill));
            result.append(val);
            result.append(QString(rightPad, m_spec.fill));
            break;
        }
        case Alignment::None:
            return val;
        }

        return result;
    }

private:
    FormatSpec m_spec;
};

class LiteralToken : public FormattedToken
{
public:
    explicit LiteralToken(const QString &text) : m_text(text) { }

    void appendToString(const LogMessage &, QString &dest) const override
    {
        int removeCount = 0;
        while (!dest.isEmpty() && dest.at(dest.size() - 1) == DEL_MARKER) {
            dest.chop(1);
            removeCount++;
        }

        if (removeCount > 0 && removeCount < m_text.size()) {
            dest.append(m_text.mid(removeCount));
        } else if (removeCount == 0) {
            dest.append(m_text);
        }

        // If removeCount >= m_text.size(), append nothing
    }

    size_t estimatedLength() const override { return m_text.size(); }

private:
    QString m_text;
};

class MessageToken : public FormattedToken
{
public:
    MessageToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        dest.append(applyPadding(lmsg.message()));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 50; // Estimated average message length
    }
};

class TypeToken : public FormattedToken
{
public:
    TypeToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        dest.append(applyPadding(qtMsgTypeToString(lmsg.type())));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 8; // Maximum length of "critical"
    }
};

class LineToken : public FormattedToken
{
public:
    LineToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        dest.append(applyPadding(QString::number(lmsg.line())));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 5; // Maximum length of "99999"
    }
};

class FileToken : public FormattedToken
{
public:
    FileToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        dest.append(applyPadding(lmsg.file()));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 20; // Maximum length of "path/to/file.cpp"
    }
};

class ShortFileToken : public FormattedToken
{
public:
    ShortFileToken(const QString &baseDir = QString()) : m_baseDir(baseDir) { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        QString file = lmsg.file();
        QString value;
        if (m_baseDir.isEmpty()) {
            // No basedir specified - return only filename without directory
            int lastSlash = file.lastIndexOf(QLatin1Char('/'));
            if (lastSlash == -1) {
                lastSlash = file.lastIndexOf(QLatin1Char('\\'));
            }
            if (lastSlash != -1) {
                value = file.mid(lastSlash + 1);
            } else {
                value = file;
            }
        } else {
            // Strip basedir prefix if present
            if (file.startsWith(m_baseDir)) {
                QString result = file.mid(m_baseDir.length());
                // Remove leading slash if present
                if (result.startsWith(QLatin1Char('/')) || result.startsWith(QLatin1Char('\\'))) {
                    result = result.mid(1);
                }
                value = result;
            } else {
                value = file;
            }
        }
        dest.append(applyPadding(value));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 20;
    }

private:
    QString m_baseDir;
};

class FunctionToken : public FormattedToken
{
public:
    FunctionToken(bool cleanup = true) : m_cleanup(cleanup) { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        QString value;
        if (m_cleanup) {
            value = QString::fromLatin1(cleanup(lmsg.function()));
        } else {
            value = QString::fromLatin1(lmsg.function());
        }
        dest.append(applyPadding(value));
    }

    size_t estimatedLength() const override
    {
        if (hasFormatSpec())
            return formatWidth();
        return m_cleanup ? 20 : 40;
    }

private:
    bool m_cleanup;

    static QByteArray cleanup(QByteArray func)
    {
        if (func.isEmpty())
            return func;

        // Helper lambda: find balanced bracket in reverse
        auto findBalancedReverse = [&func](char open, char close, int startPos) -> int {
            if (startPos <= 0)
                return -1;
            int count = 1;
            int pos = startPos - 1;
            while (pos >= 0 && count > 0) {
                char c = func.at(pos);
                if (c == close)
                    ++count;
                else if (c == open)
                    --count;
                --pos;
            }
            return (count == 0) ? pos + 1 : -1;
        };

        // Remove compiler metadata like [with T = int]
        if (func.endsWith(']') && !func.startsWith('+') && !func.startsWith('-')) {
            int openBracket = findBalancedReverse('[', ']', func.size() - 1);
            if (openBracket != -1)
                func.truncate(openBracket);
        }
        while (func.endsWith(' '))
            func.chop(1);

        // Normalize operator spacing
        func.replace("operator ", "operator");

        // Try to handle function pointer return types: returntype (*name(args))(return_args)
        bool handledFunctionPointer = false;
        int parenOpenIdx = func.indexOf(")(");
        if (parenOpenIdx != -1) {
            int ptrParen = func.indexOf("(*");
            if (ptrParen != -1 && ptrParen < parenOpenIdx) {
                int nameStart = ptrParen + 2;
                int parenDepth = 0;
                int argsParen = -1;
                for (int i = nameStart; i < parenOpenIdx; ++i) {
                    char c = func.at(i);
                    if (c == '(') {
                        if (parenDepth == 0)
                            argsParen = i;
                        ++parenDepth;
                    } else if (c == ')') {
                        --parenDepth;
                    }
                }
                if (argsParen != -1 && argsParen > nameStart) {
                    func = func.mid(nameStart, argsParen - nameStart);
                    handledFunctionPointer = true;
                }
            }
        }

        if (!handledFunctionPointer) {
            // Remove function arguments
            int end = func.lastIndexOf(')');
            if (end != -1) {
                int openParen = findBalancedReverse('(', ')', end);
                if (openParen != -1) {
                    bool isOperatorCall = false;
                    if (openParen >= 8 && func.mid(openParen - 8, 8) == "operator") {
                        // Check that 'operator' is not part of a longer identifier
                        if (openParen == 8) {
                            isOperatorCall = true;
                        } else {
                            char prevChar = func.at(openParen - 9);
                            if (!QChar::isLetterOrNumber(prevChar) && prevChar != '_') {
                                isOperatorCall = true;
                            }
                        }
                    }
                    if (!isOperatorCall)
                        func.truncate(openParen);
                }
            }

            // Remove trailing qualifiers
            static const char *const qualifiers[] = { " const", " volatile", " noexcept",
                                                      " override", " final" };
            bool found;
            do {
                found = false;
                for (const char *qual : qualifiers) {
                    if (func.endsWith(qual)) {
                        func.chop(static_cast<int>(qstrlen(qual)));
                        found = true;
                        break;
                    }
                }
            } while (found);

            // Extract function name (remove return type)
            int operatorPos = func.lastIndexOf("operator");
            if (operatorPos != -1) {
                int scanPos = operatorPos - 1;
                while (scanPos >= 0 && func.at(scanPos) == ' ')
                    --scanPos;

                bool extracted = false;
                while (scanPos >= 0) {
                    if (scanPos >= 1 && func.at(scanPos) == ':' && func.at(scanPos - 1) == ':') {
                        scanPos -= 2;
                        while (scanPos >= 0 && func.at(scanPos) == ' ')
                            --scanPos;
                        if (scanPos >= 0 && func.at(scanPos) == ')') {
                            int op = findBalancedReverse('(', ')', scanPos + 1);
                            if (op != -1) {
                                scanPos = op - 1;
                                continue;
                            }
                        }
                        if (scanPos >= 0 && func.at(scanPos) == '>') {
                            int oa = findBalancedReverse('<', '>', scanPos + 1);
                            if (oa != -1) {
                                scanPos = oa - 1;
                                continue;
                            }
                        }
                        while (scanPos >= 0
                               && (QChar(func.at(scanPos)).isLetterOrNumber()
                                   || func.at(scanPos) == '_'))
                            --scanPos;
                    } else if (func.at(scanPos) == ' ') {
                        func = func.mid(scanPos + 1);
                        extracted = true;
                        break;
                    } else {
                        break;
                    }
                }
                if (!extracted) {
                    int firstSpace = func.indexOf(' ');
                    if (firstSpace != -1 && firstSpace < operatorPos)
                        func = func.mid(firstSpace + 1);
                }
            } else {
                int pos = func.size() - 1;
                int parenCount = 0, angleCount = 0;
                while (pos >= 0) {
                    char c = func.at(pos);
                    if (c == ')') {
                        ++parenCount;
                        --pos;
                        continue;
                    }
                    if (c == '(' && parenCount > 0) {
                        --parenCount;
                        --pos;
                        continue;
                    }
                    if (c == '>') {
                        ++angleCount;
                        --pos;
                        continue;
                    }
                    if (c == '<' && angleCount > 0) {
                        --angleCount;
                        --pos;
                        continue;
                    }
                    if (parenCount > 0 || angleCount > 0) {
                        --pos;
                        continue;
                    }
                    if (c == ' ') {
                        func = func.mid(pos + 1);
                        break;
                    }
                    --pos;
                }
            }
            while (func.startsWith('*') || func.startsWith('&') || func.startsWith(' '))
                func = func.mid(1);
        }

        // Remove empty parentheses before :: (e.g., method():: -> method::)
        int pos = 0;
        while ((pos = func.indexOf("()::", pos)) != -1) {
            if (pos >= 8 && func.mid(pos - 8, 8) == "operator") {
                pos += 4;
                continue;
            }
            int angleDepth = 0;
            bool insideTemplate = false;
            for (int i = pos - 1; i >= 0; --i) {
                if (func.at(i) == '>')
                    ++angleDepth;
                else if (func.at(i) == '<') {
                    if (angleDepth == 0) {
                        insideTemplate = true;
                        break;
                    }
                    --angleDepth;
                }
            }
            if (insideTemplate) {
                pos += 4;
                continue;
            }
            func.remove(pos, 2);
        }

        // Remove template parameters
        while (true) {
            int closeAngle = func.lastIndexOf('>');
            if (closeAngle == -1)
                break;
            int opCheck = func.lastIndexOf("operator", closeAngle);
            if (opCheck != -1) {
                int operatorEnd = opCheck + 8;
                if (operatorEnd <= closeAngle) {
                    bool isOperatorSymbol = true;
                    static const QByteArray operatorChars("=!+-*/%^&|~<>");
                    for (int i = operatorEnd; i <= closeAngle; ++i) {
                        char ch = func.at(i);
                        if (!operatorChars.contains(ch)) {
                            isOperatorSymbol = false;
                            break;
                        }
                    }
                    if (isOperatorSymbol)
                        break;
                }
            }
            int openAngle = findBalancedReverse('<', '>', closeAngle);
            if (openAngle == -1)
                break;
            if (openAngle >= 8 && func.mid(openAngle - 8, 8) == "operator")
                break;
            if (func.mid(openAngle + 1, closeAngle - openAngle - 1).startsWith("lambda"))
                break;
            func.remove(openAngle, closeAngle - openAngle + 1);
        }

        return func;
    }
};

class CategoryToken : public FormattedToken
{
public:
    CategoryToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        dest.append(applyPadding(lmsg.category()));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 20; // Maximum length of "categoryName"
    }
};

class TimeToken : public FormattedToken
{
public:
    explicit TimeToken(const QString &format = QString()) : m_format(format) { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        QString value;
        if (m_format == QLatin1String("process")) {
            // Time since process started in seconds
            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
                    lmsg.steadyTime() - g_processStartTime);
            double seconds = duration.count() / 1000.0;
            value = QString::number(seconds, 'f', 3);
        } else if (m_format == QLatin1String("boot")) {
            // Time since system boot in seconds using steady_clock epoch
            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
                    lmsg.steadyTime().time_since_epoch());
            double seconds = duration.count() / 1000.0;
            value = QString::number(seconds, 'f', 3);
        } else if (m_format.isEmpty()) {
            value = lmsg.time().toString(Qt::ISODate);
        } else {
            value = lmsg.time().toString(m_format);
        }
        dest.append(applyPadding(value));
    }

    size_t estimatedLength() const override
    {
        if (hasFormatSpec())
            return formatWidth();
        if (m_format == QLatin1String("process") || m_format == QLatin1String("boot")) {
            return 15; // Enough for "123456789.123"
        }
        return m_format.isEmpty() ? 20 : m_format.length() * 2; // Estimated length based on format
    }

private:
    QString m_format;
};

class ThreadIdToken : public FormattedToken
{
public:
    ThreadIdToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        dest.append(applyPadding(QString::number(lmsg.threadId())));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 10; // Maximum length of "9999999999"
    }
};

class QThreadPtrToken : public FormattedToken
{
public:
    QThreadPtrToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        QString value = QStringLiteral("0x") + QString::number(lmsg.qthreadptr(), 16);
        dest.append(applyPadding(value));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 18; // "0x" + 16 hex digits for 64-bit pointer
    }
};

class AttributeToken : public FormattedToken
{
public:
    explicit AttributeToken(const QString &attributeName, bool optional = false,
                            int removeBefore = 0, int removeAfter = 0)
        : m_attributeName(attributeName)
        , m_optional(optional)
        , m_removeBefore(removeBefore)
        , m_removeAfter(removeAfter)
    {
    }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        if (lmsg.hasAttribute(m_attributeName)) {
            dest.append(applyPadding(lmsg.attribute(m_attributeName).toString()));
            return;
        }

        if (!m_optional) {
            QString value = QStringLiteral("%{") + m_attributeName + QStringLiteral("}");
            dest.append(applyPadding(value));
            return;
        }

        // Optional attribute not found: remove characters before and add ZWSP markers for removeAfter
        if (m_removeBefore > 0 && dest.size() >= m_removeBefore) {
            dest.chop(m_removeBefore);
        }
        // Append ZWSP markers to signal how many chars to remove from next token
        for (int i = 0; i < m_removeAfter; ++i) {
            dest.append(DEL_MARKER);
        }
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 20; // Estimated average attribute value length
    }

private:
    QString m_attributeName;
    bool m_optional;
    int m_removeBefore;
    int m_removeAfter;
};

} // namespace

class PatternFormatter::PatternFormatterPrivate
{
public:
    explicit PatternFormatterPrivate(const QString &pattern) : m_pattern(pattern)
    {
        parsePattern();
    }

    void parsePattern()
    {
        m_tokens.clear();

        int pos = 0;
        QString literalText;
        QtMsgType currentCondition = QtDebugMsg;
        bool hasCondition = false;

        while (pos < m_pattern.length()) {
            if (pos < m_pattern.length() - 1 && m_pattern[pos] == '%') {
                if (m_pattern[pos + 1] == '{') {
                    if (!literalText.isEmpty()) {
                        auto token = new LiteralToken(literalText);
                        if (hasCondition) {
                            token->setCondition(currentCondition);
                        }
                        m_tokens.append(QSharedPointer<Token>(token));
                        literalText.clear();
                    }

                    int closingPos = m_pattern.indexOf('}', pos + 2);
                    if (closingPos == -1) {
                        // No closing brace, treat as literal
                        literalText.append('%');
                        pos++;
                        continue;
                    }

                    QString placeholder = m_pattern.mid(pos + 2, closingPos - pos - 2);

                    std::optional<FormattedToken::FormatSpec> formatSpec;

                    int lastColon = placeholder.lastIndexOf(QLatin1Char(':'));
                    if (lastColon != -1 && lastColon < placeholder.length() - 1) {
                        QString possibleSpec = placeholder.mid(lastColon + 1);
                        formatSpec = FormattedToken::parseFormatSpec(possibleSpec);
                        if (formatSpec) {
                            placeholder = placeholder.left(lastColon);
                        }
                    }

                    FormattedToken *token = nullptr;

                    if (placeholder == QLatin1String("type")) {
                        token = new TypeToken();
                    } else if (placeholder == QLatin1String("line")) {
                        token = new LineToken();
                    } else if (placeholder == QLatin1String("file")) {
                        token = new FileToken();
                    } else if (placeholder == QLatin1String("shortfile")
                               || placeholder.startsWith(QLatin1String("shortfile "))) {
                        QString baseDir;
                        if (placeholder.startsWith(QLatin1String("shortfile "))) {
                            baseDir = placeholder.mid(10).trimmed();
                        }
                        token = new ShortFileToken(baseDir);
                    } else if (placeholder == QLatin1String("function")) {
                        token = new FunctionToken(false);
                    } else if (placeholder == QLatin1String("func")) {
                        token = new FunctionToken(true);
                    } else if (placeholder == QLatin1String("category")) {
                        token = new CategoryToken();
                    } else if (placeholder == QLatin1String("time")
                               || placeholder.startsWith(QLatin1String("time "))) {
                        QString timeFormat;
                        if (placeholder.startsWith(QLatin1String("time "))) {
                            timeFormat = placeholder.mid(5).trimmed();
                        }
                        token = new TimeToken(timeFormat);
                    } else if (placeholder == QLatin1String("threadid")) {
                        token = new ThreadIdToken();
                    } else if (placeholder == QLatin1String("qthreadptr")) {
                        token = new QThreadPtrToken();
                    } else if (placeholder == QLatin1String("message")) {
                        token = new MessageToken();
                    } else if (placeholder.startsWith(QLatin1String("if-"))) {
                        // Handle conditional: %{if-debug}, %{if-warning}, etc.
                        QString conditionType = placeholder.mid(3); // Remove "if-"
                        currentCondition = stringToQtMsgType(conditionType, QtDebugMsg);
                        hasCondition = true;
                        pos = closingPos + 1;
                        continue;
                    } else if (placeholder == QLatin1String("endif")) {
                        hasCondition = false;
                        pos = closingPos + 1;
                        continue;
                    } else {
                        // Try to handle as custom attribute: %{attr} or %{attr?[N][,M]}
                        int questionPos = placeholder.indexOf(QLatin1Char('?'));
                        if (questionPos != -1) {
                            QString attrName = placeholder.left(questionPos);
                            QString suffix = placeholder.mid(questionPos + 1); // after '?'
                            int removeBefore = 0;
                            int removeAfter = 0;

                            int commaPos = suffix.indexOf(QLatin1Char(','));
                            if (commaPos == -1) {
                                // Only removeBefore: %{attr?N}
                                removeBefore = suffix.toInt();
                            } else {
                                // Both or only removeAfter: %{attr?N,M} or %{attr?,M}
                                if (commaPos > 0) {
                                    removeBefore = suffix.left(commaPos).toInt();
                                }
                                removeAfter = suffix.mid(commaPos + 1).toInt();
                            }
                            token = new AttributeToken(attrName, true, removeBefore, removeAfter);
                        } else {
                            token = new AttributeToken(placeholder);
                        }
                    }

                    if (token) {
                        if (hasCondition) {
                            token->setCondition(currentCondition);
                        }
                        if (formatSpec) {
                            token->setFormatSpec(*formatSpec);
                        }
                        m_tokens.append(QSharedPointer<Token>(token));
                    }

                    pos = closingPos + 1;
                } else if (m_pattern[pos + 1] == '%') {
                    // Escaped %, add single %
                    literalText.append('%');
                    pos += 2;
                } else {
                    // Just a regular %
                    literalText.append('%');
                    pos++;
                }
            } else {
                literalText.append(m_pattern[pos]);
                pos++;
            }
        }

        if (!literalText.isEmpty()) {
            auto token = new LiteralToken(literalText);
            if (hasCondition) {
                token->setCondition(currentCondition);
            }
            m_tokens.append(QSharedPointer<Token>(token));
        }
    }

    QString format(const LogMessage &lmsg)
    {
        if (m_tokens.isEmpty()) {
            return lmsg.message();
        }

        size_t estimatedLength = 0;
        for (const auto &token : std::as_const(m_tokens)) {
            if (token->checkCondition(lmsg)) {
                estimatedLength += token->estimatedLength();
            }
        }

        QString result;
        result.reserve(estimatedLength);

        for (const auto &token : std::as_const(m_tokens)) {
            if (token->checkCondition(lmsg)) {
                token->appendToString(lmsg, result);
            }
        }

        result.remove(DEL_MARKER);

        return result;
    }

    QString m_pattern;
    QList<QSharedPointer<Token>> m_tokens;
};

QTLOGGER_DECL_SPEC
PatternFormatter::PatternFormatter(const QString &pattern) : d(new PatternFormatterPrivate(pattern))
{
}

QTLOGGER_DECL_SPEC
PatternFormatter::~PatternFormatter() = default;

QTLOGGER_DECL_SPEC
QString PatternFormatter::format(const LogMessage &lmsg)
{
    return d->format(lmsg);
}

} // namespace QtLogger

// prettyformatter.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
PrettyFormatter::PrettyFormatter(bool colorize, int maxCategoryWidth)
    : m_colorize(colorize), m_maxCategoryWidth(maxCategoryWidth)
{
}

QTLOGGER_DECL_SPEC
QString PrettyFormatter::format(const LogMessage &lmsg)
{
    static const QString timeFormat = QStringLiteral("dd.MM.yyyy hh:mm:ss");
    static const QChar typeLetters[] = {
        QLatin1Char(' '), QLatin1Char('W'), QLatin1Char('E'),
        QLatin1Char('F'), QLatin1Char('I'), QLatin1Char('S')
    };

    // ANSI color codes
    static const QLatin1String reset("\033[0m");
    static const QLatin1String darkGray("\033[90m");
    static const QLatin1String bold("\033[1m");
    static const QLatin1String green("\033[32m");
    static const QLatin1String greenBold("\033[1;32m");
    static const QLatin1String orange("\033[38;5;172m");
    static const QLatin1String darkOrange("\033[38;5;208m");
    static const QLatin1String redBold("\033[1;31m");
    static const QLatin1String darkRedBold("\033[1;38;5;88m");

    static const QLatin1Char space(' ');
    static const QLatin1Char bracketOpen('[');
    static const QLatin1Char bracketClose(']');
    static const QLatin1Char letterT('T');

    const auto type = lmsg.type();
    const auto threadId = lmsg.threadId();
    const auto categoryRaw = lmsg.category();
    const bool isDefaultCategory = (qstrcmp(categoryRaw, "default") == 0);

    // Pre-calculate category string once if needed
    QString category;
    if (!isDefaultCategory) {
        category = QString::fromUtf8(categoryRaw);
    }

    // Estimate result size to minimize reallocations
    // DateTime(19) + space(1) + type(1) + space(1) + thread(~5) + category(~20) + message
    const int estimatedSize = 30 + category.size() + 4 + lmsg.message().size()
                              + (m_colorize ? 80 : 0);

    QString result;
    result.reserve(estimatedSize);

    // DateTime
    result += lmsg.time().toString(timeFormat);
    result += space;

    // Type letter with specific colors
    if (m_colorize) {
        switch (type) {
        case QtInfoMsg:
            result += greenBold;
            result += typeLetters[type];
            result += reset;
            break;
        case QtWarningMsg:
            result += darkOrange;
            result += typeLetters[type];
            result += reset;
            break;
        case QtCriticalMsg:
            result += redBold;
            result += typeLetters[type];
            result += reset;
            break;
        case QtFatalMsg:
            result += darkRedBold;
            result += typeLetters[type];
            result += reset;
            break;
        default:
            result += typeLetters[type];
            break;
        }
    } else {
        result += typeLetters[type];
    }

    result += space;

    // Thread handling with optimized lookup
    auto it = m_threads.find(threadId);
    if (it == m_threads.end()) {
        it = m_threads.insert(threadId, m_threadsIndex++);
    }

    if (m_threads.size() > 1) {
        const int index = it.value();
        if (index == 0) {
            // Calculate width needed for thread field
            int threadWidth = 3; // "T0 " minimum
            if (m_threadsIndex > 10) threadWidth = 4;
            if (m_threadsIndex > 100) threadWidth = 5;
            result += QString(threadWidth, space);
        } else {
            if (m_colorize) {
                result += bold;
            }
            result += letterT;
            result += QString::number(index);
            result += space;
            if (m_colorize) {
                result += reset;
            }
        }
    }

    // Category output (only if not default)
    const int categoryFormatLength = isDefaultCategory ? 0 : (category.size() + 3); // "[name] "
    if (!isDefaultCategory) {
        if (m_colorize) {
            result += darkGray;
        }
        result += bracketOpen;
        result += category;
        result += bracketClose;
        result += space;
        if (m_colorize) {
            result += reset;
        }
    }

    // Space for alignment
    if (m_maxCategoryWidth > 0) {
        if (categoryFormatLength > m_categoryWidth) {
            m_categoryWidth = qMin(categoryFormatLength, m_maxCategoryWidth);
        }
        const int spaceCount = m_categoryWidth - categoryFormatLength;
        if (spaceCount > 0) {
            result += QString(spaceCount, space);
        }
    }

    // Message with color
    if (m_colorize) {
        switch (type) {
        case QtInfoMsg:
            result += green;
            result += lmsg.message();
            result += reset;
            break;
        case QtWarningMsg:
            result += orange;
            result += lmsg.message();
            result += reset;
            break;
        case QtCriticalMsg:
            result += redBold;
            result += lmsg.message();
            result += reset;
            break;
        case QtFatalMsg:
            result += darkRedBold;
            result += lmsg.message();
            result += reset;
            break;
        default:
            result += lmsg.message();
            break;
        }
    } else {
        result += lmsg.message();
    }

    return result;
}

} // namespace QtLogger

// sentryformatter.cpp

#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QUuid>

namespace QtLogger {

namespace {

QTLOGGER_DECL_SPEC
QString qtMsgTypeToSentryLevel(QtMsgType type)
{
    switch (type) {
    case QtDebugMsg:
        return QStringLiteral("debug");
    case QtInfoMsg:
        return QStringLiteral("info");
    case QtWarningMsg:
        return QStringLiteral("warning");
    case QtCriticalMsg:
        return QStringLiteral("error");
    case QtFatalMsg:
        return QStringLiteral("fatal");
    default:
        return QStringLiteral("info");
    }
}

} // namespace

SentryFormatter::SentryFormatter(const QString &sdkName, const QString &sdkVersion)
    : m_sdkName(sdkName), m_sdkVersion(sdkVersion)
{
}

QTLOGGER_DECL_SPEC
QString SentryFormatter::format(const LogMessage &lmsg)
{
    QJsonObject event;

    // Required: Event ID (UUID without dashes)
#if QT_VERSION >= QT_VERSION_CHECK(5, 11, 0)
    auto eventId = QUuid::createUuid().toString(QUuid::Id128);
#else
    auto eventId = QUuid::createUuid().toString().remove(QLatin1Char('{')).remove(QLatin1Char('}')).remove(QLatin1Char('-'));
#endif
    event[QStringLiteral("event_id")] = eventId;

    // Required: Timestamp in ISO 8601 format
    event[QStringLiteral("timestamp")] = lmsg.time().toUTC().toString(Qt::ISODate);

    // Platform
    event[QStringLiteral("platform")] = QStringLiteral("native");

    // Severity level
    event[QStringLiteral("level")] = qtMsgTypeToSentryLevel(lmsg.type());

    // Logger name (category)
    auto category = QString::fromLatin1(lmsg.category());
    if (!category.isEmpty() && category != QLatin1String("default")) {
        event[QStringLiteral("logger")] = category;
    }

    // Message
    QJsonObject message;
    message[QStringLiteral("formatted")] = lmsg.message();
    event[QStringLiteral("message")] = message;

    // Transaction/culprit (function name)
    if (lmsg.function() && strlen(lmsg.function()) > 0) {
        event[QStringLiteral("culprit")] = QString::fromLatin1(lmsg.function());
    }

    // Tags
    QJsonObject tags;
    tags[QStringLiteral("qt_version")] = QString::fromLatin1(qVersion());
    if (lmsg.hasAttribute(QStringLiteral("appname"))) {
        tags[QStringLiteral("app_name")] = lmsg.attribute(QStringLiteral("appname")).toString();
    }
    if (lmsg.hasAttribute(QStringLiteral("appversion"))) {
        tags[QStringLiteral("app_version")] = lmsg.attribute(QStringLiteral("appversion")).toString();
    }
    event[QStringLiteral("tags")] = tags;

    // Extra context
    QJsonObject extra;
    extra[QStringLiteral("line")] = lmsg.line();
    if (lmsg.file() && strlen(lmsg.file()) > 0) {
        extra[QStringLiteral("file")] = QString::fromLatin1(lmsg.file());
    }
    extra[QStringLiteral("thread_id")] = QString::number(lmsg.threadId());

    // Add custom attributes to extra
    const auto attrs = lmsg.attributes();
    for (auto it = attrs.cbegin(); it != attrs.cend(); ++it) {
        // Skip already handled attributes
        if (it.key() == QLatin1String("appname") || it.key() == QLatin1String("appversion")
            || it.key() == QLatin1String("os_name") || it.key() == QLatin1String("os_version")
            || it.key() == QLatin1String("kernel_version") || it.key() == QLatin1String("build_abi")
            || it.key() == QLatin1String("cpu_arch") || it.key() == QLatin1String("host_name")) {
            continue;
        }
        extra[it.key()] = QJsonValue::fromVariant(it.value());
    }
    event[QStringLiteral("extra")] = extra;

    // Contexts
    QJsonObject contexts;

    // OS context (from SysInfoAttrs)
    QJsonObject osContext;
    if (lmsg.hasAttribute(QStringLiteral("os_name"))) {
        osContext[QStringLiteral("name")] = lmsg.attribute(QStringLiteral("os_name")).toString();
    }
    if (lmsg.hasAttribute(QStringLiteral("os_version"))) {
        osContext[QStringLiteral("version")] = lmsg.attribute(QStringLiteral("os_version")).toString();
    }
    if (lmsg.hasAttribute(QStringLiteral("kernel_version"))) {
        osContext[QStringLiteral("kernel_version")] = lmsg.attribute(QStringLiteral("kernel_version")).toString();
    }
    if (lmsg.hasAttribute(QStringLiteral("build_abi"))) {
        osContext[QStringLiteral("build")] = lmsg.attribute(QStringLiteral("build_abi")).toString();
    }
    if (!osContext.isEmpty()) {
        contexts[QStringLiteral("os")] = osContext;
    }

    // Device context
    QJsonObject deviceContext;
    if (lmsg.hasAttribute(QStringLiteral("cpu_arch"))) {
        deviceContext[QStringLiteral("arch")] = lmsg.attribute(QStringLiteral("cpu_arch")).toString();
    }
    if (lmsg.hasAttribute(QStringLiteral("host_name"))) {
        deviceContext[QStringLiteral("name")] = lmsg.attribute(QStringLiteral("host_name")).toString();
    }
    if (!deviceContext.isEmpty()) {
        contexts[QStringLiteral("device")] = deviceContext;
    }

    // Runtime context
    QJsonObject runtimeContext;
    runtimeContext[QStringLiteral("name")] = QStringLiteral("Qt");
    runtimeContext[QStringLiteral("version")] = QString::fromLatin1(qVersion());
    contexts[QStringLiteral("runtime")] = runtimeContext;

    event[QStringLiteral("contexts")] = contexts;

    // SDK info
    QJsonObject sdk;
    sdk[QStringLiteral("name")] = m_sdkName;
    sdk[QStringLiteral("version")] = m_sdkVersion;
    event[QStringLiteral("sdk")] = sdk;

    // Fingerprint (for grouping similar events)
    QJsonArray fingerprint;
    fingerprint.append(qtMsgTypeToSentryLevel(lmsg.type()));
    fingerprint.append(category.isEmpty() ? QStringLiteral("default") : category);
    fingerprint.append(lmsg.message().left(100)); // First 100 chars of message
    event[QStringLiteral("fingerprint")] = fingerprint;

    return QString::fromUtf8(QJsonDocument(event).toJson(QJsonDocument::Compact));
}

} // namespace QtLogger

// logger.cpp

#include <QFileInfo>
#include <QLoggingCategory>
#include <QScopedPointer>

#ifndef QTLOGGER_NO_THREAD
#    include <QAtomicPointer>
#    include <QMutexLocker>
#endif

namespace QtLogger {

namespace {

#ifndef QTLOGGER_NO_THREAD
QAtomicPointer<Logger> g_activeLogger;
#else
Logger *g_activeLogger = nullptr;
#endif

QtMessageHandler g_previousMessageHandler = nullptr;

}

QTLOGGER_DECL_SPEC
Logger *Logger::instance()
{
    static QScopedPointer<Logger> s_instance;

    if (!s_instance) {
        s_instance.reset(new Logger());
    }

    return s_instance.data();
}

QTLOGGER_DECL_SPEC
Logger::~Logger()
{
#ifndef QTLOGGER_NO_THREAD
    g_activeLogger.testAndSetOrdered(this, nullptr);
#else
    if (g_activeLogger == this) {
        g_activeLogger = nullptr;
    }
#endif
}

QTLOGGER_DECL_SPEC
void Logger::configure(const QString &path, int maxFileSize, int maxFileCount,
                       RotatingFileSink::Options options, bool async)
{
    QtLogger::configure(this, path, maxFileSize, maxFileCount, options, async);

    installMessageHandler();
}

QTLOGGER_DECL_SPEC
void Logger::configure(const QSettings &settings, const QString &group)
{
    QtLogger::configure(this, settings, group);

    installMessageHandler();
}

QTLOGGER_DECL_SPEC
void Logger::configureFromIniFile(const QString &path, const QString &group)
{
    configure(QSettings(path, QSettings::IniFormat), group);
}

QTLOGGER_DECL_SPEC
Logger &Logger::operator<<(const HandlerPtr &handler)
{
    append(handler);
    return *this;
}

QTLOGGER_DECL_SPEC
void Logger::processMessage(QtMsgType type, const QMessageLogContext &context,
                            const QString &message)
{
#ifndef QTLOGGER_NO_THREAD
    QMutexLocker locker(mutex());
#endif

    LogMessage lmsg(type, context, message);
    process(lmsg);
}

QTLOGGER_DECL_SPEC
void Logger::messageHandler(QtMsgType type, const QMessageLogContext &context,
                            const QString &message)
{
#ifndef QTLOGGER_NO_THREAD
    auto logger = g_activeLogger.loadAcquire();
#else
    auto logger = g_activeLogger;
#endif

    if (!logger)
        return;

    logger->processMessage(type, context, message);
}

QTLOGGER_DECL_SPEC
void Logger::installMessageHandler()
{
#ifndef QTLOGGER_NO_THREAD
    g_activeLogger.storeRelease(this);
#else
    g_activeLogger = this;
#endif

    auto prev = qInstallMessageHandler(messageHandler);

    if (prev != messageHandler) {
        g_previousMessageHandler = prev;
    }
}

QTLOGGER_DECL_SPEC
void Logger::restorePreviousMessageHandler()
{
    if (!g_previousMessageHandler)
        return;

    auto prev = qInstallMessageHandler(g_previousMessageHandler);

    if (prev != messageHandler) {
        qInstallMessageHandler(prev);
    }

    g_previousMessageHandler = nullptr;
}

#ifndef QTLOGGER_NO_THREAD

QTLOGGER_DECL_SPEC
void Logger::lock() const
{
    mutex()->lock();
}

QTLOGGER_DECL_SPEC
void Logger::unlock() const
{
    mutex()->unlock();
}

#endif

} // namespace QtLogger

// pipeline.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
Pipeline::Pipeline(std::initializer_list<HandlerPtr> handlers, bool scoped)
    : m_handlers(handlers), m_scoped(scoped)
{
}

QTLOGGER_DECL_SPEC
void Pipeline::append(const HandlerPtr &handler)
{
    if (handler.isNull())
        return;

    m_handlers.append(handler);
}

QTLOGGER_DECL_SPEC
void Pipeline::append(std::initializer_list<HandlerPtr> handlers)
{
    m_handlers.append(handlers);
}

QTLOGGER_DECL_SPEC
void Pipeline::remove(const HandlerPtr &handler)
{
    if (handler.isNull())
        return;

    m_handlers.removeAll(handler);
}

QTLOGGER_DECL_SPEC
void Pipeline::clear()
{
    m_handlers.clear();
}

QTLOGGER_DECL_SPEC
Pipeline &Pipeline::operator<<(const HandlerPtr &handler)
{
    append(handler);
    return *this;
}

QTLOGGER_DECL_SPEC
bool Pipeline::process(LogMessage &lmsg)
{
    QString fmsg;
    QVariantHash attrs;

    if (m_scoped) {
        if (lmsg.isFormatted()) {
            fmsg = lmsg.formattedMessage();
        }
        attrs = lmsg.attributes();
    }

    for (auto &handler : m_handlers) {
        if (!handler)
            continue;
        if (!handler->process(lmsg))
            break;
    }

    if (m_scoped) {
        lmsg.setFormattedMessage(fmsg);
        lmsg.setAttributes(attrs);
    }

    return true;
}

} // namespace QtLogger

// simplepipeline.cpp

#include <QCoreApplication>

#ifdef QTLOGGER_NETWORK

#endif

#ifdef QTLOGGER_SYSLOG

#endif

#ifdef QTLOGGER_ANDROIDLOG

#endif

#ifdef QTLOGGER_OSLOG

#endif

#ifdef QTLOGGER_SDJOURNAL

#endif

#ifdef Q_OS_WIN

#endif

namespace QtLogger {

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::addSeqNumber(const QString &name)
{
    append(SeqNumberAttrPtr::create(name));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::addAppInfo()
{
    append(AppInfoAttrsPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::addSysInfo()
{
    append(SysInfoAttrsPtr::create());
    return *this;
}

#ifdef QTLOGGER_NETWORK
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::addHostInfo()
{
    append(HostInfoAttrsPtr::create());
    return *this;
}
#endif

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::attrHandler(std::function<QVariantHash(const LogMessage &lmsg)> func)
{
    append(FunctionAttrHandlerPtr::create(func));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::filter(std::function<bool(const LogMessage &)> func)
{
    append(FunctionFilterPtr::create(func));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::filter(const QString &regexp)
{
    append(RegExpFilterPtr::create(regexp));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::filterLevel(QtMsgType minLevel)
{
    append(LevelFilterPtr::create(minLevel));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::filterCategory(const QString &rules)
{
    append(CategoryFilterPtr::create(rules));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::filterDuplicate()
{
    append(DuplicateFilterPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::format(std::function<QString(const LogMessage &)> func)
{
    append(FunctionFormatterPtr::create(func));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::format(const QString &pattern)
{
    if (pattern == "default")
        append(PatternFormatterPtr::create(DefaultMessagePattern));
    else if (pattern == "qt")
        append(QtLogMessageFormatter::instance());
    else if (pattern == "pretty")
        append(PrettyFormatterPtr::create());
    else
        append(PatternFormatterPtr::create(pattern));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::formatByQt()
{
    append(QtLogMessageFormatter::instance());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::formatPretty(bool colorize, int maxCategoryWidth)
{
    append(PrettyFormatterPtr::create(colorize, maxCategoryWidth));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::formatToJson(bool compact)
{
    append(JsonFormatterPtr::create(compact));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::formatToSentry(const QString &sdkName, const QString &sdkVersion)
{
    append(SentryFormatterPtr::create(sdkName, sdkVersion));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToStdOut(bool colorize)
{
    append(StdOutSinkPtr::create(colorize ? ColorMode::Auto : ColorMode::Never));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToStdErr(bool colorize)
{
    append(StdErrSinkPtr::create(colorize ? ColorMode::Auto : ColorMode::Never));
    return *this;
}

#ifdef QTLOGGER_SYSLOG
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToSyslog()
{
    append(SyslogSinkPtr::create(QCoreApplication::applicationName()));
    return *this;
}
#endif

#ifdef QTLOGGER_SDJOURNAL
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToSdJournal()
{
    append(SdJournalSinkPtr::create());
    return *this;
}
#endif

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToPlatformStdLog()
{
    append(PlatformStdSinkPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToFile(const QString &fileName, int maxFileSize,
                                           int maxFileCount, RotatingFileSink::Options options)
{
    if (fileName.isEmpty())
        return *this;

    if (maxFileSize > 0
        || options.testFlag(RotatingFileSink::RotationOnStartup)
        || options.testFlag(RotatingFileSink::RotationDaily)) {
        append(RotatingFileSinkPtr::create(fileName, maxFileSize, maxFileCount, options));
    }
    else {
        append(FileSinkPtr::create(fileName));
    }

    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToIODevice(const QIODevicePtr &device)
{
    append(IODeviceSinkPtr::create(device));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToSignal(QObject *receiver, const char *method)
{
    auto sink = SignalSinkPtr::create();
    QObject::connect(sink.data(), SIGNAL(message(QtLogger::LogMessage)), receiver, method);
    append(sink.staticCast<Sink>());
    return *this;
}

#ifdef QTLOGGER_NETWORK
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToHttp(const QString &url)
{
    append(HttpSinkPtr::create(QUrl(url)));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToHttp(const QString &url,
                                           const QList<QPair<QByteArray, QByteArray>> &headers)
{
    append(HttpSinkPtr::create(QUrl(url), headers));
    return *this;
}
#endif

#ifdef Q_OS_WIN
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToWinDebug()
{
    append(WinDebugSinkPtr::create());
    return *this;
}
#endif

#ifdef QTLOGGER_ANDROIDLOG
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToAndroidLog()
{
    append(AndroidLogSinkPtr::create());
    return *this;
}
#endif

#ifdef QTLOGGER_OSLOG
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToOsLog()
{
    append(OslogSinkPtr::create());
    return *this;
}
#endif

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::pipeline()
{
    auto pipeline = SimplePipelinePtr::create(/* scoped */ true, /* parent */ this);
    append(pipeline);
    return *pipeline.data();
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::end()
{
    if (m_parent)
        return *m_parent;
    else
        return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::handler(std::function<bool(LogMessage &)> func)
{
    append(FunctionHandlerPtr::create(std::move(func)));
    return *this;
}

QTLOGGER_DECL_SPEC
void SimplePipeline::recursiveFlush(const Pipeline *pipeline)
{
    for (const auto &handler : pipeline->handlers()) {
        if (auto sink = handler.dynamicCast<Sink>()) {
            sink->flush();
            continue;
        }
        if (auto pipeline = handler.dynamicCast<Pipeline>()) {
            recursiveFlush(pipeline.data());
        }
    }
}

QTLOGGER_DECL_SPEC
void SimplePipeline::flush()
{
    recursiveFlush(this);
}

} // namespace QtLogger

// androidlogsink.cpp

#ifdef QTLOGGER_ANDROIDLOG

#include <android/log.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void AndroidLogSink::send(const LogMessage &lmsg)
{
    auto priority = ANDROID_LOG_DEBUG;

    switch (lmsg.type()) {
    case QtDebugMsg:
        priority = ANDROID_LOG_DEBUG;
        break;
    case QtInfoMsg:
        priority = ANDROID_LOG_INFO;
        break;
    case QtWarningMsg:
        priority = ANDROID_LOG_WARN;
        break;
    case QtCriticalMsg:
        priority = ANDROID_LOG_ERROR;
        break;
    case QtFatalMsg:
        priority = ANDROID_LOG_FATAL;
        break;
    };

    __android_log_print(priority, lmsg.category(), "%s", qPrintable(lmsg.message()));

    // TODO: use __android_log_write_log_message for API level 30 and above
}

} // namespace QtLogger

#endif // QTLOGGER_ANDROIDLOG

// coloredconsole.cpp

#ifdef Q_OS_WIN
#    include <io.h>
#    include <stdio.h>
#    ifndef STDOUT_FILENO
#        define STDOUT_FILENO _fileno(stdout)
#    endif
#    ifndef STDERR_FILENO
#        define STDERR_FILENO _fileno(stderr)
#    endif
#    define isatty _isatty
#else
#    include <unistd.h>
#endif

namespace QtLogger {

QTLOGGER_DECL_SPEC
ColoredConsole::ColoredConsole(ColorMode colorMode) : m_colorMode(colorMode) { }

QTLOGGER_DECL_SPEC
ColoredConsole::~ColoredConsole() = default;

QTLOGGER_DECL_SPEC
void ColoredConsole::setColorMode(ColorMode mode)
{
    m_colorMode = mode;
    updateColorsEnabled();
}

QTLOGGER_DECL_SPEC
ColorMode ColoredConsole::colorMode() const
{
    return m_colorMode;
}

QTLOGGER_DECL_SPEC
bool ColoredConsole::colorsEnabled() const
{
    return m_colorsEnabled;
}

QTLOGGER_DECL_SPEC
QString ColoredConsole::colorPrefix(QtMsgType type)
{
    switch (type) {
    case QtDebugMsg:
        return QStringLiteral("\033[90m"); // Gray
    case QtInfoMsg:
        return QStringLiteral("\033[32m"); // Green
    case QtWarningMsg:
        return QStringLiteral("\033[33m"); // Yellow
    case QtCriticalMsg:
        return QStringLiteral("\033[31m"); // Red
    case QtFatalMsg:
        return QStringLiteral("\033[1;91m"); // Bold bright red
    default:
        return QString();
    }
}

QTLOGGER_DECL_SPEC
QString ColoredConsole::colorReset()
{
    return QStringLiteral("\033[0m");
}

QTLOGGER_DECL_SPEC
QString ColoredConsole::colorize(const QString &message, QtMsgType type)
{
    const QString prefix = colorPrefix(type);
    if (prefix.isEmpty()) {
        return message;
    }
    return prefix + message + colorReset();
}

QTLOGGER_DECL_SPEC
bool ColoredConsole::isStdOutTty()
{
    static const bool isTty = isatty(STDOUT_FILENO) != 0;
    return isTty;
}

QTLOGGER_DECL_SPEC
bool ColoredConsole::isStdErrTty()
{
    static const bool isTty = isatty(STDERR_FILENO) != 0;
    return isTty;
}

QTLOGGER_DECL_SPEC
void ColoredConsole::updateColorsEnabled()
{
    switch (m_colorMode) {
    case ColorMode::Always:
        m_colorsEnabled = true;
        break;
    case ColorMode::Never:
        m_colorsEnabled = false;
        break;
    case ColorMode::Auto:
    default:
        m_colorsEnabled = isTty();
        break;
    }
}

} // namespace QtLogger

// filesink.cpp

#include <QDateTime>
#include <QFile>
#include <QRegularExpression>
#include <QSharedPointer>

#include <iostream>

namespace QtLogger {

namespace {

/**
 * @brief Replaces the time pattern in the given string with the current date and time.
 *
 * This function searches for a time pattern in the format `%{time <format>}` within the input
 * string. If found, it replaces the pattern with the current date and time formatted according to
 * the specified format. If no format is specified, it defaults to "yyyyMMdd_hhmmss".
 *
 * @param path The input string potentially containing the time pattern.
 * @return A new string with the time pattern replaced by the current date and time.
 */

QTLOGGER_DECL_SPEC
QString replaceTimePattern(const QString &path)
{
    static auto re = QRegularExpression(QStringLiteral("(.*)%{time *(.*?)}(.*)"));
    auto match = re.match(path);

    if (!match.hasMatch())
        return path;

    auto format = match.captured(2);

    if (format.isEmpty()) {
        format = QStringLiteral("yyyyMMdd_hhmmss");
    }

    return match.captured(1) + QDateTime::currentDateTime().toString(format) + match.captured(3);
}

QTLOGGER_DECL_SPEC
QSharedPointer<QFile> createFilePtr(const QString &path)
{
    return QSharedPointer<QFile>::create(replaceTimePattern(path));
}

}

QTLOGGER_DECL_SPEC
FileSink::FileSink(const QString &path) : IODeviceSink(createFilePtr(path))
{
    if (!file()->open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text)) {
        std::cerr << "FileSink: Can't open log file: " << path.toStdString()
                  << " error: " << file()->errorString().toStdString() << std::endl;
    }
}

QTLOGGER_DECL_SPEC
FileSink::~FileSink()
{
    file()->close();
}

QTLOGGER_DECL_SPEC
bool FileSink::flush()
{
    return file()->flush();
}

QTLOGGER_DECL_SPEC
QFile *FileSink::file() const
{
    return qobject_cast<QFile *>(device().data());
}

} // namespace QtLogger

// httpsink.cpp

#ifdef QTLOGGER_NETWORK

#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QNetworkRequest>

namespace QtLogger {

QTLOGGER_DECL_SPEC
HttpSink::HttpSink(const QUrl &url) : m_url(url)
{
    init();
}

QTLOGGER_DECL_SPEC
HttpSink::HttpSink(const QUrl &url, const Headers &headers) : m_url(url), m_headers(headers)
{
    init();
}

QTLOGGER_DECL_SPEC
void HttpSink::init()
{
    m_manager = new QNetworkAccessManager();

#ifndef QTLOGGER_NO_THREAD
    if (m_manager->thread() != Logger::instance()->ownThread()) {
        m_manager->moveToThread(Logger::instance()->ownThread());
    }
#endif

    m_request.setUrl(m_url);
    for (const auto &header : m_headers) {
        m_request.setRawHeader(header.first, header.second);
    }
}

QTLOGGER_DECL_SPEC
HttpSink::~HttpSink()
{
    if (!m_manager.isNull()) {
        delete m_manager.data();
    }
}

QTLOGGER_DECL_SPEC
void HttpSink::send(const LogMessage &lmsg)
{
    if (!Logger::instance()->ownThreadIsRunning()) {
        if (!m_manager.isNull() && !m_manager->property("activeReply").isValid())
            m_manager->deleteLater();
        m_manager = new QNetworkAccessManager();
    }

    if (!m_request.hasRawHeader("Content-Type")) {
        m_request.setHeader(QNetworkRequest::ContentTypeHeader,
                            QStringLiteral("text/plain; charset=utf-8"));
    }

    auto reply = m_manager->post(m_request, lmsg.formattedMessage().toUtf8());

    QObject::connect(reply, &QNetworkReply::finished, reply, &QObject::deleteLater);

    if (!Logger::instance()->ownThreadIsRunning()) {
        m_manager->setProperty("activeReply", QVariant::fromValue(reply));
        QObject::connect(reply, &QNetworkReply::finished, m_manager, &QObject::deleteLater);
    }
}

QTLOGGER_DECL_SPEC
void HttpSink::setNetworkAccessManager(QNetworkAccessManager *manager)
{
    if (!m_manager.isNull()) {
        delete m_manager.data();
    }
    m_manager = manager;
}

QTLOGGER_DECL_SPEC
void HttpSink::setRequest(const QNetworkRequest &request)
{
    m_request = request;
}

QTLOGGER_DECL_SPEC
void HttpSink::setHeaders(const Headers &headers)
{
    m_headers = headers;
    for (const auto &header : m_headers) {
        m_request.setRawHeader(header.first, header.second);
    }
}

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// iodevicesink.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
IODeviceSink::IODeviceSink(const QIODevicePtr &device) : m_device(device) { }

QTLOGGER_DECL_SPEC
void IODeviceSink::send(const LogMessage &lmsg)
{
    if (m_device.isNull()) {
        return;
    }

    m_device->write(lmsg.formattedMessage().toLocal8Bit().append("\n"));
}

QTLOGGER_DECL_SPEC
const QIODevicePtr &IODeviceSink::device() const
{
    return m_device;
}

QTLOGGER_DECL_SPEC
void IODeviceSink::setDevice(const QIODevicePtr &device)
{
    m_device = device;
}

} // namespace QtLogger

// oslogsink.cpp

#ifdef QTLOGGER_OSLOG

#include <os/log.h>

#include <QCoreApplication>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void OslogSink::send(const LogMessage &lmsg)
{
    auto customLog = os_log_create(qPrintable(QCoreApplication::applicationName()),
                                   qPrintable(lmsg.category()));

    auto type = OS_LOG_TYPE_DEBUG;
    switch (lmsg.type()) {
    case QtDebugMsg:
        type = OS_LOG_TYPE_DEBUG;
        break;
    case QtInfoMsg:
        type = OS_LOG_TYPE_INFO;
        break;
    case QtWarningMsg:
        type = OS_LOG_TYPE_ERROR;
        break;
    case QtCriticalMsg:
        type = OS_LOG_TYPE_FAULT;
        break;
    case QtFatalMsg:
        type = OS_LOG_TYPE_FAULT;
        break;
    };

    os_log_with_type(customLog, type, "%s", qPrintable(lmsg.message()));
}

} // namespace QtLogger

#endif // QTLOGGER_OSLOG

// rotatingfilesink.cpp

/*
 * Rotated file naming format:
 *   <basename>.<date>.<index>.<suffix>[.gz]
 *   Example: app.2024-05-15.1.log or app.2024-05-15.1.log.gz
 *
 * Rotation triggers:
 *   1. On startup (RotationOnStartup) - rotates if the log file is non-empty
 *   2. Daily (RotationDaily) - rotates when the message date differs from the current log date
 *   3. By size (maxFileSize > 0) - rotates when adding a new message would exceed maxFileSize
 *
 *   If maxFileCount == 1, rotation is disabled (only the main file is kept)
 *   If maxFileCount <= 0, rotated files are kept indefinitely (no automatic cleanup)
 */

#include <QDate>
#include <QDir>
#include <QFile>
#include <QFileInfo>
#include <QRegularExpression>
#include <QtEndian>
#include <QDataStream>

#include <algorithm>
#include <iostream>

namespace QtLogger {

namespace {

QTLOGGER_DECL_SPEC
static quint32 calculateCRC32(QFile &file) {
    quint32 crc = 0xFFFFFFFF;
    const quint32 polynomial = 0xEDB88320;
    static quint32 table[256];
    static bool tableGenerated = false;

    if (!tableGenerated) {
        for (quint32 i = 0; i < 256; i++) {
            quint32 value = i;
            for (int j = 0; j < 8; j++) {
                if (value & 1) value = (value >> 1) ^ polynomial;
                else value >>= 1;
            }
            table[i] = value;
        }
        tableGenerated = true;
    }

    file.seek(0);
    char buffer[8192];
    while (!file.atEnd()) {
        auto bytesRead = file.read(buffer, sizeof(buffer));
        for (auto i = 0; i < bytesRead; i++) {
            crc = table[(crc ^ static_cast<unsigned char>(buffer[i])) & 0xFF] ^ (crc >> 8);
        }
    }
    return crc ^ 0xFFFFFFFF;
}

} // namespace

class RotatingFileSink::RotatingFileSinkPrivate
{
public:
    RotatingFileSinkPrivate(RotatingFileSink *q,
                            int maxFileSize,
                            int maxFileCount,
                            RotatingFileSink::Options options)
        : q_ptr(q)
        , m_maxFileSize(maxFileSize)
        , m_maxFileCount(maxFileCount)
        , m_rotationOnStartup(options.testFlag(RotatingFileSink::RotationOnStartup))
        , m_rotationDaily(options.testFlag(RotatingFileSink::RotationDaily))
        , m_compression(options.testFlag(RotatingFileSink::Compression))
    {
    }

    void init()
    {
        if (m_initialized)
            return;

        m_initialized = true;

        auto fi = QFileInfo(q_ptr->file()->fileName());
        if (fi.exists() && fi.size() > 0) {
            m_currentLogDate = fi.lastModified().date();
        } else {
            m_currentLogDate = QDate::currentDate();
        }

        if (m_rotationOnStartup) {
            checkStartupRotation();
        }
    }

    void rotateIfNeeded(const LogMessage &lmsg)
    {
        const auto messageDate = lmsg.time().date();

        if (m_rotationDaily) {
            checkDailyRotation(messageDate);
        }

        if (m_maxFileSize > 0) {
            const auto additionalSize = lmsg.formattedMessage().toUtf8().size() + 1; // +1 for newline
            checkSizeRotation(additionalSize);
        }
    }

    void checkStartupRotation()
    {
        if (q_ptr->file()->size() > 0) {
            rotate();
        }
    }

    void checkDailyRotation(const QDate &messageDate)
    {
        if (messageDate != m_currentLogDate && q_ptr->file()->size() > 0) {
            rotate();
            m_currentLogDate = messageDate;
        }
    }

    void checkSizeRotation(int additionalSize)
    {
        if (m_maxFileSize <= 0)
            return;

        const auto currentSize = q_ptr->file()->size();
        if (currentSize > 0 && (currentSize + additionalSize) > m_maxFileSize) {
            rotate();
        }
    }

    QString baseDir() const
    {
        auto fi = QFileInfo(q_ptr->file()->fileName());
        return fi.absolutePath();
    }

    QString generateRotatedFileName(const QDate &date, int index) const
    {
        auto fi = QFileInfo(q_ptr->file()->fileName());
        const auto baseName = fi.completeBaseName();
        const auto suffix = fi.suffix();
        const auto dateStr = date.toString(QStringLiteral("yyyy-MM-dd"));

        QString rotatedName;
        if (suffix.isEmpty()) {
            rotatedName = QStringLiteral("%1.%2.%3").arg(baseName, dateStr).arg(index);
        } else {
            rotatedName = QStringLiteral("%1.%2.%3.%4").arg(baseName, dateStr).arg(index).arg(suffix);
        }

        return QDir(baseDir()).filePath(rotatedName);
    }

    int findNextIndexForDate(const QDate &date) const
    {
        auto fi = QFileInfo(q_ptr->file()->fileName());
        const auto baseName = fi.completeBaseName();
        const auto suffix = fi.suffix();
        const auto dateStr = date.toString(QStringLiteral("yyyy-MM-dd"));

        QString pattern;
        if (suffix.isEmpty()) {
            pattern = QStringLiteral("^%1\\.%2\\.(\\d+)(\\.gz)?$")
                          .arg(QRegularExpression::escape(baseName),
                               QRegularExpression::escape(dateStr));
        } else {
            pattern = QStringLiteral("^%1\\.%2\\.(\\d+)\\.%3(\\.gz)?$")
                          .arg(QRegularExpression::escape(baseName),
                               QRegularExpression::escape(dateStr),
                               QRegularExpression::escape(suffix));
        }

        auto re = QRegularExpression(pattern);
        auto dir = QDir(baseDir());
        auto maxIndex = 0;

        const auto entries = dir.entryList(QDir::Files);
        for (const QString &entry : entries) {
            auto match = re.match(entry);
            if (match.hasMatch()) {
                auto index = match.captured(1).toInt();
                if (index > maxIndex) {
                    maxIndex = index;
                }
            }
        }

        return maxIndex + 1;
    }

    void compressFile(const QString &filePath)
    {
        auto inputFile = QFile(filePath);
        if (!inputFile.open(QIODevice::ReadOnly)) return;

        const auto compressedPath = filePath + QStringLiteral(".gz");
        auto outputFile = QFile(compressedPath);
        if (!outputFile.open(QIODevice::WriteOnly)) {
            inputFile.close();
            return;
        }

        auto fileCRC = calculateCRC32(inputFile);
        auto fileSize = static_cast<quint32>(inputFile.size());
        inputFile.seek(0);

        outputFile.putChar('\x1f'); // ID1
        outputFile.putChar('\x8b'); // ID2
        outputFile.putChar('\x08'); // CM (Deflate)
        outputFile.putChar('\x00'); // FLG
        outputFile.write("\x00\x00\x00\x00", 4); // MTIME (0 = unknown)
        outputFile.putChar('\x00'); // XFL
        outputFile.putChar('\x03'); // OS (Unix)

        auto rawData = inputFile.readAll();
        auto compressed = qCompress(rawData, 5);

        if (compressed.size() > 10) {
            outputFile.write(compressed.constData() + 6, compressed.size() - 6 - 4);
        }

        auto le_crc = qToLittleEndian(fileCRC);
        auto le_size = qToLittleEndian(fileSize);
        outputFile.write(reinterpret_cast<const char*>(&le_crc), 4);
        outputFile.write(reinterpret_cast<const char*>(&le_size), 4);

        inputFile.close();
        outputFile.close();
        QFile::remove(filePath);
    }

    QStringList findRotatedFiles() const
    {
        auto fi = QFileInfo(q_ptr->file()->fileName());
        const auto baseName = fi.completeBaseName();
        const auto suffix = fi.suffix();

        QString pattern;
        if (suffix.isEmpty()) {
            pattern = QStringLiteral("^%1\\.\\d{4}-\\d{2}-\\d{2}\\.\\d+(\\.gz)?$")
                          .arg(QRegularExpression::escape(baseName));
        } else {
            pattern = QStringLiteral("^%1\\.\\d{4}-\\d{2}-\\d{2}\\.\\d+\\.%2(\\.gz)?$")
                          .arg(QRegularExpression::escape(baseName),
                               QRegularExpression::escape(suffix));
        }

        auto re = QRegularExpression(pattern);
        auto dir = QDir(baseDir());
        auto result = QStringList();

        const auto entries = dir.entryList(QDir::Files, QDir::Name);
        for (const QString &entry : entries) {
            if (re.match(entry).hasMatch()) {
                result.append(dir.filePath(entry));
            }
        }

        std::sort(result.begin(), result.end(), [](const QString &a, const QString &b) {
            return QFileInfo(a).lastModified() < QFileInfo(b).lastModified();
        });

        return result;
    }

    void removeOldFiles()
    {
        if (m_maxFileCount <= 0)
            return;

        auto rotatedFiles = findRotatedFiles();

        while (rotatedFiles.size() > m_maxFileCount - 1) {
            const QString &oldestFile = rotatedFiles.first();
            if (!QFile::remove(oldestFile)) {
                std::cerr << "RotatingFileSink: Failed to remove old log file: "
                          << oldestFile.toStdString() << std::endl;
            }
            rotatedFiles.removeFirst();
        }
    }

    void rotate()
    {
        if (m_maxFileCount == 1)
            return;

        q_ptr->file()->close();

        const auto &currentFileName = q_ptr->file()->fileName();
        const auto rotationDate = m_currentLogDate.isValid() ? m_currentLogDate : QDate::currentDate();
        const auto nextIndex = findNextIndexForDate(rotationDate);
        const auto rotatedFileName = generateRotatedFileName(rotationDate, nextIndex);

        if (!QFile::rename(currentFileName, rotatedFileName)) {
            std::cerr << "RotatingFileSink: Failed to rename log file from "
                      << currentFileName.toStdString() << " to "
                      << rotatedFileName.toStdString() << std::endl;
        } else if (m_compression) {
            compressFile(rotatedFileName);
        }

        removeOldFiles();

        if (!q_ptr->file()->open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text)) {
            std::cerr << "RotatingFileSink: Failed to reopen log file: "
                      << currentFileName.toStdString() << std::endl;
        }

        m_currentLogDate = QDate::currentDate();
    }

    RotatingFileSink *q_ptr;

    int m_maxFileSize;
    int m_maxFileCount;
    bool m_rotationOnStartup;
    bool m_rotationDaily;
    bool m_compression;

    QDate m_currentLogDate;
    bool m_initialized = false;
};

QTLOGGER_DECL_SPEC
RotatingFileSink::RotatingFileSink(const QString &path,
                                   int maxFileSize,
                                   int maxFileCount,
                                   RotatingFileSink::Options options)
    : FileSink(path)
    , d(new RotatingFileSinkPrivate(this, maxFileSize, maxFileCount, options))
{
}

QTLOGGER_DECL_SPEC
RotatingFileSink::~RotatingFileSink() = default;

QTLOGGER_DECL_SPEC
void RotatingFileSink::send(const LogMessage &lmsg)
{
    d->init();
    d->rotateIfNeeded(lmsg);
    FileSink::send(lmsg);
}

} // namespace QtLogger

// sdjournalsink.cpp

#ifdef QTLOGGER_SDJOURNAL

#include <systemd/sd-journal.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void SdJournalSink::send(const LogMessage &lmsg)
{
    auto priority = LOG_DEBUG;

    switch (lmsg.type()) {
    case QtDebugMsg:
        priority = LOG_DEBUG;
        break;
    case QtWarningMsg:
        priority = LOG_WARNING;
        break;
    case QtCriticalMsg:
        priority = LOG_ERR;
        break;
    case QtFatalMsg:
        priority = LOG_EMERG;
        break;
    case QtInfoMsg:
        priority = LOG_INFO;
        break;
    default:
        return;
    }

    const auto &file = QByteArrayLiteral("CODE_FILE=") + QByteArray(lmsg.file());
    const auto &line = QByteArrayLiteral("CODE_LINE=") + QByteArray::number(lmsg.line());

    sd_journal_print_with_location(priority, file.constData(), line.constData(), lmsg.function(),
                                   "%s", qPrintable(lmsg.formattedMessage()));

    sd_journal_send_with_location(file.constData(), line.constData(), lmsg.function(), "%s",
                                  qPrintable(lmsg.formattedMessage()), "PRIORITY=%i", priority,
                                  "CATEGORY=%s", lmsg.category(), NULL);
}

} // namespace QtLogger

#endif // QTLOGGER_SDJOURNAL

// signalsink.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
SignalSink::SignalSink(QObject *parent) : QObject(parent) { }

QTLOGGER_DECL_SPEC
void SignalSink::send(const LogMessage &lmsg)
{
    Q_EMIT message(lmsg);
}

} // namespace QtLogger

// stderrsink.cpp

#include <iostream>

namespace QtLogger {

QTLOGGER_DECL_SPEC
StdErrSink::StdErrSink(ColorMode colorMode)
    : ColoredConsole(colorMode)
{
    updateColorsEnabled();
}

QTLOGGER_DECL_SPEC
void StdErrSink::send(const LogMessage &lmsg)
{
    if (m_colorsEnabled) {
        std::cerr << qPrintable(colorize(lmsg.formattedMessage(), lmsg.type())) << std::endl;
    } else {
        std::cerr << qPrintable(lmsg.formattedMessage()) << std::endl;
    }
}

QTLOGGER_DECL_SPEC
bool StdErrSink::flush()
{
    std::flush(std::cerr);
    return true;
}

QTLOGGER_DECL_SPEC
bool StdErrSink::isTty() const
{
    return isStdErrTty();
}

} // namespace QtLogger

// stdoutsink.cpp

#include <iostream>

namespace QtLogger {

QTLOGGER_DECL_SPEC
StdOutSink::StdOutSink(ColorMode colorMode)
    : ColoredConsole(colorMode)
{
    updateColorsEnabled();
}

QTLOGGER_DECL_SPEC
void StdOutSink::send(const LogMessage &lmsg)
{
    if (m_colorsEnabled) {
        std::cout << qPrintable(colorize(lmsg.formattedMessage(), lmsg.type())) << std::endl;
    } else {
        std::cout << qPrintable(lmsg.formattedMessage()) << std::endl;
    }
}

QTLOGGER_DECL_SPEC
bool StdOutSink::flush()
{
    std::flush(std::cout);
    return true;
}

QTLOGGER_DECL_SPEC
bool StdOutSink::isTty() const
{
    return isStdOutTty();
}

} // namespace QtLogger

// syslogsink.cpp

#ifdef QTLOGGER_SYSLOG

#include <syslog.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
SyslogSink::SyslogSink(const QString &ident, int option, int facility)
{
    openlog(qPrintable(ident), option, facility);
}

QTLOGGER_DECL_SPEC
SyslogSink::~SyslogSink()
{
    closelog();
}

QTLOGGER_DECL_SPEC
void SyslogSink::send(const LogMessage &lmsg)
{
    auto priority = LOG_DEBUG;

    switch (lmsg.type()) {
    case QtDebugMsg:
        priority = LOG_DEBUG;
        break;
    case QtWarningMsg:
        priority = LOG_WARNING;
        break;
    case QtCriticalMsg:
        priority = LOG_ERR;
        break;
    case QtFatalMsg:
        priority = LOG_EMERG;
        break;
    case QtInfoMsg:
        priority = LOG_INFO;
        break;
    default:
        return;
    }

    QString formattedMessage;
    if (qstrcmp(lmsg.category(), "default") == 0) {
        formattedMessage = lmsg.message();
    } else {
        formattedMessage = QStringLiteral("%1: %2").arg(lmsg.category(), lmsg.message());
    }

    syslog(priority, "%s", qPrintable(formattedMessage));
}

} // namespace QtLogger

#endif // QTLOGGER_SYSLOG

// windebugsink.cpp

#ifdef Q_OS_WIN

#include <qt_windows.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void WinDebugSink::send(const LogMessage &lmsg)
{
    auto formattedMessage = lmsg.formattedMessage() + u'\n';
    OutputDebugString(reinterpret_cast<const wchar_t *>(formattedMessage.utf16()));
}

} // namespace QtLogger

#endif

// sortedpipeline.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
void SortedPipeline::insertBetweenNearLeft(const QSet<HandlerType> &leftType,
                                           const QSet<HandlerType> &rightType,
                                           const HandlerPtr &handler)
{
    auto firstRight =
            std::find_if(handlers().begin(), handlers().end(),
                         [&rightType](const auto &x) { return rightType.contains(x->type()); });

    auto lastLeft = std::find_if(firstRight, handlers().begin(), [&leftType](const HandlerPtr &x) {
        return leftType.contains(x->type());
    });

    handlers().insert(lastLeft, handler);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::insertBetweenNearRight(const QSet<HandlerType> &leftType,
                                            const QSet<HandlerType> &rightType,
                                            const HandlerPtr &handler)
{
    auto lastLeft =
            std::find_if(handlers().end(), handlers().begin(),
                         [&leftType](const HandlerPtr &x) { return leftType.contains(x->type()); });

    auto firstRight = std::find_if(lastLeft, handlers().end(), [&rightType](const auto &x) {
        return rightType.contains(x->type());
    });

    handlers().insert(firstRight, handler);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clear(HandlerType type)
{
    QMutableListIterator<HandlerPtr> iter(handlers());

    while (iter.hasNext()) {
        if (iter.next()->type() == type) {
            iter.remove();
        }
    }
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clear()
{
    Pipeline::clear();
}

QTLOGGER_DECL_SPEC
void SortedPipeline::appendAttrHandler(const AttrHandlerPtr &attrHandler)
{
    if (attrHandler.isNull())
        return;

    insertBetweenNearLeft({ HandlerType::AttrHandler },
                          { HandlerType::Filter, HandlerType::Formatter, HandlerType::Sink },
                          attrHandler);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clearAttrHandlers()
{
    clear(HandlerType::AttrHandler);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::appendFilter(const FilterPtr &filter)
{
    if (filter.isNull())
        return;

    insertBetweenNearLeft({ HandlerType::AttrHandler, HandlerType::Filter },
                          { HandlerType::Formatter, HandlerType::Sink }, filter);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clearFilters()
{
    clear(HandlerType::Filter);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::setFormatter(const FormatterPtr &formatter)
{
    if (formatter.isNull())
        return;

    clearFormatters();

    insertBetweenNearRight({ HandlerType::AttrHandler, HandlerType::Filter }, { HandlerType::Sink },
                           formatter);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clearFormatters()
{
    clear(HandlerType::Formatter);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::appendSink(const SinkPtr &sink)
{
    append(sink);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clearSinks()
{
    clear(HandlerType::Sink);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::appendPipeline(const PipelinePtr &pipeline)
{
    append(pipeline);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clearPipelines()
{
    clear(HandlerType::Pipeline);
}

} // namespace QtLogger

// utils.cpp

#include <QLoggingCategory>
#include <QString>

namespace {

QTLOGGER_DECL_SPEC
QString prevMessagePattern(const QString &messagePattern = {})
{
    static QString __prevMessagePattern { QString::fromUtf8(QtLogger::DefaultMessagePattern) };

    if (!messagePattern.isNull())
        __prevMessagePattern = messagePattern;

    return __prevMessagePattern;
}

}

namespace QtLogger {

QTLOGGER_DECL_SPEC
void setFilterRules(const QString &a_rules)
{
    QString rules = a_rules;
    rules.replace(QChar::fromLatin1(';'), QChar::fromLatin1('\n'));
    rules.replace(QChar::fromLatin1(':'), QChar::fromLatin1('\n'));
    QLoggingCategory::setFilterRules(rules);
}

QTLOGGER_DECL_SPEC
QString setMessagePattern(const QString &a_messagePattern)
{
    QString messagePattern = a_messagePattern;

    if (messagePattern.toLower() == QStringLiteral("default")) {
        messagePattern = QString::fromUtf8(DefaultMessagePattern);
    } else if (messagePattern.toLower() == QStringLiteral("pretty")) {
        messagePattern = QString::fromUtf8(PrettyMessagePattern);
    }

    static QString s_messagePattern { QString::fromUtf8(QtLogger::DefaultMessagePattern) };

    if (s_messagePattern == messagePattern)
        return s_messagePattern;

    prevMessagePattern(s_messagePattern);

    s_messagePattern = messagePattern;

    qSetMessagePattern(s_messagePattern);

    return prevMessagePattern();
}

QTLOGGER_DECL_SPEC
QString restorePreviousMessagePattern()
{
    return setMessagePattern(prevMessagePattern());
}

} // namespace QtLogger

