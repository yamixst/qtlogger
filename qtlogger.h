// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2024 Mikhail Yatsenko <mikhail.yatsenko@gmail.com>

// This file is automatically generated. Please don't edit it.

#pragma once

// #define QTLOGGER_NO_THREAD
// #define QTLOGGER_NETWORK
// #define QTLOGGER_IOSLOG
// #define QTLOGGER_ANDROIDLOG
// #define QTLOGGER_SYSLOG
// #define QTLOGGER_JOURNAL

#define QTLOGGER_DECL_SPEC inline

// qtlogger.h

// attrhandler.h

#include <QSharedPointer>

// handler.h

#include <QSharedPointer>

// logger_global.h

#include <QtCore/qglobal.h>

#if defined(QTLOGGER_STATIC)
#    define QTLOGGER_EXPORT
#elif defined(QTLOGGER_LIBRARY)
#    define QTLOGGER_EXPORT Q_DECL_EXPORT
#else
#    define QTLOGGER_EXPORT Q_DECL_IMPORT
#endif

#if !defined(QTLOGGER_DECL_SPEC)
#    define QTLOGGER_DECL_SPEC
#endif

// end logger_global.h

// logmessage.h

#include <QDateTime>
#include <QThread>
#include <qlogging.h>

namespace QtLogger {

class QTLOGGER_EXPORT LogMessage
{
public:
    constexpr LogMessage() noexcept = default;

    LogMessage(QtMsgType type, const QMessageLogContext &context, const QString &message) noexcept
        : m_type(type),
          m_context(context.file, context.line, context.function, context.category),
          m_message(message)
    {
    }

    LogMessage(const LogMessage &lmsg) noexcept
        : m_file(lmsg.m_context.file),
          m_function(lmsg.m_context.function),
          m_category(lmsg.m_context.category),
          m_type(lmsg.m_type),
          m_context(m_file.constData(), lmsg.m_context.line, m_function.constData(),
                    m_category.constData()),
          m_message(lmsg.m_message),
          m_time(lmsg.m_time),
          m_threadId(lmsg.m_threadId),
          m_formattedMessage(lmsg.m_formattedMessage),
          m_attributes(lmsg.m_attributes)
    {
    }

    inline QtMsgType type() const { return m_type; }
    inline const QMessageLogContext &context() const { return m_context; }
    inline QString message() const { return m_message; }

    // Context members

    inline int line() const { return m_context.line; }
    inline const char *file() const { return m_context.file; }
    inline const char *function() const { return m_context.function; }
    inline const char *category() const { return m_context.category; }

    // System attributes

    inline QDateTime time() const { return m_time; }
    inline qintptr threadId() const { return m_threadId; }

    // Formatted message

    inline QString formattedMessage() const
    {
        return isFormatted() ? m_formattedMessage : m_message;
    }
    inline void setFormattedMessage(const QString &formattedMessage)
    {
        m_formattedMessage = formattedMessage;
    }
    inline bool isFormatted() const { return !m_formattedMessage.isNull(); }

    // Custom attributes

    inline QVariant attribute(const QString &name) const { return m_attributes.value(name); }
    inline void setAttribute(const QString &name, const QVariant &value)
    {
        m_attributes.insert(name, value);
    }
    inline bool hasAttribute(const QString &name) const { return m_attributes.contains(name); }
    inline QVariantHash attributes() const { return m_attributes; }
    inline QVariantHash &attributes() { return m_attributes; }

    QVariantHash allAttributes() const;

private:
    // `context` buffers
    const QByteArray m_file;
    const QByteArray m_function;
    const QByteArray m_category;

    const QtMsgType m_type = QtDebugMsg;
    const QMessageLogContext m_context;
    const QString m_message;

    const QDateTime m_time = QDateTime::currentDateTime();
    const qintptr m_threadId = reinterpret_cast<qintptr>(QThread::currentThreadId());

    QString m_formattedMessage;
    QVariantHash m_attributes;
};

inline QString qtMsgTypeToString(QtMsgType type, const QString &a_default = QStringLiteral("debug"))
{
    static const auto map = QHash<QtMsgType, QString> {
        { QtDebugMsg, QStringLiteral("debug") },
        { QtInfoMsg, QStringLiteral("info") },
        { QtWarningMsg, QStringLiteral("warning") },
        { QtCriticalMsg, QStringLiteral("critical") },
        { QtFatalMsg, QStringLiteral("fatal") },
    };
    return map.value(type, a_default);
}

inline QtMsgType stringToQtMsgType(const QString &str, QtMsgType a_default= QtDebugMsg)
{
    static const auto map = QHash<QString, QtMsgType> {
        { QStringLiteral("debug"), QtDebugMsg },
        { QStringLiteral("info"), QtInfoMsg },
        { QStringLiteral("warning"), QtWarningMsg },
        { QStringLiteral("critical"), QtCriticalMsg },
        { QStringLiteral("fatal"), QtFatalMsg },
    };
    return map.value(str, a_default);
}

inline QVariantHash LogMessage::allAttributes() const
{
    auto attrs = QVariantHash {
        { QStringLiteral("type"), qtMsgTypeToString(m_type) },
        { QStringLiteral("line"), m_context.line },
        { QStringLiteral("file"), m_context.file },
        { QStringLiteral("function"), m_context.function },
        { QStringLiteral("category"), m_context.category },
        { QStringLiteral("time"), m_time },
        { QStringLiteral("threadId"), m_threadId },
    };
    attrs.insert(m_attributes);
    return attrs;
}

} // namespace QtLogger

// end logmessage.h

namespace QtLogger {

class QTLOGGER_EXPORT Handler
{
public:
    enum class HandlerType { Handler, AttrHandler, Filter, Formatter, Sink, Pipeline, Mixed };

    virtual ~Handler() = default;

    virtual HandlerType type() const { return HandlerType::Handler; }

    virtual bool process(LogMessage &lmsg) = 0;
};

using HandlerPtr = QSharedPointer<Handler>;

} // namespace QtLogger

// end handler.h

namespace QtLogger {

class QTLOGGER_EXPORT AttrHandler : public Handler
{
public:
    virtual QVariantHash attributes() = 0;

    HandlerType type() const override { return HandlerType::AttrHandler; }

    bool process(LogMessage &lmsg) override
    {
        lmsg.attributes().insert(attributes());
        return true;
    }
};

using AttrHandlerPtr = QSharedPointer<AttrHandler>;

} // namespace QtLogger

// end attrhandler.h

// appinfoattrs.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT AppInfoAttrs : public AttrHandler
{
public:
    QVariantHash attributes() override;
};

using AppInfoAttrsPtr = QSharedPointer<AppInfoAttrs>;

} // namespace QtLogger

// end appinfoattrs.h

// seqnumberattr.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT SeqNumberAttr : public AttrHandler
{
public:
    QVariantHash attributes() override;

private:
    int m_count = 0;
};

using SeqNumberAttrPtr = QSharedPointer<SeqNumberAttr>;

} // namespace QtLogger

// end seqnumberattr.h

// filter.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Filter : public Handler
{
public:
    virtual ~Filter() = default;

    virtual bool filter(const LogMessage &lmsg) = 0;

    HandlerType type() const override { return HandlerType::Filter; }

    bool process(LogMessage &lmsg) override final { return filter(lmsg); }
};

using FilterPtr = QSharedPointer<Filter>;

} // namespace QtLogger

// end filter.h

// categoryfilter.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT CategoryFilter : public Filter
{
public:
    CategoryFilter(const QString &rules);

    bool filter(const LogMessage &lmsg) override;

private:
    struct Rule;
    void parseRules(const QString &rules);
    QList<QSharedPointer<Rule>> m_rules;
};

using CategoryFilterPtr = QSharedPointer<CategoryFilter>;

} // namespace QtLogger

// end categoryfilter.h

// duplicatefilter.h

namespace QtLogger {

class QTLOGGER_EXPORT DuplicateFilter : public Filter
{
public:
    bool filter(const LogMessage &lmsg) override;

private:
    QString m_lastMessage;
};

using DuplicateFilterPtr = QSharedPointer<DuplicateFilter>;

} // namespace QtLogger

// end duplicatefilter.h

// functionfilter.h

#include <functional>

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT FunctionFilter : public Filter
{
public:
    using Function = std::function<bool(const LogMessage &)>;

    FunctionFilter(const Function &function) : m_function(function) { }

    bool filter(const LogMessage &lmsg) override { return m_function(lmsg); }

private:
    Function m_function;
};

using FunctionFilterPtr = QSharedPointer<FunctionFilter>;

} // namespace QtLogger

// end functionfilter.h

// regexpfilter.h

#include <QRegularExpression>
#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT RegExpFilter : public Filter
{
public:
    explicit RegExpFilter(const QRegularExpression &regExp);
    explicit RegExpFilter(const QString &regExp);

    bool filter(const LogMessage &lmsg) override;

private:
    QRegularExpression m_regExp;
};

using RegExpFilterPtr = QSharedPointer<RegExpFilter>;

} // namespace QtLogger

// end regexpfilter.h

// formatter.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Formatter : public Handler
{
public:
    virtual ~Formatter() = default;

    virtual QString format(const LogMessage &lmsg) = 0;

    HandlerType type() const override { return HandlerType::Formatter; }

    bool process(LogMessage &lmsg) override final
    {
        lmsg.setFormattedMessage(format(lmsg));
        return true;
    }
};

using FormatterPtr = QSharedPointer<Formatter>;

} // namespace QtLogger

// end formatter.h

// functionformatter.h

#include <functional>

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT FunctionFormatter : public Formatter
{
public:
    using Function = std::function<QString(const LogMessage &)>;

    FunctionFormatter(const Function &func) : m_func(func) { }

    QString format(const LogMessage &lmsg) override { return m_func(lmsg); }

private:
    Function m_func;
};

using FunctionFormatterPtr = QSharedPointer<FunctionFormatter>;

} // namespace QtLogger

// end functionformatter.h

// jsonformatter.h

#include <QSharedPointer>

namespace QtLogger {

using JsonFormatterPtr = QSharedPointer<class JsonFormatter>;

class QTLOGGER_EXPORT JsonFormatter : public Formatter
{
public:
    static JsonFormatterPtr instance()
    {
        static const auto s_instance = JsonFormatterPtr::create();
        return s_instance;
    }

    QString format(const LogMessage &lmsg) override;
};

} // namespace QtLogger

// end jsonformatter.h

// patternformatter.h

#include <QSharedPointer>

namespace QtLogger {

using PatternFormatterPtr = QSharedPointer<class PatternFormatter>;

class QTLOGGER_EXPORT PatternFormatter : public Formatter
{
public:
    explicit PatternFormatter(const QString &pattern);

    QString format(const LogMessage &lmsg) override;

private:
    QString m_pattern;
};

} // namespace QtLogger

// end patternformatter.h

// prettyformatter.h

#include <QMap>
#include <QStringList>

namespace QtLogger {

using PrettyFormatterPtr = QSharedPointer<class PrettyFormatter>;

class QTLOGGER_EXPORT PrettyFormatter : public Formatter
{
public:
    static PrettyFormatterPtr instance()
    {
        static const auto s_instance = PrettyFormatterPtr::create(true, 0);
        return s_instance;
    }

    explicit PrettyFormatter(bool showThread = true, int maxCategoryWidth = 15);

    QString format(const LogMessage &lmsg) override;

    inline bool showThreadId() const { return m_showThreadId; }
    inline void setShowThreadId(bool newShowThreadId) { m_showThreadId = newShowThreadId; }

    inline int maxCategoryWidth() const { return m_maxCategoryWidth; }
    inline void setMaxCategoryWidth(int newMaxCategoryWidth)
    {
        m_maxCategoryWidth = newMaxCategoryWidth;
    }

private:
    bool m_showThreadId = true;
    QMap<int, int> m_threads;
    int m_threadsIndex = 0;

    int m_maxCategoryWidth = 15;
    int m_categoryWidth = 0;
};

} // namespace QtLogger

// end prettyformatter.h

// qtlogmessageformatter.h

#include <QSharedPointer>

namespace QtLogger {

using QtLogMessageFormatterPtr = QSharedPointer<class QtLogMessageFormatter>;

class QTLOGGER_EXPORT QtLogMessageFormatter : public Formatter
{
public:
    static QtLogMessageFormatterPtr instance()
    {
        static const auto s_instance = QtLogMessageFormatterPtr(new QtLogMessageFormatter());
        return s_instance;
    }

    QString format(const LogMessage &lmsg) override
    {
        return qFormatLogMessage(lmsg.type(), lmsg.context(), lmsg.message());
    }

private:
    QtLogMessageFormatter() { }
};

} // namespace QtLogger

// end qtlogmessageformatter.h

// logger.h

#include <QSettings>

#ifndef QTLOGGER_NO_THREAD
#    include <QEvent>
#    include <QMutex>
#    include <QThread>
#endif

#ifndef QTLOGGER_NO_THREAD

// ownthreadpipeline.h

#include <QPointer>

// simplepipeline.h

#include <QList>
#include <QSharedPointer>

// typedpipeline.h

// pipeline.h

#include <initializer_list>

#include <QList>
#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Pipeline : public Handler
{
public:
    explicit Pipeline(bool scoped = false) : m_scoped(scoped) {};
    Pipeline(std::initializer_list<HandlerPtr> handlers);

    HandlerType type() const override { return HandlerType::Pipeline; }

    void append(const HandlerPtr &handler);
    void append(std::initializer_list<HandlerPtr> handlers);
    void remove(const HandlerPtr &handler);
    void clear();

    Pipeline &operator<<(const HandlerPtr &handler);

    bool process(LogMessage &lmsg) override;

protected:
    QList<HandlerPtr> &handlers() { return m_handlers; }

private:
    QList<HandlerPtr> m_handlers;
    bool m_scoped = false;
};

using PipelinePtr = QSharedPointer<Pipeline>;

inline Pipeline &operator<<(Pipeline *pipeline, const HandlerPtr &handler)
{
    return *pipeline << handler;
}

inline Pipeline &operator<<(PipelinePtr pipeline, const HandlerPtr &handler)
{
    return *pipeline << handler;
}

} // namespace QtLogger

// end pipeline.h

// sink.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Sink : public Handler
{
public:
    virtual void send(const LogMessage &lmsg) = 0;
    virtual bool flush() { return true; }

    HandlerType type() const override { return HandlerType::Sink; }

    bool process(LogMessage &lmsg) override final
    {
        send(lmsg);
        return true;
    }
};

using SinkPtr = QSharedPointer<Sink>;

} // namespace QtLogger

// end sink.h

namespace QtLogger {

class QTLOGGER_EXPORT TypedPipeline : public Pipeline
{
public:
    explicit TypedPipeline(bool scoped = false) : Pipeline(scoped) {}
    ~TypedPipeline() override;

    void insertBefore(HandlerType type, const HandlerPtr &handler);
    void insertAfter(HandlerType type, const HandlerPtr &handler);
    void insertBetween(HandlerType leftType, HandlerType rightType, const HandlerPtr &handler);
    void clearType(HandlerType type);

    void appendFilter(const FilterPtr &filter);
    FunctionFilterPtr appendFilter(const std::function<bool(const LogMessage &)> &function);
    RegExpFilterPtr appendFilter(const QRegularExpression &regExp);
    void clearFilters();

    void setFormatter(const FormatterPtr &formatter);
    FunctionFormatterPtr setFormatter(const std::function<QString(const LogMessage &)> &function);
    PatternFormatterPtr setFormatter(const QString &pattern);
    void clearFormatters();

    void appendSink(const SinkPtr &sink);
    void clearSinks();

    void appendPipeline(const PipelinePtr &pipeline);
    void clearPipelines();

    void flush();
};

using TypedPipelinePtr = QSharedPointer<TypedPipeline>;

} // namespace QtLogger

// end typedpipeline.h

namespace QtLogger {

class QTLOGGER_EXPORT SimplePipeline : public TypedPipeline
{
public:
    explicit SimplePipeline(bool scoped = false, SimplePipeline *parent = nullptr)
        : TypedPipeline(scoped), m_parent(parent)
    {
    }

    SimplePipeline &addSeqNumber();
    SimplePipeline &addAppInfo();
#ifdef QTLOGGER_NETWORK
    SimplePipeline &addHostInfo();
#endif

    SimplePipeline &filter(std::function<bool(const LogMessage &)> func);
    SimplePipeline &filter(const QString &regexp);
    SimplePipeline &filterCategory(const QString &rules);
    SimplePipeline &filterDuplicate();

    SimplePipeline &format(std::function<QString(const LogMessage &)> func);
    SimplePipeline &format(const QString &pattern);
    SimplePipeline &formatByQt();
    SimplePipeline &formatPretty();
    SimplePipeline &formatToJson();

    SimplePipeline &sendToStdOut();
    SimplePipeline &sendToStdErr();
#ifdef QTLOGGER_SYSLOG
    SimplePipeline &sendToSyslog();
#endif
#ifdef QTLOGGER_SDJOURNAL
    SimplePipeline &sendToSdJournal();
#endif
    SimplePipeline &sendToPlatformStdLog();
    SimplePipeline &sendToFile(const QString &fileName, int maxFileSize = 0, int maxFileCount = 0);
#ifdef QTLOGGER_NETWORK
    SimplePipeline &sendToHttp(const QString &url);
#endif
#ifdef Q_OS_WIN
    SimplePipeline &sendToWinDebug();
#endif

    SimplePipeline &pipeline();
    SimplePipeline &end();

private:
    SimplePipeline *m_parent = nullptr;
};

using SimplePipelinePtr = QSharedPointer<SimplePipeline>;

} // namespace QtLogger

// end simplepipeline.h

QT_FORWARD_DECLARE_CLASS(QThread)

namespace QtLogger {

class OwnThreadPipelineWorker;

class QTLOGGER_EXPORT OwnThreadPipeline : public SimplePipeline
{
public:
    OwnThreadPipeline();
    ~OwnThreadPipeline() override;

    OwnThreadPipeline &moveToOwnThread();
    void moveToMainThread();
    bool ownThreadIsRunning() const;
    QThread *ownThread() const { return m_thread; }

    bool process(LogMessage &lmsg) override;

private:
    QPointer<OwnThreadPipelineWorker> m_worker;
    QPointer<QThread> m_thread;
};

} // namespace QtLogger

// end ownthreadpipeline.h

#else

#endif

#define gQtLogger QtLogger::Logger::instance()

#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
#    define QRMUTEX QRecursiveMutex
#else
#    define QRMUTEX QMutex
#endif

namespace QtLogger {

class QTLOGGER_EXPORT Logger :
#ifndef QTLOGGER_NO_THREAD
    public OwnThreadPipeline
#else
    public SimplePipeline
#endif
{
public:
    enum class SinkType {
        Unknown = 0x00,
        StdOut = 0x01,
        StdErr = 0x02,
        Syslog = 0x04,
        SdJournal = 0x8,
        PlatformStdLog = 0x10,
        File = 0x40,
        RotatingFile = 0x80
    };

    Q_DECLARE_FLAGS(SinkTypeFlags, SinkType)

    static Logger *instance();

    Logger() = default;
    ~Logger() override;

    /*
        Set global filter rules

        Format:  "[<category>|*].[debug|info|warning|critical]=true|false;..."
        Example: "app.*.debug=false;app.logger.debug=true"
    */
    static void setFilterRules(const QString &rules);

    /*
       Set global message pattern

       Following placeholders are supported:
       %{appname} %{category} %{file} %{function} %{line} %{message} %{pid} %{threadid}
       %{qthreadptr} %{type} %{time process} %{time boot} %{time [format]} %{backtrace [depth=N]
       [separator="..."]}
    */
    static void setMessagePattern(const QString &pattern);

    Logger &operator<<(const HandlerPtr &handler);

    void configure(std::initializer_list<HandlerPtr> handlers, bool async = false);

    void configure(const SinkTypeFlags &types = SinkType::PlatformStdLog, const QString &path = {},
                   int maxFileSize = 0, int maxFileCount = 0, bool async = false);

    void configure(int types, const QString &path = {}, int maxFileSize = 0, int maxFileCount = 0,
                   bool async = false);

    /*
       logger/filter_rules = [<category>|*][.debug|.info|.warning|.critical]=true|false;...
       logger/message_pattern = <string>
       logger/regexp_filter = <regexp>
       logger/stdout = true|false
       logger/stderr = true|false
       logger/platform_std_log = true|false
       logger/syslog_ident = <string>
       logger/sdjournal = true|false
       logger/path = <string>
       logger/max_file_size = <int>
       logger/max_file_count = <int>
       logger/async = true|false
    */
    void configure(const QSettings &settings, const QString &group = QStringLiteral("logger"));
    void configure(const QString &path, const QString &group = QStringLiteral("logger"));

#ifndef QTLOGGER_NO_THREAD
public:
    void lock() const;
    void unlock() const;
    QRMUTEX *mutex() const;
#endif

public:
    void installMessageHandler();
    static void restorePreviousMessageHandler();

    void processMessage(QtMsgType type, const QMessageLogContext &context, const QString &message);

    static void messageHandler(QtMsgType type, const QMessageLogContext &context,
                               const QString &message);

private:
#ifndef QTLOGGER_NO_THREAD
#    if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
    mutable QRecursiveMutex m_mutex;
#    else
    mutable QMutex m_mutex { QMutex::Recursive };
#    endif
#endif
};

inline Logger &operator<<(Logger *logger, const HandlerPtr &handler)
{
    return *logger << handler;
}

inline Logger &operator<<(Logger *logger, const Pipeline &pipeline)
{
    return *logger << PipelinePtr::create(pipeline);
}

} // namespace QtLogger

// end logger.h

// messagepatterns.h

namespace QtLogger {

constexpr char DefaultMessagePattern[] = "%{if-category}%{category}: %{endif}"
                                         "%{message}";

constexpr char PrettyMessagePattern[] = "%{time dd.MM.yyyy hh:mm:ss.zzz} "
                                        "%{if-debug} %{endif}"
                                        "%{if-info}I%{endif}"
                                        "%{if-warning}W%{endif}"
                                        "%{if-critical}E%{endif}"
                                        "%{if-fatal}F%{endif} "
                                        "[%{category}] %{message}";

} // namespace QtLogger

// end messagepatterns.h

// setmessagepattern.h

#include <qlogging.h>

namespace QtLogger {

QTLOGGER_EXPORT QString setMessagePattern(const QString &messagePattern);

QTLOGGER_EXPORT QString restorePreviousMessagePattern();

} // namespace QtLogger

// end setmessagepattern.h

// filesink.h

#include <QSharedPointer>

// iodevicesink.h

#include <QIODevice>
#include <QSharedPointer>

namespace QtLogger {

using QIODevicePtr = QSharedPointer<QIODevice>;

class QTLOGGER_EXPORT IODeviceSink : public Sink
{
public:
    explicit IODeviceSink(const QIODevicePtr &device);

    void send(const LogMessage &lmsg) override;

protected:
    const QIODevicePtr &device() const;
    void setDevice(const QIODevicePtr &device);

private:
    QIODevicePtr m_device;
};

using IODeviceSinkPtr = QSharedPointer<IODeviceSink>;

} // namespace QtLogger

// end iodevicesink.h

QT_FORWARD_DECLARE_CLASS(QFile)

namespace QtLogger {

class QTLOGGER_EXPORT FileSink : public IODeviceSink
{
public:
    explicit FileSink(const QString &path);
    ~FileSink() override;

    bool flush() override;

protected:
    QFile *file() const;
};

using FileSinkPtr = QSharedPointer<FileSink>;

} // namespace QtLogger

// end filesink.h

// platformstdsink.h

#include <QSharedPointer>

#if defined(QTLOGGER_ANDROIDLOG)

// androidlogsink.h

#ifdef QTLOGGER_ANDROIDLOG

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT AndroidLogSink : public Sink
{
public:
    void send(const LogMessage &lmsg) override;
};

using AndroidLogSinkPtr = QSharedPointer<AndroidLogSink>;

} // namespace QtLogger

#endif // QTLOGGER_ANDROIDLOG

// end androidlogsink.h

#elif defined(QTLOGGER_OSLOG)

// oslogsink.h

#ifdef QTLOGGER_OSLOG

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT OslogSink : public Sink
{
public:
    void send(const LogMessage &lmsg);
};

using OslogSinkPtr = QSharedPointer<OslogSink>;

} // namespace QtLogger

#endif // QTLOGGER_OSLOG

// end oslogsink.h

#else

// stderrsink.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT StdErrSink : public Sink
{
public:
    void send(const LogMessage &lmsg) override;
    virtual bool flush() override;
};

using StdErrSinkPtr = QSharedPointer<StdErrSink>;

} // namespace QtLogger

// end stderrsink.h

#endif

namespace QtLogger {

#if defined(QTLOGGER_ANDROIDLOG)
using PlatformStdSink = AndroidLogSink;
#elif defined(QTLOGGER_OSLOG)
using PlatformStdSink = OslogSink;
#else
using PlatformStdSink = StdErrSink;
#endif

using PlatformStdSinkPtr = QSharedPointer<PlatformStdSink>;

}

// end platformstdsink.h

// rotatingfilesink.h

#include <QSharedPointer>

namespace QtLogger {

constexpr int RotatingFileDefaultMaxFileSize = 1024 * 1024;
constexpr int RotatingFileDefaultMaxFileCount = 3;
constexpr int RotatingFileCountLimit = 1024;

class QTLOGGER_EXPORT RotatingFileSink : public FileSink
{
public:
    explicit RotatingFileSink(const QString &path, int maxFileSize = RotatingFileDefaultMaxFileSize,
                              int maxFileCount = RotatingFileDefaultMaxFileCount);

    void send(const LogMessage &lmsg) override;

private:
    void rotate();

private:
    int m_maxFileSize = RotatingFileDefaultMaxFileSize;
    int m_maxFileCount = RotatingFileDefaultMaxFileCount;
};

using RotatingFileSinkPtr = QSharedPointer<RotatingFileSink>;

} // namespace QtLogger

// end rotatingfilesink.h

// signalsink.h

#include <QObject>

namespace QtLogger {

class QTLOGGER_EXPORT SignalSink : public QObject, Sink
{
    Q_OBJECT

public:
    explicit SignalSink(QObject *parent = nullptr);

    void send(const LogMessage &lmsg) override;

Q_SIGNALS:
    void message(const QtLogger::LogMessage &lmsg);
};

using SignalSinkPtr = QSharedPointer<SignalSink>;

} // namespace QtLogger

// end signalsink.h

// stdoutsink.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT StdOutSink : public Sink
{
public:
    void send(const LogMessage &lmsg) override;
    virtual bool flush() override;
};

using StdOutSinkPtr = QSharedPointer<StdOutSink>;

} // namespace QtLogger

// end stdoutsink.h

// version.h

#define QTLOGGER_VERSION 0.5.0

// end version.h

#ifdef QTLOGGER_NETWORK

// hostinfoattrs.h

#ifdef QTLOGGER_NETWORK

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT HostInfoAttrs : public AttrHandler
{
public:
    QVariantHash attributes() override;
};

using HostInfoAttrsPtr = QSharedPointer<HostInfoAttrs>;

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// end hostinfoattrs.h

// httpsink.h

#ifdef QTLOGGER_NETWORK

#include <QNetworkRequest>
#include <QSharedPointer>
#include <QPointer>
#include <QUrl>

QT_FORWARD_DECLARE_CLASS(QNetworkAccessManager)

namespace QtLogger {

class QTLOGGER_EXPORT HttpSink : public Sink
{
public:
    explicit HttpSink(const QUrl &url);
    ~HttpSink();

    void send(const LogMessage &lmsg) override;

    void setNetworkAccessManager(QNetworkAccessManager *manager);
    void setRequest(const QNetworkRequest &request);

private:
    QUrl m_url;
    QPointer<QNetworkAccessManager> m_manager;
    QNetworkRequest m_request;
};

using HttpSinkPtr = QSharedPointer<HttpSink>;

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// end httpsink.h

#endif

#ifdef Q_OS_WIN

// windebugsink.h

#ifdef Q_OS_WIN

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT WinDebugSink : public Sink
{
public:
    void send(const LogMessage &lmsg) override;
};

using WinDebugSinkPtr = QSharedPointer<WinDebugSink>;

} // namespace QtLogger

#endif

// end windebugsink.h

#endif

#ifdef QTLOGGER_IOSLOG

#endif

#ifdef QTLOGGER_ANDROIDLOG

#endif

#ifdef QTLOGGER_SYSLOG

// syslogsink.h

#ifdef QTLOGGER_SYSLOG

#include <QSharedPointer>

// Syslog options
// See syslog.h for more information
#define QTLOGGER_SYSLOG_LOG_PID  0x01
#define QTLOGGER_SYSLOG_LOG_USER (1 << 3)

namespace QtLogger {

class QTLOGGER_EXPORT SyslogSink : public Sink
{
public:
    explicit SyslogSink(const QString &ident, int option = QTLOGGER_SYSLOG_LOG_PID,
                        int facility = QTLOGGER_SYSLOG_LOG_USER);
    ~SyslogSink();

    void send(const LogMessage &lmsg) override;
};

using SyslogSinkPtr = QSharedPointer<SyslogSink>;

} // namespace QtLogger

#endif // QTLOGGER_SYSLOG

// end syslogsink.h

#endif

#ifdef QTLOGGER_SDJOURNAL

// sdjournalsink.h

#ifdef QTLOGGER_SDJOURNAL

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT SdJournalSink : public Sink
{
public:
    void send(const LogMessage &lmsg) override;
};

using SdJournalSinkPtr = QSharedPointer<SdJournalSink>;

} // namespace QtLogger

#endif // QTLOGGER_SDJOURNAL

// end sdjournalsink.h

#endif

// appinfoattrs.cpp

#include <QCoreApplication>

namespace QtLogger {

QTLOGGER_DECL_SPEC
QVariantHash AppInfoAttrs::attributes()
{
    return QVariantHash {
        { QStringLiteral("app_name"), QCoreApplication::applicationName() },
        { QStringLiteral("app_version"), QCoreApplication::applicationVersion() },
        { QStringLiteral("app_dir"), QCoreApplication::applicationDirPath() },
        { QStringLiteral("app_path"), QCoreApplication::applicationFilePath() },
        { QStringLiteral("pid"), QCoreApplication::applicationPid() },
    };
}

} // namespace QtLogger

// hostinfoattrs.cpp

#ifdef QTLOGGER_NETWORK

#include <QHostInfo>

namespace QtLogger {

QTLOGGER_DECL_SPEC
QVariantHash HostInfoAttrs::attributes()
{
    return QVariantHash {
        { QStringLiteral("host_name"), QHostInfo::localHostName() },
    };
}

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// seqnumberattr.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
QVariantHash SeqNumberAttr::attributes()
{
    return { { "seq_number", m_count++ } };
}

} // namespace QtLogger

// categoryfilter.cpp

#include <QRegularExpression>
#include <qlogging.h>

namespace QtLogger {

struct CategoryFilter::Rule
{
    QRegularExpression category;
    QtMsgType type;
    bool typeMatch;
    bool enabled;

    bool matches(const QString &category, QtMsgType messageType) const;
};

CategoryFilter::CategoryFilter(const QString &a_rules)
{
    auto rules = a_rules;
    rules.replace(";", "\n");
    parseRules(rules);
}

void CategoryFilter::parseRules(const QString &rules)
{
    const auto lines = rules.split('\n', Qt::SkipEmptyParts);
    for (const auto &line : lines) {
        const auto ruleRegex = QRegularExpression(
                R"(^\s*(\S+?)(?:\.(debug|info|warning|critical))?\s*=\s*(true|false)\s*$)");

        const auto match = ruleRegex.match(line);

        if (!match.hasMatch())
            continue;

        auto rule = QSharedPointer<Rule>::create();

        auto category = match.captured(1);
        category = QRegularExpression::escape(category);
        category.replace("\\*", ".*");

        rule->category = QRegularExpression("^" + category + "$");
        rule->type = stringToQtMsgType(match.captured(2));
        rule->typeMatch = !match.captured(2).isEmpty();
        rule->enabled = match.captured(3) == "true";

        m_rules.append(rule);
    }
}

bool CategoryFilter::Rule::matches(const QString &category, QtMsgType messageType) const
{
    return this->category.match(category).hasMatch() && (!typeMatch || type == messageType);
}

bool CategoryFilter::filter(const LogMessage &lmsg)
{
    bool enabled = true;
    for (const auto &rule : m_rules) {
        if (rule->matches(lmsg.category(), lmsg.type())) {
            enabled = rule->enabled;
        }
    }
    return enabled;
}

} // namespace QtLogger

// duplicatefilter.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
bool DuplicateFilter::filter(const LogMessage &lmsg)
{
    if (lmsg.message() == m_lastMessage) {
        return false;
    }

    m_lastMessage = lmsg.message();
    return true;
}

} // namespace QtLogger

// regexpfilter.cpp

#include <QRegularExpression>

namespace QtLogger {

QTLOGGER_DECL_SPEC
RegExpFilter::RegExpFilter(const QRegularExpression &regExp) : m_regExp(regExp) { }

QTLOGGER_DECL_SPEC
QtLogger::RegExpFilter::RegExpFilter(const QString &regExp) : m_regExp(QRegularExpression(regExp))
{
}

QTLOGGER_DECL_SPEC
bool RegExpFilter::filter(const LogMessage &lmsg)
{
    return m_regExp.match(lmsg.message()).hasMatch();
}

} // namespace QtLogger

// jsonformatter.cpp

#include <QCoreApplication>
#include <QJsonDocument>
#include <QJsonObject>

namespace QtLogger {

QTLOGGER_DECL_SPEC
QString JsonFormatter::format(const LogMessage &lmsg)
{
    QJsonObject obj;

    obj[QStringLiteral("message")] = lmsg.message();

    auto attrs = lmsg.allAttributes();
    for (auto it = attrs.cbegin(); it != attrs.cend(); ++it) {
        obj.insert(it.key(), QJsonValue::fromVariant(it.value()));
    }

    return QString::fromUtf8(QJsonDocument(obj).toJson());
}

} // namespace QtLogger

// patternformatter.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
PatternFormatter::PatternFormatter(const QString &pattern) : m_pattern(pattern) { }

QTLOGGER_DECL_SPEC
QString PatternFormatter::format(const LogMessage &lmsg)
{
    // TODO: write own implementation

    QtLogger::setMessagePattern(m_pattern);

    auto result = qFormatLogMessage(lmsg.type(), lmsg.context(), lmsg.message());

    QtLogger::restorePreviousMessagePattern();

    return result;
}

} // namespace QtLogger

// prettyformatter.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
PrettyFormatter::PrettyFormatter(bool showThread, int maxCategoryWidth)
    : m_showThreadId(showThread), m_maxCategoryWidth(maxCategoryWidth)
{
}

QTLOGGER_DECL_SPEC
QString PrettyFormatter::format(const LogMessage &lmsg)
{
    static const QString msg_f { QStringLiteral("%1 %2 %3%4%5%6") };
    static const QString time_f { QStringLiteral("dd.MM.yyyy hh:mm:ss.zzz") };
    static const QStringList type_l {
        QStringLiteral(" "), QStringLiteral("W"), QStringLiteral("E"),
        QStringLiteral("F"), QStringLiteral("I"), QStringLiteral("S")
    };
    static const QString thread_f { QStringLiteral("#%1 ") };
    static const QString category_f { QStringLiteral("[%1] ") };

    QString thread;
    if (m_showThreadId) {
        if (!m_threads.contains(lmsg.threadId())) {
            m_threads[lmsg.threadId()] = m_threadsIndex++;
        }
        if (m_threads.count() > 1) {
            const auto index = m_threads.value(lmsg.threadId());
            thread = thread_f.arg(index);
            if (index == 0) {
                thread.fill(QChar::fromLatin1(' '));
            }
        }
    }

    QString category;
    if (qstrcmp(lmsg.category(), "default") != 0) {
        category = category_f.arg(QString::fromUtf8(lmsg.category()));
    }

    QString space;
    if (m_maxCategoryWidth > 0) {
        int categoryLength = category.length();
        if (categoryLength > m_categoryWidth && categoryLength <= m_maxCategoryWidth) {
            m_categoryWidth = categoryLength;
        }
        space.fill(QChar::fromLatin1(' '), qMax(m_categoryWidth - categoryLength, 0));
    }

    auto result = msg_f.arg(lmsg.time().toString(time_f), type_l.at(lmsg.type()), thread,
                            category, space, lmsg.message());

    return result;
}

} // namespace QtLogger

// logger.cpp

#include <QFileInfo>
#include <QLoggingCategory>
#include <QScopedPointer>

#ifndef QTLOGGER_NO_THREAD
#    include <QAtomicPointer>
#    include <QCoreApplication>
#    include <QMutexLocker>
#endif

#include <iostream>

#ifdef QTLOGGER_NETWORK

#endif

#ifdef QTLOGGER_SYSLOG

#endif

#ifdef QTLOGGER_SDJOURNAL

#endif

#ifdef QTLOGGER_OSLOG

#endif

#ifdef QTLOGGER_ANDROIDLOG

#endif

namespace QtLogger {

namespace {

#ifndef QTLOGGER_NO_THREAD
QAtomicPointer<Logger> g_activeLogger;
#else
Logger *g_activeLogger = nullptr;
#endif

QtMessageHandler g_previousMessageHandler = nullptr;

}

QTLOGGER_DECL_SPEC
Logger *Logger::instance()
{
    static QScopedPointer<Logger> s_instance;

    if (!s_instance) {
        s_instance.reset(new Logger);
        s_instance->installMessageHandler();
    }

    return s_instance.data();
}

QTLOGGER_DECL_SPEC
Logger::~Logger()
{
#ifndef QTLOGGER_NO_THREAD
    g_activeLogger.testAndSetOrdered(this, nullptr);
#else
    if (g_activeLogger == this) {
        g_activeLogger = nullptr;
    }
#endif
}

QTLOGGER_DECL_SPEC
void Logger::setFilterRules(const QString &rules)
{
    QLoggingCategory::setFilterRules(
            QString(rules).replace(QChar::fromLatin1(';'), QChar::fromLatin1('\n')));
}

QTLOGGER_DECL_SPEC
void Logger::setMessagePattern(const QString &pattern)
{
    if (pattern.toLower() == QStringLiteral("default")) {
        QtLogger::setMessagePattern(QString::fromUtf8(DefaultMessagePattern));
        return;
    }

    if (pattern.toLower() == QStringLiteral("pretty")) {
        QtLogger::setMessagePattern(QString::fromUtf8(PrettyMessagePattern));
        return;
    }

    QtLogger::setMessagePattern(pattern);
}

QTLOGGER_DECL_SPEC
Logger &Logger::operator<<(const HandlerPtr &handler)
{
    append(handler);
    return *this;
}

QTLOGGER_DECL_SPEC
void Logger::configure(std::initializer_list<HandlerPtr> handlers, bool async)
{
#ifndef QTLOGGER_NO_THREAD
    QMutexLocker locker(&m_mutex);
#endif

    clear();

    for (const auto &handler : handlers) {
        append(handler);
    }

#ifndef QTLOGGER_NO_THREAD
    if (async) {
        moveToOwnThread();
    }
#else
    Q_UNUSED(async)
#endif
}

QTLOGGER_DECL_SPEC
void Logger::configure(const SinkTypeFlags &types, const QString &path, int maxFileSize,
                       int maxFileCount, bool async)
{
#ifndef QTLOGGER_NO_THREAD
    QMutexLocker locker(&m_mutex);
#endif

    clear();

    setFormatter(PrettyFormatter::instance());

    if (types.testFlag(SinkType::StdOut)) {
        appendSink(StdOutSinkPtr::create());
    }

    if (types.testFlag(SinkType::StdErr)) {
        appendSink(StdErrSinkPtr::create());
    }

    if (types.testFlag(SinkType::PlatformStdLog)) {
        appendSink(PlatformStdSinkPtr::create());
    }

#ifdef QTLOGGER_SYSLOG
    if (types.testFlag(SinkType::Syslog)) {
        appendSink(SyslogSinkPtr::create(QFileInfo(path).baseName()));
    }
#endif

#ifdef QTLOGGER_SDJOURNAL
    if (types.testFlag(SinkType::SdJournal)) {
        appendSink(SdJournalSinkPtr::create());
    }
#endif

    if (types.testFlag(SinkType::File) && !path.isEmpty()) {
        appendSink(FileSinkPtr::create(path));
    }

    if (types.testFlag(SinkType::RotatingFile) && !path.isEmpty()) {
        appendSink(RotatingFileSinkPtr::create(path, maxFileSize, maxFileCount));
    }

#ifndef QTLOGGER_NO_THREAD
    if (async) {
        moveToOwnThread();
    }
#else
    Q_UNUSED(async)
#endif
}

QTLOGGER_DECL_SPEC
void Logger::configure(int types, const QString &path, int maxFileSize, int maxFileCount,
                       bool async)
{
    configure(SinkTypeFlags(QFlag(types)), path, maxFileSize, maxFileCount, async);
}

QTLOGGER_DECL_SPEC
void Logger::configure(const QSettings &settings, const QString &group)
{
#ifndef QTLOGGER_NO_THREAD
    QMutexLocker locker(&m_mutex);
#endif

    clear();

    setFormatter(PrettyFormatter::instance());

    const auto filterRules = settings.value(group + QStringLiteral("/filter_rules")).toString();
    if (!filterRules.isEmpty()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: filterRules: " << filterRules.toStdString() << std::endl;
#endif
        setFilterRules(filterRules);
    }

    const auto messagePattern =
            settings.value(group + QStringLiteral("/message_pattern")).toString();
    if (!messagePattern.isEmpty()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: messagePattern: " << messagePattern.toStdString()
                  << std::endl;
#endif
        setFormatter(PatternFormatterPtr::create(messagePattern));
    }

    const auto regExpFilter = settings.value(group + QStringLiteral("/regexp_filter")).toString();
    if (!regExpFilter.isEmpty()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: filter: " << regExpFilter.toStdString() << std::endl;
#endif
        appendFilter(RegExpFilterPtr::create(regExpFilter));
    }

    if (settings.value(group + QStringLiteral("/stdout"), false).toBool()) {
        std::cerr << "Logger::configure: stdout" << std::endl;
        appendSink(StdOutSinkPtr::create());
    }

    if (settings.value(group + QStringLiteral("/stderr"), false).toBool()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: stderr" << std::endl;
#endif
        appendSink(StdErrSinkPtr::create());
    }

    if (settings.value(group + QStringLiteral("/platform_std_log"), true).toBool()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: platform_std_log" << std::endl;
#endif
        appendSink(PlatformStdSinkPtr::create());
    }

#ifdef QTLOGGER_SYSLOG
    const auto syslogIdent = settings.value(group + QStringLiteral("/syslog_ident")).toString();
    if (!syslogIdent.isEmpty()) {
#    ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: syslogIdent: " << syslogIdent.toStdString() << std::endl;
#    endif
        appendSink(SyslogSinkPtr::create(syslogIdent));
    }
#endif

#ifdef QTLOGGER_SDJOURNAL
    if (settings.value(group + QStringLiteral("/sdjournal"), false).toBool()) {
#    ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: sd-journal" << std::endl;
#    endif
        appendSink(SdJournalSinkPtr::create());
    }
#endif

    const auto path = settings.value(group + QStringLiteral("/path")).toString();
    if (!path.isEmpty()) {
        const auto maxFileSize = settings.value(group + QStringLiteral("/max_file_size"),
                                                RotatingFileDefaultMaxFileSize)
                                         .toInt();

        const auto maxFileCount = settings.value(group + QStringLiteral("/max_file_count"),
                                                 RotatingFileDefaultMaxFileCount)
                                          .toInt();

#ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: path: " << path.toStdString()
                  << " maxFileSize: " << maxFileSize << " maxFileCount: " << maxFileCount
                  << std::endl;
#endif

        appendSink(RotatingFileSinkPtr::create(path, maxFileSize, maxFileCount));
    }

#ifdef QTLOGGER_NETWORK
    const auto httpUrl = settings.value(group + QStringLiteral("/http_url")).toString();
    if (!httpUrl.isEmpty()) {
        const auto httpMsgFormat = settings.value(group + QStringLiteral("/http_msg_format"),
                                                  QStringLiteral("default"))
                                           .toString();
        // TODO: add support for http_msg_format (json)
        appendSink(HttpSinkPtr::create(QUrl(httpUrl)));
    }
#endif

#ifndef QTLOGGER_NO_THREAD
    if (settings.value(group + QStringLiteral("/async"), false).toBool()) {
#    ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: async" << std::endl;
#    endif
        moveToOwnThread();
    }
#endif
}

QTLOGGER_DECL_SPEC
void Logger::configure(const QString &path, const QString &group)
{
    configure(QSettings(path, QSettings::IniFormat), group);
}

#ifndef QTLOGGER_NO_THREAD

QTLOGGER_DECL_SPEC
void Logger::lock() const
{
    m_mutex.lock();
}

QTLOGGER_DECL_SPEC
void Logger::unlock() const
{
    m_mutex.unlock();
}

QTLOGGER_DECL_SPEC
QRMUTEX *Logger::mutex() const
{
    return &m_mutex;
}

#endif

QTLOGGER_DECL_SPEC
void Logger::processMessage(QtMsgType type, const QMessageLogContext &context,
                            const QString &message)
{
    LogMessage lmsg(type, context, message);

    process(lmsg);
}

QTLOGGER_DECL_SPEC
void Logger::messageHandler(QtMsgType type, const QMessageLogContext &context,
                            const QString &message)
{
#ifndef QTLOGGER_NO_THREAD
    auto logger = g_activeLogger.loadAcquire();
#else
    auto logger = g_activeLogger;
#endif

    if (!logger)
        return;

#ifndef QTLOGGER_NO_THREAD
    QMutexLocker locker(logger->mutex());
#endif

    logger->processMessage(type, context, message);
}

QTLOGGER_DECL_SPEC
void Logger::installMessageHandler()
{
#ifndef QTLOGGER_NO_THREAD
    g_activeLogger.storeRelease(this);
#else
    g_activeLogger = this;
#endif

    auto prev = qInstallMessageHandler(messageHandler);

    if (prev != messageHandler) {
        g_previousMessageHandler = prev;
    }
}

QTLOGGER_DECL_SPEC
void Logger::restorePreviousMessageHandler()
{
    if (!g_previousMessageHandler)
        return;

    auto prev = qInstallMessageHandler(g_previousMessageHandler);

    if (prev != messageHandler) {
        qInstallMessageHandler(prev);
    }

    g_previousMessageHandler = nullptr;
}

} // namespace QtLogger

// ownthreadpipeline.cpp

#include <QCoreApplication>
#include <QEvent>
#include <QThread>

namespace QtLogger {

namespace {

static QEvent::Type __processLogMessageEventType = static_cast<QEvent::Type>(QEvent::User + 2000);

struct QTLOGGER_EXPORT ProcessLogMessageEvent : public QEvent
{
    LogMessage lmsg;
    ProcessLogMessageEvent(const LogMessage &lmsg)
        : QEvent(__processLogMessageEventType), lmsg(lmsg)
    {
    }
};

}

class QTLOGGER_EXPORT OwnThreadPipelineWorker : public QObject
{
public:
    explicit OwnThreadPipelineWorker(OwnThreadPipeline *handler, QObject *parent = nullptr)
        : QObject(parent), m_handler(handler)
    {
    }

    void customEvent(QEvent *event) override
    {
        if (event->type() == __processLogMessageEventType) {
            auto _event = dynamic_cast<ProcessLogMessageEvent *>(event);
            if (_event) {
                m_handler->SimplePipeline::process(_event->lmsg);
            }
        }
    }

private:
    OwnThreadPipeline *m_handler;
};

QTLOGGER_DECL_SPEC
OwnThreadPipeline::OwnThreadPipeline()
{
    qRegisterMetaType<QtLogger::LogMessage>("QtLogger::LogMessage");
}

QTLOGGER_DECL_SPEC
OwnThreadPipeline::~OwnThreadPipeline()
{
#ifndef QTLOGGER_NO_THREAD
    if (m_thread) {
        m_thread->quit();
        m_thread->wait(1000);
        if (m_thread)
            delete m_thread;
    }

    if (m_worker) {
        delete m_worker;
    }
#endif
}

QTLOGGER_DECL_SPEC
OwnThreadPipeline &OwnThreadPipeline::moveToOwnThread()
{
    if (!m_worker) {
        m_worker = new OwnThreadPipelineWorker(this);
    }

    if (!m_thread) {
        m_thread = new QThread;

        if (qApp) {
            if (qApp->thread() != m_thread->thread())
                m_thread->moveToThread(qApp->thread());
            QObject::connect(qApp, &QCoreApplication::aboutToQuit, m_thread, &QThread::quit);
        }

        QObject::connect(m_thread, &QThread::finished, m_thread, &QThread::deleteLater);
        QObject::connect(m_thread, &QThread::finished, m_worker, &QThread::deleteLater);

        m_thread->start();
    }

    m_worker->moveToThread(m_thread);

    return *this;
}

QTLOGGER_DECL_SPEC
void OwnThreadPipeline::moveToMainThread()
{
    m_worker->moveToThread(qApp->thread());

    if (m_thread) {
        m_thread->quit();
    }
}

QTLOGGER_DECL_SPEC
bool OwnThreadPipeline::ownThreadIsRunning() const
{
    return m_thread && m_thread->isRunning();
}

QTLOGGER_DECL_SPEC
bool OwnThreadPipeline::process(LogMessage &lmsg)
{
    if (!ownThreadIsRunning()) {
        SimplePipeline::process(lmsg);
    } else {
        QCoreApplication::postEvent(m_worker, new ProcessLogMessageEvent(lmsg));
    }
    return true;
}

} // namespace QtLogger

// pipeline.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
Pipeline::Pipeline(std::initializer_list<HandlerPtr> handlers) : m_handlers(handlers) { }

QTLOGGER_DECL_SPEC
void Pipeline::append(const HandlerPtr &handler)
{
    if (handler.isNull())
        return;

    m_handlers.append(handler);
}

QTLOGGER_DECL_SPEC
void Pipeline::append(std::initializer_list<HandlerPtr> handlers)
{
    m_handlers.append(handlers);
}

QTLOGGER_DECL_SPEC
void Pipeline::remove(const HandlerPtr &handler)
{
    if (handler.isNull())
        return;

    m_handlers.removeAll(handler);
}

QTLOGGER_DECL_SPEC
void Pipeline::clear()
{
    m_handlers.clear();
}

QTLOGGER_DECL_SPEC
Pipeline &Pipeline::operator<<(const HandlerPtr &handler)
{
    append(handler);
    return *this;
}

QTLOGGER_DECL_SPEC
bool Pipeline::process(LogMessage &lmsg)
{
    QString fmsg;
    QVariantHash attrs;

    if (m_scoped) {
        if (lmsg.isFormatted()) {
            fmsg = lmsg.formattedMessage();
        }
        attrs = lmsg.attributes();
    }

    for (auto &handler : m_handlers) {
        if (!handler)
            continue;
        if (!handler->process(lmsg))
            break;
    }

    if (m_scoped) {
        lmsg.setFormattedMessage(fmsg);
        lmsg.attributes() = attrs;
    }

    return true;
}

} // namespace QtLogger

// setmessagepattern.cpp

#include <QString>

namespace {

QTLOGGER_DECL_SPEC
QString prevMessagePattern(const QString &messagePattern = {})
{
    static QString __prevMessagePattern { QString::fromUtf8(QtLogger::DefaultMessagePattern) };

    if (!messagePattern.isNull())
        __prevMessagePattern = messagePattern;

    return __prevMessagePattern;
}

}

namespace QtLogger {

QTLOGGER_DECL_SPEC
QString setMessagePattern(const QString &messagePattern)
{
    static QString __messagePattern { QString::fromUtf8(QtLogger::DefaultMessagePattern) };

    if (__messagePattern == messagePattern)
        return __messagePattern;

    prevMessagePattern(__messagePattern);

    __messagePattern = messagePattern;

    qSetMessagePattern(__messagePattern);

    return prevMessagePattern();
}

QTLOGGER_DECL_SPEC
QString restorePreviousMessagePattern()
{
    return setMessagePattern(prevMessagePattern());
}

} // namespace QtLogger

// simplepipeline.cpp

#include <QCoreApplication>

#ifdef QTLOGGER_NETWORK

#endif

#ifdef QTLOGGER_SYSLOG

#endif

#ifdef QTLOGGER_SDJOURNAL

#endif

#ifdef Q_OS_WIN

#endif

namespace QtLogger {

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::addSeqNumber()
{
    append(SeqNumberAttrPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::addAppInfo()
{
    append(AppInfoAttrsPtr::create());
    return *this;
}

#ifdef QTLOGGER_NETWORK
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::addHostInfo()
{
    append(HostInfoAttrsPtr::create());
    return *this;
}
#endif

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::filter(std::function<bool(const LogMessage &)> func)
{
    append(FunctionFilterPtr::create(func));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::filterCategory(const QString &rules)
{
    append(CategoryFilterPtr::create(rules));
    return *this;
}

SimplePipeline &SimplePipeline::filterDuplicate()
{
    append(DuplicateFilterPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::filter(const QString &regexp)
{
    append(RegExpFilterPtr::create(regexp));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::format(std::function<QString(const LogMessage &)> func)
{
    append(FunctionFormatterPtr::create(func));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::format(const QString &pattern)
{
    if (pattern == "default")
        append(PatternFormatterPtr::create(DefaultMessagePattern));
    else if (pattern == "qt")
        append(QtLogMessageFormatter::instance());
    else if (pattern == "pretty")
        append(PrettyFormatterPtr::create());
    else
        append(PatternFormatterPtr::create(pattern));
    return *this;
}

SimplePipeline &SimplePipeline::formatByQt()
{
    append(QtLogMessageFormatter::instance());
    return *this;
}

SimplePipeline &SimplePipeline::formatPretty()
{
    append(PrettyFormatterPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::formatToJson()
{
    append(JsonFormatterPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToStdOut()
{
    append(StdOutSinkPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToStdErr()
{
    append(StdErrSinkPtr::create());
    return *this;
}

#ifdef QTLOGGER_SYSLOG
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToSyslog()
{
    append(SyslogSinkPtr::create(QCoreApplication::applicationName()));
    return *this;
}
#endif

#ifdef QTLOGGER_SDJOURNAL
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToSdJournal()
{
    append(SdJournalSinkPtr::create());
    return *this;
}
#endif

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToPlatformStdLog()
{
    append(PlatformStdSinkPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToFile(const QString &fileName, int maxFileSize,
                                           int maxFileCount)
{
    if (maxFileSize == 0)
        append(RotatingFileSinkPtr::create(fileName));
    else
        append(RotatingFileSinkPtr::create(fileName, maxFileSize, maxFileCount));
    return *this;
}

#ifdef QTLOGGER_NETWORK
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToHttp(const QString &url)
{
    append(HttpSinkPtr::create(url));
    return *this;
}
#endif

#ifdef Q_OS_WIN
SimplePipeline &SimplePipeline::sendToWinDebug()
{
    append(WinDebugSinkPtr::create());
    return *this;
}
#endif

SimplePipeline &SimplePipeline::pipeline()
{
    auto pipeline = SimplePipelinePtr::create(true, this);
    append(pipeline);
    return *pipeline.data();
}

SimplePipeline &SimplePipeline::end()
{
    if (m_parent)
        return *m_parent;
    else
        return *this;
}

} // namespace QtLogger

// androidlogsink.cpp

#ifdef QTLOGGER_ANDROIDLOG

#include <android/log.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void AndroidLogSink::send(const LogMessage &lmsg)
{
    auto priority = ANDROID_LOG_DEBUG;

    switch (lmsg.type()) {
    case QtDebugMsg:
        priority = ANDROID_LOG_DEBUG;
        break;
    case QtInfoMsg:
        priority = ANDROID_LOG_INFO;
        break;
    case QtWarningMsg:
        priority = ANDROID_LOG_WARN;
        break;
    case QtCriticalMsg:
        priority = ANDROID_LOG_ERROR;
        break;
    case QtFatalMsg:
        priority = ANDROID_LOG_FATAL;
        break;
    };

    __android_log_print(priority, lmsg.category(), "%s", qPrintable(lmsg.message()));

    // TODO: use __android_log_write_log_message for API level 30 and above
}

} // namespace QtLogger

#endif // QTLOGGER_ANDROIDLOG

// filesink.cpp

#include <QDateTime>
#include <QFile>
#include <QRegularExpression>
#include <QSharedPointer>

#include <iostream>

namespace QtLogger {

namespace {

/**
 * @brief Replaces the time pattern in the given string with the current date and time.
 *
 * This function searches for a time pattern in the format `%{time <format>}` within the input
 * string. If found, it replaces the pattern with the current date and time formatted according to
 * the specified format. If no format is specified, it defaults to "yyyyMMdd_hhmmss".
 *
 * @param path The input string potentially containing the time pattern.
 * @return A new string with the time pattern replaced by the current date and time.
 */

QTLOGGER_DECL_SPEC
QString replaceTimePattern(const QString &path)
{
    static auto re = QRegularExpression(QStringLiteral("(.*)%{time *(.*?)}(.*)"));
    auto match = re.match(path);

    if (!match.hasMatch())
        return path;

    auto format = match.captured(2);

    if (format.isEmpty()) {
        format = QStringLiteral("yyyyMMdd_hhmmss");
    }

    return match.captured(1) + QDateTime::currentDateTime().toString(format) + match.captured(3);
}

QTLOGGER_DECL_SPEC
QSharedPointer<QFile> createFilePtr(const QString &path)
{
    return QSharedPointer<QFile>::create(replaceTimePattern(path));
}

}

QTLOGGER_DECL_SPEC
FileSink::FileSink(const QString &path) : IODeviceSink(createFilePtr(path))
{
    if (!file()->open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text)) {
        std::cerr << "Logger::FileHandler: Can't open log file: " << path.toStdString()
                  << " error: " << file()->errorString().toStdString() << std::endl;
    }
}

QTLOGGER_DECL_SPEC
FileSink::~FileSink()
{
    file()->close();
}

QTLOGGER_DECL_SPEC
bool FileSink::flush()
{
    return file()->flush();
}

QTLOGGER_DECL_SPEC
QFile *FileSink::file() const
{
    return qobject_cast<QFile *>(device().data());
}

} // namespace QtLogger

// httpsink.cpp

#ifdef QTLOGGER_NETWORK

#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QNetworkRequest>

namespace QtLogger {

QTLOGGER_DECL_SPEC
HttpSink::HttpSink(const QUrl &url) : m_url(url)
{
    m_manager = new QNetworkAccessManager;

#ifndef QTLOGGER_NO_THREAD
    if (m_manager->thread() != Logger::instance()->ownThread()) {
        m_manager->moveToThread(Logger::instance()->ownThread());
    }
#endif

    m_request.setUrl(m_url);
}

QTLOGGER_DECL_SPEC
HttpSink::~HttpSink()
{
    if (!m_manager.isNull()) {
        delete m_manager.data();
    }
}

QTLOGGER_DECL_SPEC
void HttpSink::send(const LogMessage &lmsg)
{
    if (!Logger::instance()->ownThreadIsRunning()) {
        if (!m_manager.isNull() && !m_manager->property("activeReply").isValid())
            m_manager->deleteLater();
        m_manager = new QNetworkAccessManager;
    }

    if (lmsg.hasAttribute("mime_type")) {
        m_request.setHeader(QNetworkRequest::ContentTypeHeader,
                            QStringLiteral("%1; charset=utf-8")
                                    .arg(lmsg.attribute("mime_type").toByteArray()));
    } else {
        m_request.setHeader(QNetworkRequest::ContentTypeHeader,
                            QStringLiteral("text/plain; charset=utf-8"));
    }

    auto reply = m_manager->post(m_request, lmsg.formattedMessage().toUtf8());

    QObject::connect(reply, &QNetworkReply::finished, reply, &QObject::deleteLater);

    if (!Logger::instance()->ownThreadIsRunning()) {
        m_manager->setProperty("activeReply", QVariant::fromValue(reply));
        QObject::connect(reply, &QNetworkReply::finished, m_manager, &QObject::deleteLater);
    }
}

QTLOGGER_DECL_SPEC
void HttpSink::setNetworkAccessManager(QNetworkAccessManager *manager)
{
    if (!m_manager.isNull()) {
        delete m_manager.data();
    }
    m_manager = manager;
}

QTLOGGER_DECL_SPEC
void HttpSink::setRequest(const QNetworkRequest &request)
{
    m_request = request;
}

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// iodevicesink.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
IODeviceSink::IODeviceSink(const QIODevicePtr &device) : m_device(device) { }

QTLOGGER_DECL_SPEC
void IODeviceSink::send(const LogMessage &lmsg)
{
    if (m_device.isNull()) {
        return;
    }

    m_device->write(lmsg.formattedMessage().toLocal8Bit().append("\n"));
}

QTLOGGER_DECL_SPEC
const QIODevicePtr &IODeviceSink::device() const
{
    return m_device;
}

QTLOGGER_DECL_SPEC
void IODeviceSink::setDevice(const QIODevicePtr &device)
{
    m_device = device;
}

} // namespace QtLogger

// oslogsink.cpp

#ifdef QTLOGGER_OSLOG

#include <os/log.h>

#include <QCoreApplication>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void OslogSink::send(const LogMessage &lmsg)
{
    auto customLog = os_log_create(qPrintable(QCoreApplication::applicationName()),
                                   qPrintable(lmsg.category()));

    auto type = OS_LOG_TYPE_DEBUG;
    switch (lmsg.type()) {
    case QtDebugMsg:
        type = OS_LOG_TYPE_DEBUG;
        break;
    case QtInfoMsg:
        type = OS_LOG_TYPE_INFO;
        break;
    case QtWarningMsg:
        type = OS_LOG_TYPE_ERROR;
        break;
    case QtCriticalMsg:
        type = OS_LOG_TYPE_FAULT;
        break;
    case QtFatalMsg:
        type = OS_LOG_TYPE_FAULT;
        break;
    };

    os_log_with_type(customLog, type, "%s", qPrintable(lmsg.message()));
}

} // namespace QtLogger

#endif // QTLOGGER_OSLOG

// rotatingfilesink.cpp

#include <QDir>
#include <QFile>
#include <QFileInfo>
#include <QRegularExpression>

namespace QtLogger {

QTLOGGER_DECL_SPEC
RotatingFileSink::RotatingFileSink(const QString &path, int maxFileSize, int maxFileCount)
    : FileSink(path), m_maxFileSize(maxFileSize), m_maxFileCount(maxFileCount)
{
    if (file()->size() > 0)
        rotate();
}

QTLOGGER_DECL_SPEC
void RotatingFileSink::send(const LogMessage &lmsg)
{
    const auto newFileSize = file()->size() + lmsg.formattedMessage().toLocal8Bit().size();

    if (m_maxFileSize > 0 && file()->size() != 0 && newFileSize > m_maxFileSize) {
        rotate();
    }

    FileSink::send(lmsg);
}

QTLOGGER_DECL_SPEC
QString numberedFileName(const QString &fileName, int i)
{
    return QStringLiteral("%1.%2").arg(fileName).arg(i);
}

QTLOGGER_DECL_SPEC
void RotatingFileSink::rotate()
{
    if (m_maxFileCount == 1)
        return;

    int maxFileCount = m_maxFileCount > 1 ? m_maxFileCount : RotatingFileCountLimit;

    file()->close();

    const auto &fileName = file()->fileName();

    int i = 1;
    for (; i < maxFileCount; ++i) {
        if (!QFile::exists(numberedFileName(fileName, i))) {
            --i;
            break;
        }
    }
    for (; i > 0; --i) {
        const auto &curFileName = numberedFileName(fileName, i);
        const auto &newFileName = numberedFileName(fileName, i + 1);

        QFile::rename(curFileName, newFileName);
    }

    // rename first
    QFile::rename(fileName, numberedFileName(fileName, 1));

    // remove last
    QFile::remove(QStringLiteral("%1.%2").arg(fileName).arg(m_maxFileCount));

    file()->open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text);
}

} // namespace QtLogger

// sdjournalsink.cpp

#ifdef QTLOGGER_SDJOURNAL

#include <systemd/sd-journal.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void SdJournalSink::send(const LogMessage &lmsg)
{
    auto priority = LOG_DEBUG;

    switch (lmsg.type()) {
    case QtDebugMsg:
        priority = LOG_DEBUG;
        break;
    case QtWarningMsg:
        priority = LOG_WARNING;
        break;
    case QtCriticalMsg:
        priority = LOG_ERR;
        break;
    case QtFatalMsg:
        priority = LOG_EMERG;
        break;
    case QtInfoMsg:
        priority = LOG_INFO;
        break;
    default:
        return;
    }

    const auto &file = QByteArrayLiteral("CODE_FILE=") + QByteArray(lmsg.file());
    const auto &line = QByteArrayLiteral("CODE_LINE=") + QByteArray::number(lmsg.line());

    sd_journal_print_with_location(priority, file.constData(), line.constData(), lmsg.function(),
                                   "%s", qPrintable(lmsg.formattedMessage()));

    sd_journal_send_with_location(file.constData(), line.constData(), lmsg.function(), "%s",
                                  qPrintable(lmsg.formattedMessage()), "PRIORITY=%i", priority,
                                  "CATEGORY=%s", lmsg.category(), NULL);
}

} // namespace QtLogger

#endif // QTLOGGER_SDJOURNAL

// signalsink.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
SignalSink::SignalSink(QObject *parent) : QObject(parent) { }

QTLOGGER_DECL_SPEC
void SignalSink::send(const LogMessage &lmsg)
{
    Q_EMIT message(lmsg);
}

} // namespace QtLogger

// stderrsink.cpp

#include <iostream>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void StdErrSink::send(const LogMessage &lmsg)
{
    std::cerr << qPrintable(lmsg.formattedMessage()) << std::endl;
}

bool StdErrSink::flush()
{
    std::flush(std::cerr);
    return true;
}

} // namespace QtLogger

// stdoutsink.cpp

#include <iostream>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void StdOutSink::send(const LogMessage &lmsg)
{
    std::cout << qPrintable(lmsg.formattedMessage()) << std::endl;
}

bool StdOutSink::flush()
{
    std::flush(std::cout);
    return true;
}

} // namespace QtLogger

// syslogsink.cpp

#ifdef QTLOGGER_SYSLOG

#include <syslog.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
SyslogSink::SyslogSink(const QString &ident, int option, int facility)
{
    openlog(qPrintable(ident), option, facility);
}

QTLOGGER_DECL_SPEC
SyslogSink::~SyslogSink()
{
    closelog();
}

QTLOGGER_DECL_SPEC
void SyslogSink::send(const LogMessage &lmsg)
{
    auto priority = LOG_DEBUG;

    switch (lmsg.type()) {
    case QtDebugMsg:
        priority = LOG_DEBUG;
        break;
    case QtWarningMsg:
        priority = LOG_WARNING;
        break;
    case QtCriticalMsg:
        priority = LOG_ERR;
        break;
    case QtFatalMsg:
        priority = LOG_EMERG;
        break;
    case QtInfoMsg:
        priority = LOG_INFO;
        break;
    default:
        return;
    }

    QString formattedMessage;
    if (qstrcmp(lmsg.category(), "default") == 0) {
        formattedMessage = lmsg.message();
    } else {
        formattedMessage = QStringLiteral("%1: %2").arg(lmsg.category(), lmsg.message());
    }

    syslog(priority, "%s", qPrintable(formattedMessage));
}

} // namespace QtLogger

#endif // QTLOGGER_SYSLOG

// windebugsink.cpp

#ifdef Q_OS_WIN

#include <qt_windows.h>

namespace QtLogger {

void WinDebugSink::send(const LogMessage &lmsg)
{
    auto formattedMessage = lmsg.formattedMessage() + u'\n';
    OutputDebugString(reinterpret_cast<const wchar_t *>(formattedMessage.utf16()));
}

} // namespace QtLogger

#endif

// typedpipeline.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
TypedPipeline::~TypedPipeline()
{
    flush();
}

QTLOGGER_DECL_SPEC
void TypedPipeline::insertBefore(HandlerType type, const HandlerPtr &handler)
{
    auto first = std::find_if(handlers().cbegin(), handlers().cend(),
                              [type](const HandlerPtr &x) { return x->type() == type; });

    if (first == handlers().cend()) {
        handlers().prepend(handler);
        return;
    }

    handlers().insert(first, handler);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::insertAfter(HandlerType type, const HandlerPtr &handler)
{
    auto first = std::find_if(handlers().cbegin(), handlers().cend(),
                              [type](const HandlerPtr &x) { return x->type() == type; });

    if (first == handlers().cend()) {
        handlers().prepend(handler);
        return;
    }

    auto last = std::find_if(first, handlers().cend(),
                             [type](const HandlerPtr &x) { return x->type() != type; });

    handlers().insert(last, handler);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::insertBetween(HandlerType leftType, HandlerType rightType,
                                  const HandlerPtr &handler)
{
    auto firstLeft =
            std::find_if(handlers().cbegin(), handlers().cend(),
                         [leftType](const HandlerPtr &x) { return x->type() == leftType; });

    if (firstLeft == handlers().cend()) {

        auto firstRight =
                std::find_if(handlers().cbegin(), handlers().cend(),
                             [rightType](const auto &x) { return x->type() == rightType; });

        if (firstRight != handlers().cend()) {
            handlers().insert(firstRight, handler);
        } else {
            handlers().prepend(handler);
        }

        return;
    }

    auto lastLeft = std::find_if(firstLeft, handlers().cend(),
                                 [leftType](const HandlerPtr &x) { return x->type() != leftType; });

    handlers().insert(lastLeft, handler);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::clearType(HandlerType type)
{
    QMutableListIterator<HandlerPtr> iter(handlers());

    while (iter.hasNext()) {
        if (iter.next()->type() == type) {
            iter.remove();
        }
    }
}

QTLOGGER_DECL_SPEC
void TypedPipeline::appendFilter(const FilterPtr &filter)
{
    if (filter.isNull())
        return;

    insertAfter(HandlerType::Filter, filter);
}

QTLOGGER_DECL_SPEC
FunctionFilterPtr
TypedPipeline::appendFilter(const std::function<bool(const LogMessage &)> &function)
{
    const auto f = FunctionFilterPtr::create(function);

    appendFilter(f);

    return f;
}

QTLOGGER_DECL_SPEC
RegExpFilterPtr TypedPipeline::appendFilter(const QRegularExpression &regExp)
{
    const auto f = RegExpFilterPtr::create(regExp);

    appendFilter(f);

    return f;
}

QTLOGGER_DECL_SPEC
void TypedPipeline::clearFilters()
{
    clearType(HandlerType::Filter);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::setFormatter(const FormatterPtr &formatter)
{
    if (formatter.isNull())
        return;

    clearFormatters();

    insertAfter(HandlerType::Filter, formatter);
}

QTLOGGER_DECL_SPEC
FunctionFormatterPtr TypedPipeline::setFormatter(const FunctionFormatter::Function &function)
{
    const auto f = FunctionFormatterPtr::create(function);

    setFormatter(f);

    return f;
}

QTLOGGER_DECL_SPEC
PatternFormatterPtr TypedPipeline::setFormatter(const QString &pattern)
{
    const auto f = PatternFormatterPtr::create(pattern);

    setFormatter(f);

    return f;
}

QTLOGGER_DECL_SPEC
void TypedPipeline::clearFormatters()
{
    clearType(HandlerType::Formatter);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::appendSink(const SinkPtr &sink)
{
    append(sink);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::clearSinks()
{
    clearType(HandlerType::Sink);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::appendPipeline(const PipelinePtr &pipeline)
{
    append(pipeline);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::clearPipelines()
{
    clearType(HandlerType::Pipeline);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::flush()
{
    for (auto &handler : handlers()) {
        switch (handler->type()) {
        case HandlerType::Sink: {
            auto sink = handler.dynamicCast<Sink>();
            if (sink)
                sink->flush();
            break;
        }
        case HandlerType::Pipeline: {
            auto pipeline = handler.dynamicCast<TypedPipeline>();
            if (pipeline)
                pipeline->flush();
            break;
        }
        default:
            break;
        }
    }
}

} // namespace QtLogger

