// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 Mikhail Yatsenko <mikhail.yatsenko@gmail.com>

// This file is automatically generated. Please don't edit it.

#pragma once

// #define QTLOGGER_NO_THREAD
// #define QTLOGGER_NETWORK
// #define QTLOGGER_IOSLOG
// #define QTLOGGER_ANDROIDLOG
// #define QTLOGGER_SYSLOG
// #define QTLOGGER_JOURNAL

#define QTLOGGER_DECL_SPEC inline

// qtlogger.h

// attrhandler.h

#include <QSharedPointer>

// handler.h

#include <QSharedPointer>

// logger_global.h

#include <QtCore/qglobal.h>

#if defined(QTLOGGER_STATIC)
#    define QTLOGGER_EXPORT
#elif defined(QTLOGGER_LIBRARY)
#    define QTLOGGER_EXPORT Q_DECL_EXPORT
#else
#    define QTLOGGER_EXPORT Q_DECL_IMPORT
#endif

#if !defined(QTLOGGER_DECL_SPEC)
#    define QTLOGGER_DECL_SPEC
#endif

// end logger_global.h

// logmessage.h

#include <QDateTime>
#include <QVariant>
#include <qlogging.h>
#include <chrono>

#ifndef QTLOGGER_NO_THREAD
#    include <QThread>
#endif

namespace QtLogger {

class QTLOGGER_EXPORT LogMessage
{
public:
    LogMessage() noexcept = default;

    LogMessage(QtMsgType type, const QMessageLogContext &context, const QString &message) noexcept
        : m_type(type),
          m_context(context.file, context.line, context.function, context.category),
          m_message(message)
    {
    }

    inline LogMessage(const LogMessage &lmsg) noexcept
        : m_file(lmsg.m_context.file),
          m_function(lmsg.m_context.function),
          m_category(lmsg.m_context.category),
          m_type(lmsg.m_type),
          m_context(m_file.constData(), lmsg.m_context.line, m_function.constData(),
                    m_category.constData()),
          m_message(lmsg.m_message),
          m_time(lmsg.m_time),
          m_steadyTime(lmsg.m_steadyTime),
#ifndef QTLOGGER_NO_THREAD
          m_qthreadptr(lmsg.m_qthreadptr),
#endif
          m_formattedMessage(lmsg.m_formattedMessage),
          m_attributes(lmsg.m_attributes)
    {
    }

    inline QtMsgType type() const { return m_type; }
    inline const QMessageLogContext &context() const { return m_context; }
    inline QString message() const { return m_message; }

    // Context members

    inline int line() const { return m_context.line; }
    inline const char *file() const { return m_context.file; }
    inline const char *function() const { return m_context.function; }
    inline const char *category() const { return m_context.category; }

    // System attributes

    inline QDateTime time() const { return m_time; }
    inline std::chrono::steady_clock::time_point steadyTime() const { return m_steadyTime; }

    inline quint64 threadId() const
    {
#ifndef QTLOGGER_NO_THREAD
        return m_qthreadptr;
#else
        return 0;
#endif
    }
    inline quintptr qthreadptr() const
    {
#ifndef QTLOGGER_NO_THREAD
        return m_qthreadptr;
#else
        return 0;
#endif
    }

    // Formatted message

    inline QString formattedMessage() const
    {
        return isFormatted() ? m_formattedMessage : m_message;
    }
    inline void setFormattedMessage(const QString &formattedMessage)
    {
        m_formattedMessage = formattedMessage;
    }
    inline bool isFormatted() const { return !m_formattedMessage.isNull(); }

    // Custom attributes

    inline QVariant attribute(const QString &name) const { return m_attributes.value(name); }
    inline void setAttribute(const QString &name, const QVariant &value)
    {
        m_attributes.insert(name, value);
    }
    inline void setAttributes(const QVariantHash &attrs)
    {
        m_attributes = attrs;
    }
    inline void updateAttributes(const QVariantHash &attrs)
    {
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
        m_attributes.insert(attrs);
#else
        m_attributes.unite(attrs);
#endif
    }
    inline void removeAttribute(const QString &name)
    {
        m_attributes.remove(name);
    }
    inline bool hasAttribute(const QString &name) const { return m_attributes.contains(name); }
    inline QVariantHash attributes() const { return m_attributes; }

    // All message attributes including: type, line, file, function, category, message,
    // time, threadId and all custom attributes
    QVariantHash allAttributes() const;

private:
    // m_context string buffers
    const QByteArray m_file;
    const QByteArray m_function;
    const QByteArray m_category;

    const QtMsgType m_type = QtDebugMsg;
    const QMessageLogContext m_context;
    const QString m_message;

    const QDateTime m_time = QDateTime::currentDateTime();
    const std::chrono::steady_clock::time_point m_steadyTime = std::chrono::steady_clock::now();
#ifndef QTLOGGER_NO_THREAD
    const quintptr m_qthreadptr = reinterpret_cast<quintptr>(QThread::currentThreadId());
#endif

    QString m_formattedMessage;
    QVariantHash m_attributes;
};

inline QString qtMsgTypeToString(QtMsgType type, const QString &a_default = QStringLiteral("debug"))
{
    static const auto map = QHash<QtMsgType, QString> {
        { QtDebugMsg, QStringLiteral("debug") },
        { QtInfoMsg, QStringLiteral("info") },
        { QtWarningMsg, QStringLiteral("warning") },
        { QtCriticalMsg, QStringLiteral("critical") },
        { QtFatalMsg, QStringLiteral("fatal") },
    };
    return map.value(type, a_default);
}

inline QtMsgType stringToQtMsgType(const QString &str, QtMsgType a_default= QtDebugMsg)
{
    static const auto map = QHash<QString, QtMsgType> {
        { QStringLiteral("debug"), QtDebugMsg },
        { QStringLiteral("info"), QtInfoMsg },
        { QStringLiteral("warning"), QtWarningMsg },
        { QStringLiteral("critical"), QtCriticalMsg },
        { QStringLiteral("fatal"), QtFatalMsg },
    };
    return map.value(str, a_default);
}

inline QVariantHash LogMessage::allAttributes() const
{
    auto attrs = QVariantHash {
        { QStringLiteral("type"), qtMsgTypeToString(type()) },
        { QStringLiteral("line"), line() },
        { QStringLiteral("file"), file() },
        { QStringLiteral("function"), function() },
        { QStringLiteral("category"), category() },
        { QStringLiteral("message"), message() },
        { QStringLiteral("time"), time() },
#ifndef QTLOGGER_NO_THREAD
        { QStringLiteral("threadId"), threadId() },
#endif
    };

#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    attrs.insert(m_attributes);
#else
    attrs.unite(m_attributes);
#endif

    return attrs;
}

} // namespace QtLogger

// end logmessage.h

namespace QtLogger {

class QTLOGGER_EXPORT Handler
{
public:
    enum class HandlerType { Handler, AttrHandler, Filter, Formatter, Sink, Pipeline };

    virtual ~Handler() = default;

    virtual HandlerType type() const { return HandlerType::Handler; }

    virtual bool process(LogMessage &lmsg) = 0;
};

using HandlerPtr = QSharedPointer<Handler>;

inline uint qHash(Handler::HandlerType key, uint seed = 0) noexcept {
    return ::qHash(static_cast<uint>(key), seed);
}

} // namespace QtLogger

// end handler.h

namespace QtLogger {

class QTLOGGER_EXPORT AttrHandler : public Handler
{
public:
    virtual ~AttrHandler() = default;

    virtual QVariantHash attributes(const LogMessage &lmsg) = 0;

    HandlerType type() const override { return HandlerType::AttrHandler; }

    bool process(LogMessage &lmsg) override
    {
        lmsg.updateAttributes(attributes(lmsg));
        return true;
    }
};

using AttrHandlerPtr = QSharedPointer<AttrHandler>;

} // namespace QtLogger

// end attrhandler.h

// appinfoattrs.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT AppInfoAttrs : public AttrHandler
{
public:
    AppInfoAttrs();

    QVariantHash attributes(const LogMessage &lmsg) override;

private:
    QVariantHash m_attrs;
};

using AppInfoAttrsPtr = QSharedPointer<AppInfoAttrs>;

} // namespace QtLogger

// end appinfoattrs.h

// functionattrhandler.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT FunctionAttrHandler : public AttrHandler
{
public:
    using Function = std::function<QVariantHash(const LogMessage &lmsg)>;

    FunctionAttrHandler(const Function &function) : m_function(function) { }

    QVariantHash attributes(const LogMessage &lmsg) override { return m_function(lmsg); }

private:
    Function m_function;
};

using FunctionAttrHandlerPtr = QSharedPointer<FunctionAttrHandler>;

} // namespace QtLogger

// end functionattrhandler.h

// seqnumberattr.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT SeqNumberAttr : public AttrHandler
{
public:
    explicit SeqNumberAttr(const QString &name = QStringLiteral("seq_number"));
    QVariantHash attributes(const LogMessage &lmsg) override;

private:
    QString m_name;
    int m_count = 0;
};

using SeqNumberAttrPtr = QSharedPointer<SeqNumberAttr>;

} // namespace QtLogger

// end seqnumberattr.h

// filter.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Filter : public Handler
{
public:
    virtual ~Filter() = default;

    virtual bool filter(const LogMessage &lmsg) = 0;

    HandlerType type() const override final { return HandlerType::Filter; }

    bool process(LogMessage &lmsg) override final { return filter(lmsg); }
};

using FilterPtr = QSharedPointer<Filter>;

} // namespace QtLogger

// end filter.h

// categoryfilter.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT CategoryFilter : public Filter
{
public:
    CategoryFilter(const QString &rules);

    bool filter(const LogMessage &lmsg) override;

private:
    struct Rule;
    void parseRules(const QString &rules);
    QList<QSharedPointer<Rule>> m_rules;
};

using CategoryFilterPtr = QSharedPointer<CategoryFilter>;

} // namespace QtLogger

// end categoryfilter.h

// duplicatefilter.h

namespace QtLogger {

class QTLOGGER_EXPORT DuplicateFilter : public Filter
{
public:
    bool filter(const LogMessage &lmsg) override;

private:
    QString m_lastMessage;
};

using DuplicateFilterPtr = QSharedPointer<DuplicateFilter>;

} // namespace QtLogger

// end duplicatefilter.h

// functionfilter.h

#include <functional>

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT FunctionFilter : public Filter
{
public:
    using Function = std::function<bool(const LogMessage &)>;

    FunctionFilter(const Function &function) : m_function(function) { }

    bool filter(const LogMessage &lmsg) override { return m_function(lmsg); }

private:
    Function m_function;
};

using FunctionFilterPtr = QSharedPointer<FunctionFilter>;

} // namespace QtLogger

// end functionfilter.h

// levelfilter.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT LevelFilter : public Filter
{
public:
    explicit LevelFilter(QtMsgType minLevel = QtDebugMsg) : m_minLevel(minLevel) { }

    bool filter(const LogMessage &lmsg) override {
        return priority(lmsg.type()) >= priority(m_minLevel);
    }

private:
    static int priority(QtMsgType type) {
        switch (type) {
            case QtDebugMsg:    return 0;
            case QtInfoMsg:     return 1;
            case QtWarningMsg:  return 2;
            case QtCriticalMsg: return 3;
            case QtFatalMsg:    return 4;
        }
        return -1;
    }

    QtMsgType m_minLevel;
};

using LevelFilterPtr = QSharedPointer<LevelFilter>;

} // namespace QtLogger

// end levelfilter.h

// regexpfilter.h

#include <QRegularExpression>
#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT RegExpFilter : public Filter
{
public:
    explicit RegExpFilter(const QRegularExpression &regExp);
    explicit RegExpFilter(const QString &regExp);

    bool filter(const LogMessage &lmsg) override;

private:
    QRegularExpression m_regExp;
};

using RegExpFilterPtr = QSharedPointer<RegExpFilter>;

} // namespace QtLogger

// end regexpfilter.h

// formatter.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Formatter : public Handler
{
public:
    virtual ~Formatter() = default;

    virtual QString format(const LogMessage &lmsg) = 0;

    HandlerType type() const override final { return HandlerType::Formatter; }

    bool process(LogMessage &lmsg) override final
    {
        lmsg.setFormattedMessage(format(lmsg));
        return true;
    }
};

using FormatterPtr = QSharedPointer<Formatter>;

} // namespace QtLogger

// end formatter.h

// functionformatter.h

#include <functional>

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT FunctionFormatter : public Formatter
{
public:
    using Function = std::function<QString(const LogMessage &)>;

    FunctionFormatter(const Function &func) : m_func(func) { }

    QString format(const LogMessage &lmsg) override { return m_func(lmsg); }

private:
    Function m_func;
};

using FunctionFormatterPtr = QSharedPointer<FunctionFormatter>;

} // namespace QtLogger

// end functionformatter.h

// jsonformatter.h

#include <QSharedPointer>

namespace QtLogger {

using JsonFormatterPtr = QSharedPointer<class JsonFormatter>;

class QTLOGGER_EXPORT JsonFormatter : public Formatter
{
public:
    static JsonFormatterPtr instance()
    {
        static const auto s_instance = JsonFormatterPtr::create();
        return s_instance;
    }

    QString format(const LogMessage &lmsg) override;
};

} // namespace QtLogger

// end jsonformatter.h

// patternformatter.h

#include <QSharedPointer>
#include <QScopedPointer>

namespace QtLogger {

using PatternFormatterPtr = QSharedPointer<class PatternFormatter>;

class QTLOGGER_EXPORT PatternFormatter : public Formatter
{
public:
    explicit PatternFormatter(const QString &pattern);
    ~PatternFormatter() override;

    QString format(const LogMessage &lmsg) override;

private:
    class PatternFormatterPrivate;
    QScopedPointer<PatternFormatterPrivate> d;
    Q_DISABLE_COPY(PatternFormatter)
};

} // namespace QtLogger

// end patternformatter.h

// prettyformatter.h

#include <QMap>
#include <QStringList>

namespace QtLogger {

using PrettyFormatterPtr = QSharedPointer<class PrettyFormatter>;

class QTLOGGER_EXPORT PrettyFormatter : public Formatter
{
public:
    static PrettyFormatterPtr instance()
    {
        static const auto s_instance = PrettyFormatterPtr::create(true, 0);
        return s_instance;
    }

    explicit PrettyFormatter(bool showThread = true, int maxCategoryWidth = 15);

    QString format(const LogMessage &lmsg) override;

    inline bool showThreadId() const { return m_showThreadId; }
    inline void setShowThreadId(bool newShowThreadId) { m_showThreadId = newShowThreadId; }

    inline int maxCategoryWidth() const { return m_maxCategoryWidth; }
    inline void setMaxCategoryWidth(int newMaxCategoryWidth)
    {
        m_maxCategoryWidth = newMaxCategoryWidth;
    }

private:
    bool m_showThreadId = true;
    QMap<int, int> m_threads;
    int m_threadsIndex = 0;

    int m_maxCategoryWidth = 15;
    int m_categoryWidth = 0;
};

} // namespace QtLogger

// end prettyformatter.h

// qtlogmessageformatter.h

#include <QSharedPointer>

namespace QtLogger {

using QtLogMessageFormatterPtr = QSharedPointer<class QtLogMessageFormatter>;

class QTLOGGER_EXPORT QtLogMessageFormatter : public Formatter
{
public:
    static QtLogMessageFormatterPtr instance()
    {
        static const auto s_instance = QtLogMessageFormatterPtr(new QtLogMessageFormatter());
        return s_instance;
    }

    QString format(const LogMessage &lmsg) override
    {
        return qFormatLogMessage(lmsg.type(), lmsg.context(), lmsg.message());
    }

private:
    QtLogMessageFormatter() { }
};

} // namespace QtLogger

// end qtlogmessageformatter.h

// functionhandler.h

#include <functional>

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT FunctionHandler : public Handler
{
public:
    using Function = std::function<bool(LogMessage &)>;

    FunctionHandler(Function function) : m_function(std::move(function)) { }

    bool process(LogMessage &lmsg) override { return m_function(lmsg); }

private:
    Function m_function;
};

using FunctionHandlerPtr = QSharedPointer<FunctionHandler>;

} // namespace QtLogger

// end functionhandler.h

// logger.h

#include <QFlags>
#include <QSettings>
#include <QtCore/QtGlobal>

#ifndef QTLOGGER_NO_THREAD
#    include <QMutex>
#endif

// configure.h

#include <QtCore/QtGlobal>
#include <QFlags>
#include <QSettings>
#include <QString>

namespace QtLogger {

class Logger;
class Pipeline;

enum class SinkType {
    Unknown = 0x00,
    StdOut = 0x01,
    StdErr = 0x02,
    Syslog = 0x04,
    SdJournal = 0x8,
    PlatformStdLog = 0x10,
    File = 0x40,
    RotatingFile = 0x80
};

Q_DECLARE_FLAGS(SinkTypeFlags, SinkType)

QTLOGGER_EXPORT void configure(Pipeline *pipeline, const SinkTypeFlags &types,
                                       const QString &path = {}, int maxFileSize = 0,
                                       int maxFileCount = 0, bool async = false);

QTLOGGER_EXPORT void configure(Pipeline *pipeline, int types, const QString &path = {},
                                       int maxFileSize = 0, int maxFileCount = 0,
                                       bool async = false);

/** Configure logger from QSettings
 *
 * Supported settings:
 * logger/filter_rules = [<category>|*][.debug|.info|.warning|.critical]=true|false;...
 * logger/regexp_filter = <regexp>
 * logger/message_pattern = <string>
 * logger/stdout = true|false
 * logger/stderr = true|false
 * logger/platform_std_log = true|false
 * logger/syslog_ident = <string>
 * logger/sdjournal = true|false
 * logger/path = <string>
 * logger/max_file_size = <int>
 * logger/max_file_count = <int>
 * logger/async = true|false
 * logger/http_url = <string>
 * logger/http_msg_format = <string>
 *
 * @param pipeline Target pipeline to configure
 * @param settings QSettings object to read from
 * @param group Settings group name
 */
QTLOGGER_EXPORT void configure(Pipeline *pipeline, const QSettings &settings,
                                       const QString &group = QStringLiteral("logger"));

QTLOGGER_EXPORT void configure(Pipeline *pipeline, const QString &path,
                                       const QString &group = QStringLiteral("logger"));
} // namespace QtLogger

Q_DECLARE_OPERATORS_FOR_FLAGS(QtLogger::SinkTypeFlags)

// end configure.h

// simplepipeline.h

#include <QList>
#include <QSharedPointer>

// sortedpipeline.h

#include <QSet>

// pipeline.h

#include <initializer_list>

#include <QList>
#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Pipeline : public Handler
{
public:
    explicit Pipeline(bool scoped = false) : m_scoped(scoped) {};
    Pipeline(std::initializer_list<HandlerPtr> handlers, bool scoped = false);

    HandlerType type() const override final { return HandlerType::Pipeline; }

    void append(const HandlerPtr &handler);
    void append(std::initializer_list<HandlerPtr> handlers);
    void remove(const HandlerPtr &handler);
    void clear();

    Pipeline &operator<<(const HandlerPtr &handler);

    bool process(LogMessage &lmsg) override;

    QList<HandlerPtr> const& handlers() const { return m_handlers; }

protected:
    QList<HandlerPtr> &handlers() { return m_handlers; }

private:
    QList<HandlerPtr> m_handlers;
    bool m_scoped = false;
};

using PipelinePtr = QSharedPointer<Pipeline>;

inline Pipeline &operator<<(Pipeline *pipeline, const HandlerPtr &handler)
{
    return *pipeline << handler;
}

inline Pipeline &operator<<(PipelinePtr pipeline, const HandlerPtr &handler)
{
    return *pipeline << handler;
}

} // namespace QtLogger

// end pipeline.h

// sink.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Sink : public Handler
{
public:
    virtual void send(const LogMessage &lmsg) = 0;
    virtual bool flush() { return true; }

    HandlerType type() const override final { return HandlerType::Sink; }

    bool process(LogMessage &lmsg) override final
    {
        send(lmsg);
        return true;
    }
};

using SinkPtr = QSharedPointer<Sink>;

} // namespace QtLogger

// end sink.h

namespace QtLogger {

class QTLOGGER_EXPORT SortedPipeline : public Pipeline
{
public:
    explicit SortedPipeline(bool scoped = false) : Pipeline(scoped) { }

    void insertBetweenNearLeft(const QSet<HandlerType> &leftType,
                               const QSet<HandlerType> &rightType, const HandlerPtr &handler);
    void insertBetweenNearRight(const QSet<HandlerType> &leftType,
                                const QSet<HandlerType> &rightType, const HandlerPtr &handler);
    void clear(HandlerType type);
    void clear();

    void appendAttrHandler(const AttrHandlerPtr &attrHandler);
    void clearAttrHandlers();

    void appendFilter(const FilterPtr &filter);
    void clearFilters();

    void setFormatter(const FormatterPtr &formatter);
    void clearFormatters();

    void appendSink(const SinkPtr &sink);
    void clearSinks();

    void appendPipeline(const PipelinePtr &pipeline);
    void clearPipelines();
};

using SortedPipelinePtr = QSharedPointer<SortedPipeline>;

} // namespace QtLogger

// end sortedpipeline.h

namespace QtLogger {

class QTLOGGER_EXPORT SimplePipeline : public SortedPipeline
{
public:
    explicit SimplePipeline(bool scoped = false, SimplePipeline *parent = nullptr)
        : SortedPipeline(scoped), m_parent(parent)
    {
    }

    SimplePipeline &addSeqNumber(const QString &name = QStringLiteral("seq_number"));
    SimplePipeline &addAppInfo();
#ifdef QTLOGGER_NETWORK
    SimplePipeline &addHostInfo();
#endif
    SimplePipeline &attrHandler(std::function<QVariantHash(const LogMessage &lmsg)> func);

    SimplePipeline &filter(std::function<bool(const LogMessage &)> func);
    SimplePipeline &filter(const QString &regexp);
    SimplePipeline &filterCategory(const QString &rules);
    SimplePipeline &filterDuplicate();
    SimplePipeline &filterLevel(QtMsgType minLevel);

    SimplePipeline &format(std::function<QString(const LogMessage &)> func);
    SimplePipeline &format(const QString &pattern);
    SimplePipeline &formatByQt();
    SimplePipeline &formatPretty();
    SimplePipeline &formatToJson();

    SimplePipeline &sendToStdOut();
    SimplePipeline &sendToStdErr();
#ifdef QTLOGGER_SYSLOG
    SimplePipeline &sendToSyslog();
#endif
#ifdef QTLOGGER_SDJOURNAL
    SimplePipeline &sendToSdJournal();
#endif
    SimplePipeline &sendToPlatformStdLog();
    SimplePipeline &sendToFile(const QString &fileName, int maxFileSize = 0, int maxFileCount = 0);
#ifdef QTLOGGER_NETWORK
    SimplePipeline &sendToHttp(const QString &url);
#endif
#ifdef Q_OS_WIN
    SimplePipeline &sendToWinDebug();
#endif

    SimplePipeline &pipeline();
    SimplePipeline &end();

    SimplePipeline &handler(std::function<bool(LogMessage &)> func);

    virtual void flush();

private:
    static void recursiveFlush(const Pipeline *pipeline);

    SimplePipeline *m_parent = nullptr;
};

using SimplePipelinePtr = QSharedPointer<SimplePipeline>;

} // namespace QtLogger

// end simplepipeline.h

#ifndef QTLOGGER_NO_THREAD

// ownthreadhandler.h

#include <type_traits>

#include <QCoreApplication>
#include <QEvent>
#include <QObject>
#include <QPointer>
#include <QThread>

namespace QtLogger {

template<typename BaseHandler>
class QTLOGGER_EXPORT OwnThreadHandler : public BaseHandler
{
    static_assert(std::is_base_of<Handler, BaseHandler>::value,
                  "BaseHandler must inherit from Handler");

public:
    template<typename... Args>
    OwnThreadHandler(Args &&...args) : BaseHandler(std::forward<Args>(args)...)
    {
        static auto __once = qRegisterMetaType<QtLogger::LogMessage>("QtLogger::LogMessage");
        Q_UNUSED(__once)
    }

    ~OwnThreadHandler() override { reset(); }

    OwnThreadHandler<BaseHandler> &moveToOwnThread()
    {
        reset();

        if (!m_worker) {
            m_worker = new Worker(this);
        }

        if (!m_thread) {
            m_thread = new QThread();

            if (qApp) {
                if (qApp->thread() != m_thread->thread()) {
                    m_thread->moveToThread(qApp->thread());
                }
                QObject::connect(qApp, &QCoreApplication::aboutToQuit, m_thread, &QThread::quit);
            }

            QObject::connect(m_thread, &QThread::finished, m_thread, &QThread::deleteLater);
            QObject::connect(m_thread, &QThread::finished, m_worker, &QThread::deleteLater);

            m_thread->start();
        }

        m_worker->moveToThread(m_thread);

        return *this;
    }

    OwnThreadHandler<BaseHandler> &moveToMainThread()
    {
        reset();

        if (!m_worker) {
            m_worker = new Worker(this);
        }

        m_worker->moveToThread(qApp->thread());

        return *this;
    }

    bool ownThreadIsRunning() const { return m_thread && m_thread->isRunning(); }

    QThread *ownThread() const { return m_thread; }

    void reset()
    {
        if (m_thread) {
            m_thread->quit();
            m_thread->wait(100);
            if (m_thread && m_thread->isRunning()) {
                m_thread->terminate();
            }
            if (m_thread) {
                delete m_thread;
            }
        }

        if (m_worker) {
            delete m_worker;
        }
    }

    bool process(LogMessage &lmsg) override
    {
        if (m_worker) {
            QCoreApplication::postEvent(m_worker, new LogMsgEvent(lmsg));
        } else {
            BaseHandler::process(lmsg);
        }
        return true;
    }

private:
    static QEvent::Type getLogMsgEventType()
    {
        static QEvent::Type type = static_cast<QEvent::Type>(QEvent::registerEventType());
        return type;
    }

    struct LogMsgEvent : public QEvent
    {
        LogMessage lmsg;
        LogMsgEvent(const LogMessage &lmsg) : QEvent(getLogMsgEventType()), lmsg(lmsg) { }
    };

    class Worker : public QObject
    {
    public:
        explicit Worker(OwnThreadHandler<BaseHandler> *handler) : QObject(), m_handler(handler) { }

        void customEvent(QEvent *event) override
        {
            if (event->type() == getLogMsgEventType()) {
                auto lmEvent = dynamic_cast<LogMsgEvent *>(event);
                if (lmEvent) {
                    m_handler->BaseHandler::process(lmEvent->lmsg);
                }
            }
        }

    private:
        OwnThreadHandler<BaseHandler> *m_handler;
    };

    QPointer<Worker> m_worker;
    QPointer<QThread> m_thread;
};

} // namespace QtLogger

// end ownthreadhandler.h

#endif

#define gQtLogger (*QtLogger::Logger::instance())

#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
#    define QRMUTEX QRecursiveMutex
#else
#    define QRMUTEX QMutex
#endif

namespace QtLogger {

class QTLOGGER_EXPORT Logger :
#ifndef QTLOGGER_NO_THREAD
    public OwnThreadHandler<SimplePipeline>
#else
    public SimplePipeline
#endif
{
public:
    using SinkType = QtLogger::SinkType;
    using SinkTypeFlags = QtLogger::SinkTypeFlags;

    static Logger *instance();

    Logger() = default;
    ~Logger() override;

    void configure(const SinkTypeFlags &types = SinkType::PlatformStdLog, const QString &path = {},
                   int maxFileSize = 0, int maxFileCount = 0, bool async = false);

    void configure(int types, const QString &path = {}, int maxFileSize = 0, int maxFileCount = 0,
                   bool async = false);

    /** Configure logger from QSettings or ini file
     *
     * logger/filter_rules = [<category>|*][.debug|.info|.warning|.critical]=true|false;...
     * logger/regexp_filter = <regexp>
     * logger/message_pattern = <string>
     * logger/stdout = true|false
     * logger/stderr = true|false
     * logger/platform_std_log = true|false
     * logger/syslog_ident = <string>
     * logger/sdjournal = true|false
     * logger/path = <string>
     * logger/max_file_size = <int>
     * logger/max_file_count = <int>
     * logger/async = true|false
     */
    void configure(const QSettings &settings, const QString &group = QStringLiteral("logger"));
    void configure(const QString &path, const QString &group = QStringLiteral("logger"));

    Logger &operator<<(const HandlerPtr &handler);

public:
    void installMessageHandler();
    static void restorePreviousMessageHandler();

    void processMessage(QtMsgType type, const QMessageLogContext &context, const QString &message);

    static void messageHandler(QtMsgType type, const QMessageLogContext &context,
                               const QString &message);

#ifndef QTLOGGER_NO_THREAD
public:
    void lock() const;
    void unlock() const;
    inline QRMUTEX *mutex() const { return &m_mutex; }
private:
#    if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
    mutable QRecursiveMutex m_mutex;
#    else
    mutable QMutex m_mutex { QMutex::Recursive };
#    endif
#endif
};

inline Logger &operator<<(Logger *logger, const HandlerPtr &handler)
{
    return *logger << handler;
}

inline Logger &operator<<(Logger *logger, const Pipeline &pipeline)
{
    return *logger << PipelinePtr::create(pipeline);
}

} // namespace QtLogger

// end logger.h

// messagepatterns.h

namespace QtLogger {

constexpr char DefaultMessagePattern[] = "%{if-category}%{category}: %{endif}"
                                         "%{message}";

constexpr char PrettyMessagePattern[] = "%{time dd.MM.yyyy hh:mm:ss.zzz} "
                                        "%{if-debug} %{endif}"
                                        "%{if-info}I%{endif}"
                                        "%{if-warning}W%{endif}"
                                        "%{if-critical}E%{endif}"
                                        "%{if-fatal}F%{endif} "
                                        "[%{category}] %{message}";

} // namespace QtLogger

// end messagepatterns.h

// filesink.h

#include <QSharedPointer>

// iodevicesink.h

#include <QIODevice>
#include <QSharedPointer>

namespace QtLogger {

using QIODevicePtr = QSharedPointer<QIODevice>;

class QTLOGGER_EXPORT IODeviceSink : public Sink
{
public:
    explicit IODeviceSink(const QIODevicePtr &device);

    void send(const LogMessage &lmsg) override;

protected:
    const QIODevicePtr &device() const;
    void setDevice(const QIODevicePtr &device);

private:
    QIODevicePtr m_device;
};

using IODeviceSinkPtr = QSharedPointer<IODeviceSink>;

} // namespace QtLogger

// end iodevicesink.h

QT_FORWARD_DECLARE_CLASS(QFile)

namespace QtLogger {

class QTLOGGER_EXPORT FileSink : public IODeviceSink
{
public:
    explicit FileSink(const QString &path);
    ~FileSink() override;

    bool flush() override;

protected:
    QFile *file() const;
};

using FileSinkPtr = QSharedPointer<FileSink>;

} // namespace QtLogger

// end filesink.h

// platformstdsink.h

#include <QSharedPointer>

#if defined(QTLOGGER_ANDROIDLOG)

// androidlogsink.h

#ifdef QTLOGGER_ANDROIDLOG

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT AndroidLogSink : public Sink
{
public:
    void send(const LogMessage &lmsg) override;
};

using AndroidLogSinkPtr = QSharedPointer<AndroidLogSink>;

} // namespace QtLogger

#endif // QTLOGGER_ANDROIDLOG

// end androidlogsink.h

#elif defined(QTLOGGER_OSLOG)

// oslogsink.h

#ifdef QTLOGGER_OSLOG

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT OslogSink : public Sink
{
public:
    void send(const LogMessage &lmsg);
};

using OslogSinkPtr = QSharedPointer<OslogSink>;

} // namespace QtLogger

#endif // QTLOGGER_OSLOG

// end oslogsink.h

#else

// stderrsink.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT StdErrSink : public Sink
{
public:
    void send(const LogMessage &lmsg) override;
    virtual bool flush() override;
};

using StdErrSinkPtr = QSharedPointer<StdErrSink>;

} // namespace QtLogger

// end stderrsink.h

#endif

namespace QtLogger {

#if defined(QTLOGGER_ANDROIDLOG)
using PlatformStdSink = AndroidLogSink;
#elif defined(QTLOGGER_OSLOG)
using PlatformStdSink = OslogSink;
#else
using PlatformStdSink = StdErrSink;
#endif

using PlatformStdSinkPtr = QSharedPointer<PlatformStdSink>;

}

// end platformstdsink.h

// rotatingfilesink.h

#include <QSharedPointer>

namespace QtLogger {

constexpr int RotatingFileDefaultMaxFileSize = 1024 * 1024;
constexpr int RotatingFileDefaultMaxFileCount = 3;
constexpr int RotatingFileCountLimit = 1024;

class QTLOGGER_EXPORT RotatingFileSink : public FileSink
{
public:
    explicit RotatingFileSink(const QString &path, int maxFileSize = RotatingFileDefaultMaxFileSize,
                              int maxFileCount = RotatingFileDefaultMaxFileCount);

    void send(const LogMessage &lmsg) override;

private:
    void rotate();

private:
    int m_maxFileSize = RotatingFileDefaultMaxFileSize;
    int m_maxFileCount = RotatingFileDefaultMaxFileCount;
};

using RotatingFileSinkPtr = QSharedPointer<RotatingFileSink>;

} // namespace QtLogger

// end rotatingfilesink.h

// signalsink.h

#include <QObject>

namespace QtLogger {

class QTLOGGER_EXPORT SignalSink : public QObject, Sink
{
    Q_OBJECT

public:
    explicit SignalSink(QObject *parent = nullptr);

    void send(const LogMessage &lmsg) override;

Q_SIGNALS:
    void message(const QtLogger::LogMessage &lmsg);
};

using SignalSinkPtr = QSharedPointer<SignalSink>;

} // namespace QtLogger

// end signalsink.h

// stdoutsink.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT StdOutSink : public Sink
{
public:
    void send(const LogMessage &lmsg) override;
    virtual bool flush() override;
};

using StdOutSinkPtr = QSharedPointer<StdOutSink>;

} // namespace QtLogger

// end stdoutsink.h

// utils.h

#include <qlogging.h>

namespace QtLogger {

/** Set global filter rules
 *
 *  Format:  "[<category>|*].[debug|info|warning|critical]=true|false;..."
 *  Example: "app.*.debug=false;app.logger.debug=true"
 */

QTLOGGER_EXPORT void setFilterRules(const QString &rules);

/** Set global message pattern
 *
 * Following placeholders are supported:
 * %{appname} %{category} %{file} %{function} %{line} %{message} %{pid} %{threadid}
 * %{qthreadptr} %{type} %{time process} %{time boot} %{time [format]} %{backtrace [depth=N]
 * [separator="..."]}
 */

QTLOGGER_EXPORT QString setMessagePattern(const QString &messagePattern);

QTLOGGER_EXPORT QString restorePreviousMessagePattern();

} // namespace QtLogger

// end utils.h

// version.h

#define QTLOGGER_VERSION 0.6.0

// end version.h

#ifdef QTLOGGER_NETWORK

// hostinfoattrs.h

#ifdef QTLOGGER_NETWORK

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT HostInfoAttrs : public AttrHandler
{
public:
    HostInfoAttrs();

    QVariantHash attributes(const LogMessage &lmsg) override;

private:
    QVariantHash m_attrs;
};

using HostInfoAttrsPtr = QSharedPointer<HostInfoAttrs>;

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// end hostinfoattrs.h

// httpsink.h

#ifdef QTLOGGER_NETWORK

#include <QNetworkRequest>
#include <QSharedPointer>
#include <QPointer>
#include <QUrl>

QT_FORWARD_DECLARE_CLASS(QNetworkAccessManager)

namespace QtLogger {

class QTLOGGER_EXPORT HttpSink : public Sink
{
public:
    explicit HttpSink(const QUrl &url);
    ~HttpSink();

    void send(const LogMessage &lmsg) override;

    void setNetworkAccessManager(QNetworkAccessManager *manager);
    void setRequest(const QNetworkRequest &request);

private:
    QUrl m_url;
    QPointer<QNetworkAccessManager> m_manager;
    QNetworkRequest m_request;
};

using HttpSinkPtr = QSharedPointer<HttpSink>;

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// end httpsink.h

#endif

#ifdef Q_OS_WIN

// windebugsink.h

#ifdef Q_OS_WIN

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT WinDebugSink : public Sink
{
public:
    void send(const LogMessage &lmsg) override;
};

using WinDebugSinkPtr = QSharedPointer<WinDebugSink>;

} // namespace QtLogger

#endif

// end windebugsink.h

#endif

#ifdef QTLOGGER_IOSLOG

#endif

#ifdef QTLOGGER_ANDROIDLOG

#endif

#ifdef QTLOGGER_SYSLOG

// syslogsink.h

#ifdef QTLOGGER_SYSLOG

#include <QSharedPointer>

// Syslog options
// See syslog.h for more information
#define QTLOGGER_SYSLOG_LOG_PID  0x01
#define QTLOGGER_SYSLOG_LOG_USER (1 << 3)

namespace QtLogger {

class QTLOGGER_EXPORT SyslogSink : public Sink
{
public:
    explicit SyslogSink(const QString &ident, int option = QTLOGGER_SYSLOG_LOG_PID,
                        int facility = QTLOGGER_SYSLOG_LOG_USER);
    ~SyslogSink();

    void send(const LogMessage &lmsg) override;
};

using SyslogSinkPtr = QSharedPointer<SyslogSink>;

} // namespace QtLogger

#endif // QTLOGGER_SYSLOG

// end syslogsink.h

#endif

#ifdef QTLOGGER_SDJOURNAL

// sdjournalsink.h

#ifdef QTLOGGER_SDJOURNAL

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT SdJournalSink : public Sink
{
public:
    void send(const LogMessage &lmsg) override;
};

using SdJournalSinkPtr = QSharedPointer<SdJournalSink>;

} // namespace QtLogger

#endif // QTLOGGER_SDJOURNAL

// end sdjournalsink.h

#endif

// appinfoattrs.cpp

#include <QCoreApplication>

namespace QtLogger {

QTLOGGER_DECL_SPEC
AppInfoAttrs::AppInfoAttrs()
{
    m_attrs = QVariantHash {
        { QStringLiteral("appname"), QCoreApplication::applicationName() },
        { QStringLiteral("appversion"), QCoreApplication::applicationVersion() },
        { QStringLiteral("appdir"), QCoreApplication::applicationDirPath() },
        { QStringLiteral("apppath"), QCoreApplication::applicationFilePath() },
        { QStringLiteral("pid"), QCoreApplication::applicationPid() },
    };
}

QTLOGGER_DECL_SPEC
QVariantHash AppInfoAttrs::attributes(const LogMessage &lmsg)
{
    Q_UNUSED(lmsg)
    return m_attrs;
}

} // namespace QtLogger

// hostinfoattrs.cpp

#ifdef QTLOGGER_NETWORK

#    include <QHostInfo>

namespace QtLogger {

QTLOGGER_DECL_SPEC
HostInfoAttrs::HostInfoAttrs()
{
    m_attrs = QVariantHash {
        { QStringLiteral("host_name"), QHostInfo::localHostName() },
    };
}

QTLOGGER_DECL_SPEC
QVariantHash HostInfoAttrs::attributes(const LogMessage &lmsg)
{
    Q_UNUSED(lmsg)
    return m_attrs;
}

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// seqnumberattr.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
SeqNumberAttr::SeqNumberAttr(const QString &name) : m_name(name) { }

QTLOGGER_DECL_SPEC
QVariantHash SeqNumberAttr::attributes(const LogMessage &lmsg)
{
    Q_UNUSED(lmsg)
    return { { m_name, m_count++ } };
}

} // namespace QtLogger

// configure.cpp

#include <QFileInfo>
#include <QLoggingCategory>
#include <QUrl>
#include <QtCore/QtGlobal>

#ifdef QTLOGGER_NETWORK

#endif

#ifdef QTLOGGER_SYSLOG

#endif

#ifdef QTLOGGER_SDJOURNAL

#endif

#ifdef QTLOGGER_OSLOG

#endif

#ifdef QTLOGGER_ANDROIDLOG

#endif

#ifndef QTLOGGER_NO_THREAD

#endif

namespace QtLogger {

QTLOGGER_DECL_SPEC
void configure(Pipeline *pipeline, const SinkTypeFlags &types, const QString &path,
                       int maxFileSize, int maxFileCount, bool async)
{
    if (!pipeline) {
        return;
    }

    *pipeline << PrettyFormatter::instance();

    if (types.testFlag(SinkType::StdOut)) {
        *pipeline << StdOutSinkPtr::create();
    }

    if (types.testFlag(SinkType::StdErr)) {
        *pipeline << StdErrSinkPtr::create();
    }

    if (types.testFlag(SinkType::PlatformStdLog)) {
        *pipeline << PlatformStdSinkPtr::create();
    }

#ifdef QTLOGGER_SYSLOG
    if (types.testFlag(SinkType::Syslog)) {
        *pipeline << SyslogSinkPtr::create(QFileInfo(path).baseName());
    }
#endif

#ifdef QTLOGGER_SDJOURNAL
    if (types.testFlag(SinkType::SdJournal)) {
        *pipeline << SdJournalSinkPtr::create();
    }
#endif

    if (!path.isEmpty()) {
        if (maxFileSize == 0) {
            *pipeline << FileSinkPtr::create(path);
        } else {
            *pipeline << RotatingFileSinkPtr::create(path, maxFileSize, maxFileCount);
        }
    }

#ifndef QTLOGGER_NO_THREAD
    if (async) {
        auto *ownThreadLogger = dynamic_cast<OwnThreadHandler<SimplePipeline> *>(pipeline);
        if (ownThreadLogger) {
            ownThreadLogger->moveToOwnThread();
        }
    }
#else
    Q_UNUSED(async)
#endif
}

QTLOGGER_DECL_SPEC
void configure(Pipeline *pipeline, int types, const QString &path, int maxFileSize,
                       int maxFileCount, bool async)
{
    configure(pipeline, SinkTypeFlags(QFlag(types)), path, maxFileSize, maxFileCount,
                      async);
}

QTLOGGER_DECL_SPEC
void configure(Pipeline *pipeline, const QSettings &settings, const QString &group)
{
    if (!pipeline) {
        return;
    }

    *pipeline << PrettyFormatter::instance();

    const auto filterRules = settings.value(group + QStringLiteral("/filter_rules")).toString();
    if (!filterRules.isEmpty()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: filterRules: " << filterRules.toStdString() << std::endl;
#endif
        QtLogger::setFilterRules(filterRules);
    }

    const auto regExpFilter = settings.value(group + QStringLiteral("/regexp_filter")).toString();
    if (!regExpFilter.isEmpty()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: filter: " << regExpFilter.toStdString() << std::endl;
#endif
        *pipeline << RegExpFilterPtr::create(regExpFilter);
    }

    const auto messagePattern =
            settings.value(group + QStringLiteral("/message_pattern")).toString();
    if (!messagePattern.isEmpty()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: messagePattern: " << messagePattern.toStdString()
                  << std::endl;
#endif
        *pipeline << PatternFormatterPtr::create(messagePattern);
    }

    if (settings.value(group + QStringLiteral("/stdout"), false).toBool()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: stdout" << std::endl;
#endif
        *pipeline << StdOutSinkPtr::create();
    }

    if (settings.value(group + QStringLiteral("/stderr"), false).toBool()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: stderr" << std::endl;
#endif
        *pipeline << StdErrSinkPtr::create();
    }

    if (settings.value(group + QStringLiteral("/platform_std_log"), true).toBool()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: platform_std_log" << std::endl;
#endif
        *pipeline << PlatformStdSinkPtr::create();
    }

#ifdef QTLOGGER_SYSLOG
    const auto syslogIdent = settings.value(group + QStringLiteral("/syslog_ident")).toString();
    if (!syslogIdent.isEmpty()) {
#    ifdef QTLOGGER_DEBUG
        std::cerr << "configure: syslogIdent: " << syslogIdent.toStdString() << std::endl;
#    endif
        *pipeline << SyslogSinkPtr::create(syslogIdent);
    }
#endif

#ifdef QTLOGGER_SDJOURNAL
    if (settings.value(group + QStringLiteral("/sdjournal"), false).toBool()) {
#    ifdef QTLOGGER_DEBUG
        std::cerr << "configure: sd-journal" << std::endl;
#    endif
        *pipeline << SdJournalSinkPtr::create();
    }
#endif

    const auto path = settings.value(group + QStringLiteral("/path")).toString();
    if (!path.isEmpty()) {
        const auto maxFileSize = settings.value(group + QStringLiteral("/max_file_size"),
                                                RotatingFileDefaultMaxFileSize)
                                         .toInt();

        const auto maxFileCount = settings.value(group + QStringLiteral("/max_file_count"),
                                                 RotatingFileDefaultMaxFileCount)
                                          .toInt();

#ifdef QTLOGGER_DEBUG
        std::cerr << "configure: path: " << path.toStdString()
                  << " maxFileSize: " << maxFileSize << " maxFileCount: " << maxFileCount
                  << std::endl;
#endif

        *pipeline << RotatingFileSinkPtr::create(path, maxFileSize, maxFileCount);
    }

#ifdef QTLOGGER_NETWORK
    const auto httpUrl = settings.value(group + QStringLiteral("/http_url")).toString();
    if (!httpUrl.isEmpty()) {
        const auto httpMsgFormat = settings.value(group + QStringLiteral("/http_msg_format"),
                                                  QStringLiteral("default"))
                                           .toString();
        // TODO: add support for http_msg_format (json)
        *pipeline << HttpSinkPtr::create(QUrl(httpUrl));
    }
#endif

#ifndef QTLOGGER_NO_THREAD
    if (settings.value(group + QStringLiteral("/async"), false).toBool()) {
#    ifdef QTLOGGER_DEBUG
        std::cerr << "configureLogger: async" << std::endl;
#    endif
        auto *ownThreadLogger = dynamic_cast<OwnThreadHandler<SimplePipeline> *>(pipeline);
        if (ownThreadLogger) {
            ownThreadLogger->moveToOwnThread();
        }
    }
#endif
}

QTLOGGER_DECL_SPEC
void configure(Pipeline *pipeline, const QString &path, const QString &group)
{
    configure(pipeline, QSettings(path, QSettings::IniFormat), group);
}

} // namespace QtLogger

// categoryfilter.cpp

#include <QRegularExpression>
#include <qlogging.h>

namespace QtLogger {

struct CategoryFilter::Rule
{
    QRegularExpression category;
    QtMsgType type;
    bool typeMatch;
    bool enabled;

    bool matches(const QString &category, QtMsgType messageType) const;
};

QTLOGGER_DECL_SPEC
CategoryFilter::CategoryFilter(const QString &a_rules)
{
    auto rules = a_rules;
    rules.replace(";", "\n");
    parseRules(rules);
}

QTLOGGER_DECL_SPEC
void CategoryFilter::parseRules(const QString &rules)
{
#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
    const auto lines = rules.split('\n', Qt::SkipEmptyParts);
#else
    const auto lines = rules.split('\n', QString::SkipEmptyParts);
#endif
    for (const auto &line : lines) {
        const auto ruleRegex = QRegularExpression(
                R"(^\s*(\S+?)(?:\.(debug|info|warning|critical))?\s*=\s*(true|false)\s*$)");

        const auto match = ruleRegex.match(line);

        if (!match.hasMatch())
            continue;

        auto rule = QSharedPointer<Rule>::create();

        auto category = match.captured(1);
        category = QRegularExpression::escape(category);
        category.replace("\\*", ".*");

        rule->category = QRegularExpression("^" + category + "$");
        rule->type = stringToQtMsgType(match.captured(2));
        rule->typeMatch = !match.captured(2).isEmpty();
        rule->enabled = match.captured(3) == "true";

        m_rules.append(rule);
    }
}

QTLOGGER_DECL_SPEC
bool CategoryFilter::Rule::matches(const QString &category, QtMsgType messageType) const
{
    return this->category.match(category).hasMatch() && (!typeMatch || type == messageType);
}

QTLOGGER_DECL_SPEC
bool CategoryFilter::filter(const LogMessage &lmsg)
{
    bool enabled = true;
    for (const auto &rule : std::as_const(m_rules)) {
        if (rule->matches(lmsg.category(), lmsg.type())) {
            enabled = rule->enabled;
        }
    }
    return enabled;
}

} // namespace QtLogger

// duplicatefilter.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
bool DuplicateFilter::filter(const LogMessage &lmsg)
{
    if (lmsg.message() == m_lastMessage) {
        return false;
    }

    m_lastMessage = lmsg.message();

    return true;
}

} // namespace QtLogger

// regexpfilter.cpp

#include <QRegularExpression>

namespace QtLogger {

QTLOGGER_DECL_SPEC
RegExpFilter::RegExpFilter(const QRegularExpression &regExp) : m_regExp(regExp) { }

QTLOGGER_DECL_SPEC
QtLogger::RegExpFilter::RegExpFilter(const QString &regExp) : m_regExp(QRegularExpression(regExp))
{
}

QTLOGGER_DECL_SPEC
bool RegExpFilter::filter(const LogMessage &lmsg)
{
    return m_regExp.match(lmsg.message()).hasMatch();
}

} // namespace QtLogger

// jsonformatter.cpp

#include <QCoreApplication>
#include <QJsonDocument>
#include <QJsonObject>

namespace QtLogger {

QTLOGGER_DECL_SPEC
QString JsonFormatter::format(const LogMessage &lmsg)
{
    QJsonObject obj;

    obj[QStringLiteral("message")] = lmsg.message();

    const auto attrs = lmsg.allAttributes();
    for (auto it = attrs.cbegin(); it != attrs.cend(); ++it) {
        obj.insert(it.key(), QJsonValue::fromVariant(it.value()));
    }

    return QString::fromUtf8(QJsonDocument(obj).toJson());
}

} // namespace QtLogger

// patternformatter.cpp

#include <optional>

#include <QSharedPointer>

namespace QtLogger {

namespace {

static const auto g_processStartTime = std::chrono::steady_clock::now();

static const QChar DEL_MARKER = QChar(0x200B);

class Token
{
public:
    virtual ~Token() = default;
    virtual size_t estimatedLength() const = 0;
    virtual bool checkCondition(const LogMessage &) const { return true; }
    virtual void appendToString(const LogMessage &lmsg, QString &dest) const = 0;
};

class ConditionToken : public Token
{
public:
    bool checkCondition(const LogMessage &lmsg) const override
    {
        if (!m_hasCondition) {
            return true;
        }
        return lmsg.type() == m_condition;
    }

    QtMsgType condition() const { return m_condition; }

    void setCondition(QtMsgType condition)
    {
        m_condition = condition;
        m_hasCondition = true;
    }

private:
    QtMsgType m_condition = QtDebugMsg;
    bool m_hasCondition = false;
};

class FormattedToken : public ConditionToken
{
public:
    enum class Alignment { None, Left, Right, Center };
    enum class TruncateMode { None, Truncate, TruncateOnly };

    struct FormatSpec
    {
        QChar fill = QLatin1Char(' ');
        Alignment align = Alignment::None;
        int width = 0;
        TruncateMode truncateMode = TruncateMode::None;
    };

    void setFormatSpec(const FormatSpec &spec) { m_spec = spec; }

    static std::optional<FormatSpec> parseFormatSpec(const QString &specString)
    {
        if (specString.isEmpty())
            return std::nullopt;

        QString s = specString;
        int pos = 0;
        FormatSpec spec;
        bool hasExplicitFill = false;
        bool hasTruncateSuffix = false;

        if (s.endsWith(QLatin1Char('!'))) {
            hasTruncateSuffix = true;
            s.chop(1);
            if (s.isEmpty())
                return std::nullopt;
        }

        // Check if we have fill + align (fill is any char, align is <, >, ^)
        if (s.length() >= 2) {
            QChar possibleAlign = s.at(1);
            if (QStringLiteral("<^>").contains(possibleAlign)) {
                spec.fill = s.at(0);
                spec.align = charToAlignment(possibleAlign);
                hasExplicitFill = true;
                pos = 2;
            }
        }

        // If no fill+align found, check for just align
        if (spec.align == Alignment::None && !s.isEmpty()) {
            QChar possibleAlign = s.at(0);
            if (QStringLiteral("<^>").contains(possibleAlign)) {
                spec.align = charToAlignment(possibleAlign);
                pos = 1;
            }
        }

        // If no align found, check if it's just a number (only valid with !)
        if (spec.align == Alignment::None && hasTruncateSuffix) {
            // Try to parse entire remaining string as width
            bool ok;
            spec.width = s.toInt(&ok);
            if (ok && spec.width > 0) {
                spec.truncateMode = TruncateMode::TruncateOnly;
                return spec;
            }
            return std::nullopt;
        }

        // If no align found at all (and not truncate-only), this is not a valid format spec
        if (spec.align == Alignment::None)
            return std::nullopt;

        // Parse width (remaining characters should be digits)
        if (pos >= s.length())
            return std::nullopt;

        QString widthStr = s.mid(pos);
        bool ok;
        spec.width = widthStr.toInt(&ok);
        if (!ok || spec.width <= 0)
            return std::nullopt;

        // Determine truncate mode
        if (hasTruncateSuffix) {
            spec.truncateMode = hasExplicitFill ? TruncateMode::Truncate : TruncateMode::TruncateOnly;
        }

        return spec;
    }

    bool hasFormatSpec() const
    {
        return m_spec.width > 0
               && (m_spec.align != Alignment::None
                   || m_spec.truncateMode == TruncateMode::TruncateOnly);
    }

    static Alignment charToAlignment(QChar ch)
    {
        switch (ch.unicode()) {
        case '<':
            return Alignment::Left;
        case '>':
            return Alignment::Right;
        case '^':
            return Alignment::Center;
        default:
            return Alignment::None;
        }
    }

    int formatWidth() const { return m_spec.width; }

protected:
    QString applyPadding(const QString &value) const
    {
        if (m_spec.width <= 0) {
            return value;
        }

        if (m_spec.truncateMode == TruncateMode::TruncateOnly) {
            if (value.length() <= m_spec.width) {
                return value;
            }
            if (m_spec.align == Alignment::Right) {
                return value.right(m_spec.width);
            } else {
                return value.left(m_spec.width);
            }
        }

        if (m_spec.align == Alignment::None) {
            return value;
        }

        QString val = value;

        if (m_spec.truncateMode == TruncateMode::Truncate
            && val.length() > m_spec.width) {
            if (m_spec.align == Alignment::Right) {
                val = val.right(m_spec.width);
            } else {
                val = val.left(m_spec.width);
            }
        }

        if (val.length() >= m_spec.width) {
            return val;
        }

        int padding = m_spec.width - val.length();
        QString result;
        result.reserve(m_spec.width);

        switch (m_spec.align) {
        case Alignment::Left:
            result.append(val);
            result.append(QString(padding, m_spec.fill));
            break;
        case Alignment::Right:
            result.append(QString(padding, m_spec.fill));
            result.append(val);
            break;
        case Alignment::Center: {
            int leftPad = padding / 2;
            int rightPad = padding - leftPad;
            result.append(QString(leftPad, m_spec.fill));
            result.append(val);
            result.append(QString(rightPad, m_spec.fill));
            break;
        }
        case Alignment::None:
            return val;
        }

        return result;
    }

private:
    FormatSpec m_spec;
};

class LiteralToken : public FormattedToken
{
public:
    explicit LiteralToken(const QString &text) : m_text(text) { }

    void appendToString(const LogMessage &, QString &dest) const override
    {
        int removeCount = 0;
        while (!dest.isEmpty() && dest.at(dest.size() - 1) == DEL_MARKER) {
            dest.chop(1);
            removeCount++;
        }

        if (removeCount > 0 && removeCount < m_text.size()) {
            dest.append(m_text.mid(removeCount));
        } else if (removeCount == 0) {
            dest.append(m_text);
        }

        // If removeCount >= m_text.size(), append nothing
    }

    size_t estimatedLength() const override { return m_text.size(); }

private:
    QString m_text;
};

class MessageToken : public FormattedToken
{
public:
    MessageToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        dest.append(applyPadding(lmsg.message()));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 50; // Estimated average message length
    }
};

class TypeToken : public FormattedToken
{
public:
    TypeToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        dest.append(applyPadding(qtMsgTypeToString(lmsg.type())));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 8; // Maximum length of "critical"
    }
};

class LineToken : public FormattedToken
{
public:
    LineToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        dest.append(applyPadding(QString::number(lmsg.line())));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 5; // Maximum length of "99999"
    }
};

class FileToken : public FormattedToken
{
public:
    FileToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        dest.append(applyPadding(lmsg.file()));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 20; // Maximum length of "path/to/file.cpp"
    }
};

class ShortFileToken : public FormattedToken
{
public:
    ShortFileToken(const QString &baseDir = QString()) : m_baseDir(baseDir) { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        QString file = lmsg.file();
        QString value;
        if (m_baseDir.isEmpty()) {
            // No basedir specified - return only filename without directory
            int lastSlash = file.lastIndexOf(QLatin1Char('/'));
            if (lastSlash == -1) {
                lastSlash = file.lastIndexOf(QLatin1Char('\\'));
            }
            if (lastSlash != -1) {
                value = file.mid(lastSlash + 1);
            } else {
                value = file;
            }
        } else {
            // Strip basedir prefix if present
            if (file.startsWith(m_baseDir)) {
                QString result = file.mid(m_baseDir.length());
                // Remove leading slash if present
                if (result.startsWith(QLatin1Char('/')) || result.startsWith(QLatin1Char('\\'))) {
                    result = result.mid(1);
                }
                value = result;
            } else {
                value = file;
            }
        }
        dest.append(applyPadding(value));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 20;
    }

private:
    QString m_baseDir;
};

class FunctionToken : public FormattedToken
{
public:
    FunctionToken(bool cleanup = true) : m_cleanup(cleanup) { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        QString value;
        if (m_cleanup) {
            value = QString::fromLatin1(cleanup(lmsg.function()));
        } else {
            value = QString::fromLatin1(lmsg.function());
        }
        dest.append(applyPadding(value));
    }

    size_t estimatedLength() const override
    {
        if (hasFormatSpec())
            return formatWidth();
        return m_cleanup ? 20 : 40;
    }

private:
    bool m_cleanup;

    static QByteArray cleanup(QByteArray func)
    {
        if (func.isEmpty())
            return func;

        // Helper lambda: find balanced bracket in reverse
        auto findBalancedReverse = [&func](char open, char close, int startPos) -> int {
            if (startPos <= 0)
                return -1;
            int count = 1;
            int pos = startPos - 1;
            while (pos >= 0 && count > 0) {
                char c = func.at(pos);
                if (c == close)
                    ++count;
                else if (c == open)
                    --count;
                --pos;
            }
            return (count == 0) ? pos + 1 : -1;
        };

        // Remove compiler metadata like [with T = int]
        if (func.endsWith(']') && !func.startsWith('+') && !func.startsWith('-')) {
            int openBracket = findBalancedReverse('[', ']', func.size() - 1);
            if (openBracket != -1)
                func.truncate(openBracket);
        }
        while (func.endsWith(' '))
            func.chop(1);

        // Normalize operator spacing
        func.replace("operator ", "operator");

        // Try to handle function pointer return types: returntype (*name(args))(return_args)
        bool handledFunctionPointer = false;
        int parenOpenIdx = func.indexOf(")(");
        if (parenOpenIdx != -1) {
            int ptrParen = func.indexOf("(*");
            if (ptrParen != -1 && ptrParen < parenOpenIdx) {
                int nameStart = ptrParen + 2;
                int parenDepth = 0;
                int argsParen = -1;
                for (int i = nameStart; i < parenOpenIdx; ++i) {
                    char c = func.at(i);
                    if (c == '(') {
                        if (parenDepth == 0)
                            argsParen = i;
                        ++parenDepth;
                    } else if (c == ')') {
                        --parenDepth;
                    }
                }
                if (argsParen != -1 && argsParen > nameStart) {
                    func = func.mid(nameStart, argsParen - nameStart);
                    handledFunctionPointer = true;
                }
            }
        }

        if (!handledFunctionPointer) {
            // Remove function arguments
            int end = func.lastIndexOf(')');
            if (end != -1) {
                int openParen = findBalancedReverse('(', ')', end);
                if (openParen != -1) {
                    bool isOperatorCall = false;
                    if (openParen >= 8 && func.mid(openParen - 8, 8) == "operator") {
                        // Check that 'operator' is not part of a longer identifier
                        if (openParen == 8) {
                            isOperatorCall = true;
                        } else {
                            char prevChar = func.at(openParen - 9);
                            if (!QChar::isLetterOrNumber(prevChar) && prevChar != '_') {
                                isOperatorCall = true;
                            }
                        }
                    }
                    if (!isOperatorCall)
                        func.truncate(openParen);
                }
            }

            // Remove trailing qualifiers
            static const char *const qualifiers[] = { " const", " volatile", " noexcept",
                                                      " override", " final" };
            bool found;
            do {
                found = false;
                for (const char *qual : qualifiers) {
                    if (func.endsWith(qual)) {
                        func.chop(static_cast<int>(qstrlen(qual)));
                        found = true;
                        break;
                    }
                }
            } while (found);

            // Extract function name (remove return type)
            int operatorPos = func.lastIndexOf("operator");
            if (operatorPos != -1) {
                int scanPos = operatorPos - 1;
                while (scanPos >= 0 && func.at(scanPos) == ' ')
                    --scanPos;

                bool extracted = false;
                while (scanPos >= 0) {
                    if (scanPos >= 1 && func.at(scanPos) == ':' && func.at(scanPos - 1) == ':') {
                        scanPos -= 2;
                        while (scanPos >= 0 && func.at(scanPos) == ' ')
                            --scanPos;
                        if (scanPos >= 0 && func.at(scanPos) == ')') {
                            int op = findBalancedReverse('(', ')', scanPos + 1);
                            if (op != -1) {
                                scanPos = op - 1;
                                continue;
                            }
                        }
                        if (scanPos >= 0 && func.at(scanPos) == '>') {
                            int oa = findBalancedReverse('<', '>', scanPos + 1);
                            if (oa != -1) {
                                scanPos = oa - 1;
                                continue;
                            }
                        }
                        while (scanPos >= 0
                               && (QChar(func.at(scanPos)).isLetterOrNumber()
                                   || func.at(scanPos) == '_'))
                            --scanPos;
                    } else if (func.at(scanPos) == ' ') {
                        func = func.mid(scanPos + 1);
                        extracted = true;
                        break;
                    } else {
                        break;
                    }
                }
                if (!extracted) {
                    int firstSpace = func.indexOf(' ');
                    if (firstSpace != -1 && firstSpace < operatorPos)
                        func = func.mid(firstSpace + 1);
                }
            } else {
                int pos = func.size() - 1;
                int parenCount = 0, angleCount = 0;
                while (pos >= 0) {
                    char c = func.at(pos);
                    if (c == ')') {
                        ++parenCount;
                        --pos;
                        continue;
                    }
                    if (c == '(' && parenCount > 0) {
                        --parenCount;
                        --pos;
                        continue;
                    }
                    if (c == '>') {
                        ++angleCount;
                        --pos;
                        continue;
                    }
                    if (c == '<' && angleCount > 0) {
                        --angleCount;
                        --pos;
                        continue;
                    }
                    if (parenCount > 0 || angleCount > 0) {
                        --pos;
                        continue;
                    }
                    if (c == ' ') {
                        func = func.mid(pos + 1);
                        break;
                    }
                    --pos;
                }
            }
            while (func.startsWith('*') || func.startsWith('&') || func.startsWith(' '))
                func = func.mid(1);
        }

        // Remove empty parentheses before :: (e.g., method():: -> method::)
        int pos = 0;
        while ((pos = func.indexOf("()::", pos)) != -1) {
            if (pos >= 8 && func.mid(pos - 8, 8) == "operator") {
                pos += 4;
                continue;
            }
            int angleDepth = 0;
            bool insideTemplate = false;
            for (int i = pos - 1; i >= 0; --i) {
                if (func.at(i) == '>')
                    ++angleDepth;
                else if (func.at(i) == '<') {
                    if (angleDepth == 0) {
                        insideTemplate = true;
                        break;
                    }
                    --angleDepth;
                }
            }
            if (insideTemplate) {
                pos += 4;
                continue;
            }
            func.remove(pos, 2);
        }

        // Remove template parameters
        while (true) {
            int closeAngle = func.lastIndexOf('>');
            if (closeAngle == -1)
                break;
            int opCheck = func.lastIndexOf("operator", closeAngle);
            if (opCheck != -1) {
                int operatorEnd = opCheck + 8;
                if (operatorEnd <= closeAngle) {
                    bool isOperatorSymbol = true;
                    static const QByteArray operatorChars("=!+-*/%^&|~<>");
                    for (int i = operatorEnd; i <= closeAngle; ++i) {
                        char ch = func.at(i);
                        if (!operatorChars.contains(ch)) {
                            isOperatorSymbol = false;
                            break;
                        }
                    }
                    if (isOperatorSymbol)
                        break;
                }
            }
            int openAngle = findBalancedReverse('<', '>', closeAngle);
            if (openAngle == -1)
                break;
            if (openAngle >= 8 && func.mid(openAngle - 8, 8) == "operator")
                break;
            if (func.mid(openAngle + 1, closeAngle - openAngle - 1).startsWith("lambda"))
                break;
            func.remove(openAngle, closeAngle - openAngle + 1);
        }

        return func;
    }
};

class CategoryToken : public FormattedToken
{
public:
    CategoryToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        dest.append(applyPadding(lmsg.category()));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 20; // Maximum length of "categoryName"
    }
};

class TimeToken : public FormattedToken
{
public:
    explicit TimeToken(const QString &format = QString()) : m_format(format) { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        QString value;
        if (m_format == QLatin1String("process")) {
            // Time since process started in seconds
            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
                    lmsg.steadyTime() - g_processStartTime);
            double seconds = duration.count() / 1000.0;
            value = QString::number(seconds, 'f', 3);
        } else if (m_format == QLatin1String("boot")) {
            // Time since system boot in seconds using steady_clock epoch
            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
                    lmsg.steadyTime().time_since_epoch());
            double seconds = duration.count() / 1000.0;
            value = QString::number(seconds, 'f', 3);
        } else if (m_format.isEmpty()) {
            value = lmsg.time().toString(Qt::ISODate);
        } else {
            value = lmsg.time().toString(m_format);
        }
        dest.append(applyPadding(value));
    }

    size_t estimatedLength() const override
    {
        if (hasFormatSpec())
            return formatWidth();
        if (m_format == QLatin1String("process") || m_format == QLatin1String("boot")) {
            return 15; // Enough for "123456789.123"
        }
        return m_format.isEmpty() ? 20 : m_format.length() * 2; // Estimated length based on format
    }

private:
    QString m_format;
};

class ThreadIdToken : public FormattedToken
{
public:
    ThreadIdToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        dest.append(applyPadding(QString::number(lmsg.threadId())));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 10; // Maximum length of "9999999999"
    }
};

class QThreadPtrToken : public FormattedToken
{
public:
    QThreadPtrToken() { }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        QString value = QStringLiteral("0x") + QString::number(lmsg.qthreadptr(), 16);
        dest.append(applyPadding(value));
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 18; // "0x" + 16 hex digits for 64-bit pointer
    }
};

class AttributeToken : public FormattedToken
{
public:
    explicit AttributeToken(const QString &attributeName, bool optional = false,
                            int removeBefore = 0, int removeAfter = 0)
        : m_attributeName(attributeName)
        , m_optional(optional)
        , m_removeBefore(removeBefore)
        , m_removeAfter(removeAfter)
    {
    }

    void appendToString(const LogMessage &lmsg, QString &dest) const override
    {
        if (lmsg.hasAttribute(m_attributeName)) {
            dest.append(applyPadding(lmsg.attribute(m_attributeName).toString()));
            return;
        }

        if (!m_optional) {
            QString value = QStringLiteral("%{") + m_attributeName + QStringLiteral("}");
            dest.append(applyPadding(value));
            return;
        }

        // Optional attribute not found: remove characters before and add ZWSP markers for removeAfter
        if (m_removeBefore > 0 && dest.size() >= m_removeBefore) {
            dest.chop(m_removeBefore);
        }
        // Append ZWSP markers to signal how many chars to remove from next token
        for (int i = 0; i < m_removeAfter; ++i) {
            dest.append(DEL_MARKER);
        }
    }

    size_t estimatedLength() const override
    {
        return hasFormatSpec() ? formatWidth() : 20; // Estimated average attribute value length
    }

private:
    QString m_attributeName;
    bool m_optional;
    int m_removeBefore;
    int m_removeAfter;
};

} // namespace

class PatternFormatter::PatternFormatterPrivate
{
public:
    explicit PatternFormatterPrivate(const QString &pattern) : m_pattern(pattern)
    {
        parsePattern();
    }

    void parsePattern()
    {
        m_tokens.clear();

        int pos = 0;
        QString literalText;
        QtMsgType currentCondition = QtDebugMsg;
        bool hasCondition = false;

        while (pos < m_pattern.length()) {
            if (pos < m_pattern.length() - 1 && m_pattern[pos] == '%') {
                if (m_pattern[pos + 1] == '{') {
                    if (!literalText.isEmpty()) {
                        auto token = new LiteralToken(literalText);
                        if (hasCondition) {
                            token->setCondition(currentCondition);
                        }
                        m_tokens.append(QSharedPointer<Token>(token));
                        literalText.clear();
                    }

                    int closingPos = m_pattern.indexOf('}', pos + 2);
                    if (closingPos == -1) {
                        // No closing brace, treat as literal
                        literalText.append('%');
                        pos++;
                        continue;
                    }

                    QString placeholder = m_pattern.mid(pos + 2, closingPos - pos - 2);

                    std::optional<FormattedToken::FormatSpec> formatSpec;

                    int lastColon = placeholder.lastIndexOf(QLatin1Char(':'));
                    if (lastColon != -1 && lastColon < placeholder.length() - 1) {
                        QString possibleSpec = placeholder.mid(lastColon + 1);
                        formatSpec = FormattedToken::parseFormatSpec(possibleSpec);
                        if (formatSpec) {
                            placeholder = placeholder.left(lastColon);
                        }
                    }

                    FormattedToken *token = nullptr;

                    if (placeholder == QLatin1String("type")) {
                        token = new TypeToken();
                    } else if (placeholder == QLatin1String("line")) {
                        token = new LineToken();
                    } else if (placeholder == QLatin1String("file")) {
                        token = new FileToken();
                    } else if (placeholder == QLatin1String("shortfile")
                               || placeholder.startsWith(QLatin1String("shortfile "))) {
                        QString baseDir;
                        if (placeholder.startsWith(QLatin1String("shortfile "))) {
                            baseDir = placeholder.mid(10).trimmed();
                        }
                        token = new ShortFileToken(baseDir);
                    } else if (placeholder == QLatin1String("function")) {
                        token = new FunctionToken(false);
                    } else if (placeholder == QLatin1String("func")) {
                        token = new FunctionToken(true);
                    } else if (placeholder == QLatin1String("category")) {
                        token = new CategoryToken();
                    } else if (placeholder == QLatin1String("time")
                               || placeholder.startsWith(QLatin1String("time "))) {
                        QString timeFormat;
                        if (placeholder.startsWith(QLatin1String("time "))) {
                            timeFormat = placeholder.mid(5).trimmed();
                        }
                        token = new TimeToken(timeFormat);
                    } else if (placeholder == QLatin1String("threadid")) {
                        token = new ThreadIdToken();
                    } else if (placeholder == QLatin1String("qthreadptr")) {
                        token = new QThreadPtrToken();
                    } else if (placeholder == QLatin1String("message")) {
                        token = new MessageToken();
                    } else if (placeholder.startsWith(QLatin1String("if-"))) {
                        // Handle conditional: %{if-debug}, %{if-warning}, etc.
                        QString conditionType = placeholder.mid(3); // Remove "if-"
                        currentCondition = stringToQtMsgType(conditionType, QtDebugMsg);
                        hasCondition = true;
                        pos = closingPos + 1;
                        continue;
                    } else if (placeholder == QLatin1String("endif")) {
                        hasCondition = false;
                        pos = closingPos + 1;
                        continue;
                    } else {
                        // Try to handle as custom attribute: %{attr} or %{attr?[N][,M]}
                        int questionPos = placeholder.indexOf(QLatin1Char('?'));
                        if (questionPos != -1) {
                            QString attrName = placeholder.left(questionPos);
                            QString suffix = placeholder.mid(questionPos + 1); // after '?'
                            int removeBefore = 0;
                            int removeAfter = 0;

                            int commaPos = suffix.indexOf(QLatin1Char(','));
                            if (commaPos == -1) {
                                // Only removeBefore: %{attr?N}
                                removeBefore = suffix.toInt();
                            } else {
                                // Both or only removeAfter: %{attr?N,M} or %{attr?,M}
                                if (commaPos > 0) {
                                    removeBefore = suffix.left(commaPos).toInt();
                                }
                                removeAfter = suffix.mid(commaPos + 1).toInt();
                            }
                            token = new AttributeToken(attrName, true, removeBefore, removeAfter);
                        } else {
                            token = new AttributeToken(placeholder);
                        }
                    }

                    if (token) {
                        if (hasCondition) {
                            token->setCondition(currentCondition);
                        }
                        if (formatSpec) {
                            token->setFormatSpec(*formatSpec);
                        }
                        m_tokens.append(QSharedPointer<Token>(token));
                    }

                    pos = closingPos + 1;
                } else if (m_pattern[pos + 1] == '%') {
                    // Escaped %, add single %
                    literalText.append('%');
                    pos += 2;
                } else {
                    // Just a regular %
                    literalText.append('%');
                    pos++;
                }
            } else {
                literalText.append(m_pattern[pos]);
                pos++;
            }
        }

        if (!literalText.isEmpty()) {
            auto token = new LiteralToken(literalText);
            if (hasCondition) {
                token->setCondition(currentCondition);
            }
            m_tokens.append(QSharedPointer<Token>(token));
        }
    }

    QString format(const LogMessage &lmsg)
    {
        if (m_tokens.isEmpty()) {
            return lmsg.message();
        }

        size_t estimatedLength = 0;
        for (const auto &token : std::as_const(m_tokens)) {
            if (token->checkCondition(lmsg)) {
                estimatedLength += token->estimatedLength();
            }
        }

        QString result;
        result.reserve(estimatedLength);

        for (const auto &token : std::as_const(m_tokens)) {
            if (token->checkCondition(lmsg)) {
                token->appendToString(lmsg, result);
            }
        }

        result.remove(DEL_MARKER);

        return result;
    }

    QString m_pattern;
    QList<QSharedPointer<Token>> m_tokens;
};

QTLOGGER_DECL_SPEC
PatternFormatter::PatternFormatter(const QString &pattern) : d(new PatternFormatterPrivate(pattern))
{
}

QTLOGGER_DECL_SPEC
PatternFormatter::~PatternFormatter() = default;

QTLOGGER_DECL_SPEC
QString PatternFormatter::format(const LogMessage &lmsg)
{
    return d->format(lmsg);
}

} // namespace QtLogger

// prettyformatter.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
PrettyFormatter::PrettyFormatter(bool showThread, int maxCategoryWidth)
    : m_showThreadId(showThread), m_maxCategoryWidth(maxCategoryWidth)
{
}

QTLOGGER_DECL_SPEC
QString PrettyFormatter::format(const LogMessage &lmsg)
{
    static const QString msg_f { QStringLiteral("%1 %2 %3%4%5%6") };
    static const QString time_f { QStringLiteral("dd.MM.yyyy hh:mm:ss.zzz") };
    static const QStringList type_l {
        QStringLiteral(" "), QStringLiteral("W"), QStringLiteral("E"),
        QStringLiteral("F"), QStringLiteral("I"), QStringLiteral("S")
    };
    static const QString thread_f { QStringLiteral("#%1 ") };
    static const QString category_f { QStringLiteral("[%1] ") };

    QString thread;
    if (m_showThreadId) {
        if (!m_threads.contains(lmsg.threadId())) {
            m_threads[lmsg.threadId()] = m_threadsIndex++;
        }
        if (m_threads.count() > 1) {
            const auto index = m_threads.value(lmsg.threadId());
            thread = thread_f.arg(index);
            if (index == 0) {
                thread.fill(QChar::fromLatin1(' '));
            }
        }
    }

    QString category;
    if (qstrcmp(lmsg.category(), "default") != 0) {
        category = category_f.arg(QString::fromUtf8(lmsg.category()));
    }

    QString space;
    if (m_maxCategoryWidth > 0) {
        int categoryLength = category.length();
        if (categoryLength > m_categoryWidth && categoryLength <= m_maxCategoryWidth) {
            m_categoryWidth = categoryLength;
        }
        space.fill(QChar::fromLatin1(' '), qMax(m_categoryWidth - categoryLength, 0));
    }

    auto result = msg_f.arg(lmsg.time().toString(time_f), type_l.at(lmsg.type()), thread,
                            category, space, lmsg.message());

    return result;
}

} // namespace QtLogger

// logger.cpp

#include <QFileInfo>
#include <QLoggingCategory>
#include <QScopedPointer>

#ifndef QTLOGGER_NO_THREAD
#    include <QAtomicPointer>
#    include <QMutexLocker>
#endif

namespace QtLogger {

namespace {

#ifndef QTLOGGER_NO_THREAD
QAtomicPointer<Logger> g_activeLogger;
#else
Logger *g_activeLogger = nullptr;
#endif

QtMessageHandler g_previousMessageHandler = nullptr;

}

QTLOGGER_DECL_SPEC
Logger *Logger::instance()
{
    static QScopedPointer<Logger> s_instance;

    if (!s_instance) {
        s_instance.reset(new Logger());
    }

    return s_instance.data();
}

QTLOGGER_DECL_SPEC
Logger::~Logger()
{
#ifndef QTLOGGER_NO_THREAD
    g_activeLogger.testAndSetOrdered(this, nullptr);
#else
    if (g_activeLogger == this) {
        g_activeLogger = nullptr;
    }
#endif
}

QTLOGGER_DECL_SPEC
void Logger::configure(const SinkTypeFlags &types, const QString &path, int maxFileSize,
                       int maxFileCount, bool async)
{
    QtLogger::configure(this, types, path, maxFileSize, maxFileCount, async);

    installMessageHandler();
}

QTLOGGER_DECL_SPEC
void Logger::configure(int types, const QString &path, int maxFileSize, int maxFileCount,
                       bool async)
{
    configure(SinkTypeFlags(QFlag(types)), path, maxFileSize, maxFileCount, async);
}

QTLOGGER_DECL_SPEC
void Logger::configure(const QSettings &settings, const QString &group)
{
    QtLogger::configure(this, settings, group);

    installMessageHandler();
}

QTLOGGER_DECL_SPEC
void Logger::configure(const QString &path, const QString &group)
{
    configure(QSettings(path, QSettings::IniFormat), group);
}

QTLOGGER_DECL_SPEC
Logger &Logger::operator<<(const HandlerPtr &handler)
{
    append(handler);
    return *this;
}

QTLOGGER_DECL_SPEC
void Logger::processMessage(QtMsgType type, const QMessageLogContext &context,
                            const QString &message)
{
#ifndef QTLOGGER_NO_THREAD
    QMutexLocker locker(mutex());
#endif

    LogMessage lmsg(type, context, message);
    process(lmsg);
}

QTLOGGER_DECL_SPEC
void Logger::messageHandler(QtMsgType type, const QMessageLogContext &context,
                            const QString &message)
{
#ifndef QTLOGGER_NO_THREAD
    auto logger = g_activeLogger.loadAcquire();
#else
    auto logger = g_activeLogger;
#endif

    if (!logger)
        return;

    logger->processMessage(type, context, message);
}

QTLOGGER_DECL_SPEC
void Logger::installMessageHandler()
{
#ifndef QTLOGGER_NO_THREAD
    g_activeLogger.storeRelease(this);
#else
    g_activeLogger = this;
#endif

    auto prev = qInstallMessageHandler(messageHandler);

    if (prev != messageHandler) {
        g_previousMessageHandler = prev;
    }
}

QTLOGGER_DECL_SPEC
void Logger::restorePreviousMessageHandler()
{
    if (!g_previousMessageHandler)
        return;

    auto prev = qInstallMessageHandler(g_previousMessageHandler);

    if (prev != messageHandler) {
        qInstallMessageHandler(prev);
    }

    g_previousMessageHandler = nullptr;
}

#ifndef QTLOGGER_NO_THREAD

QTLOGGER_DECL_SPEC
void Logger::lock() const
{
    mutex()->lock();
}

QTLOGGER_DECL_SPEC
void Logger::unlock() const
{
    mutex()->unlock();
}

#endif

} // namespace QtLogger

// pipeline.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
Pipeline::Pipeline(std::initializer_list<HandlerPtr> handlers, bool scoped)
    : m_handlers(handlers), m_scoped(scoped)
{
}

QTLOGGER_DECL_SPEC
void Pipeline::append(const HandlerPtr &handler)
{
    if (handler.isNull())
        return;

    m_handlers.append(handler);
}

QTLOGGER_DECL_SPEC
void Pipeline::append(std::initializer_list<HandlerPtr> handlers)
{
    m_handlers.append(handlers);
}

QTLOGGER_DECL_SPEC
void Pipeline::remove(const HandlerPtr &handler)
{
    if (handler.isNull())
        return;

    m_handlers.removeAll(handler);
}

QTLOGGER_DECL_SPEC
void Pipeline::clear()
{
    m_handlers.clear();
}

QTLOGGER_DECL_SPEC
Pipeline &Pipeline::operator<<(const HandlerPtr &handler)
{
    append(handler);
    return *this;
}

QTLOGGER_DECL_SPEC
bool Pipeline::process(LogMessage &lmsg)
{
    QString fmsg;
    QVariantHash attrs;

    if (m_scoped) {
        if (lmsg.isFormatted()) {
            fmsg = lmsg.formattedMessage();
        }
        attrs = lmsg.attributes();
    }

    for (auto &handler : m_handlers) {
        if (!handler)
            continue;
        if (!handler->process(lmsg))
            break;
    }

    if (m_scoped) {
        lmsg.setFormattedMessage(fmsg);
        lmsg.setAttributes(attrs);
    }

    return true;
}

} // namespace QtLogger

// simplepipeline.cpp

#include <QCoreApplication>

#ifdef QTLOGGER_NETWORK

#endif

#ifdef QTLOGGER_SYSLOG

#endif

#ifdef QTLOGGER_SDJOURNAL

#endif

#ifdef Q_OS_WIN

#endif

namespace QtLogger {

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::addSeqNumber(const QString &name)
{
    append(SeqNumberAttrPtr::create(name));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::addAppInfo()
{
    append(AppInfoAttrsPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::attrHandler(std::function<QVariantHash(const LogMessage &lmsg)> func)
{
    append(FunctionAttrHandlerPtr::create(func));
    return *this;
}

#ifdef QTLOGGER_NETWORK
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::addHostInfo()
{
    append(HostInfoAttrsPtr::create());
    return *this;
}
#endif

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::filter(std::function<bool(const LogMessage &)> func)
{
    append(FunctionFilterPtr::create(func));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::filterCategory(const QString &rules)
{
    append(CategoryFilterPtr::create(rules));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::filterDuplicate()
{
    append(DuplicateFilterPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::filter(const QString &regexp)
{
    append(RegExpFilterPtr::create(regexp));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::filterLevel(QtMsgType minLevel)
{
    append(LevelFilterPtr::create(minLevel));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::format(std::function<QString(const LogMessage &)> func)
{
    append(FunctionFormatterPtr::create(func));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::format(const QString &pattern)
{
    if (pattern == "default")
        append(PatternFormatterPtr::create(DefaultMessagePattern));
    else if (pattern == "qt")
        append(QtLogMessageFormatter::instance());
    else if (pattern == "pretty")
        append(PrettyFormatterPtr::create());
    else
        append(PatternFormatterPtr::create(pattern));
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::formatByQt()
{
    append(QtLogMessageFormatter::instance());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::formatPretty()
{
    append(PrettyFormatterPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::formatToJson()
{
    append(JsonFormatterPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToStdOut()
{
    append(StdOutSinkPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToStdErr()
{
    append(StdErrSinkPtr::create());
    return *this;
}

#ifdef QTLOGGER_SYSLOG
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToSyslog()
{
    append(SyslogSinkPtr::create(QCoreApplication::applicationName()));
    return *this;
}
#endif

#ifdef QTLOGGER_SDJOURNAL
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToSdJournal()
{
    append(SdJournalSinkPtr::create());
    return *this;
}
#endif

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToPlatformStdLog()
{
    append(PlatformStdSinkPtr::create());
    return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToFile(const QString &fileName, int maxFileSize,
                                           int maxFileCount)
{
    if (maxFileSize == 0)
        append(RotatingFileSinkPtr::create(fileName));
    else
        append(RotatingFileSinkPtr::create(fileName, maxFileSize, maxFileCount));
    return *this;
}

#ifdef QTLOGGER_NETWORK
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToHttp(const QString &url)
{
    append(HttpSinkPtr::create(url));
    return *this;
}
#endif

#ifdef Q_OS_WIN
QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::sendToWinDebug()
{
    append(WinDebugSinkPtr::create());
    return *this;
}
#endif

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::pipeline()
{
    auto pipeline = SimplePipelinePtr::create(/* scoped */ true, /* parent */ this);
    append(pipeline);
    return *pipeline.data();
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::end()
{
    if (m_parent)
        return *m_parent;
    else
        return *this;
}

QTLOGGER_DECL_SPEC
SimplePipeline &SimplePipeline::handler(std::function<bool(LogMessage &)> func)
{
    append(FunctionHandlerPtr::create(std::move(func)));
    return *this;
}

QTLOGGER_DECL_SPEC
void SimplePipeline::recursiveFlush(const Pipeline *pipeline)
{
    for (const auto &handler : pipeline->handlers()) {
        if (auto sink = handler.dynamicCast<Sink>()) {
            sink->flush();
            continue;
        }
        if (auto pipeline = handler.dynamicCast<Pipeline>()) {
            recursiveFlush(pipeline.data());
        }
    }
}

QTLOGGER_DECL_SPEC
void SimplePipeline::flush()
{
    recursiveFlush(this);
}

} // namespace QtLogger

// androidlogsink.cpp

#ifdef QTLOGGER_ANDROIDLOG

#include <android/log.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void AndroidLogSink::send(const LogMessage &lmsg)
{
    auto priority = ANDROID_LOG_DEBUG;

    switch (lmsg.type()) {
    case QtDebugMsg:
        priority = ANDROID_LOG_DEBUG;
        break;
    case QtInfoMsg:
        priority = ANDROID_LOG_INFO;
        break;
    case QtWarningMsg:
        priority = ANDROID_LOG_WARN;
        break;
    case QtCriticalMsg:
        priority = ANDROID_LOG_ERROR;
        break;
    case QtFatalMsg:
        priority = ANDROID_LOG_FATAL;
        break;
    };

    __android_log_print(priority, lmsg.category(), "%s", qPrintable(lmsg.message()));

    // TODO: use __android_log_write_log_message for API level 30 and above
}

} // namespace QtLogger

#endif // QTLOGGER_ANDROIDLOG

// filesink.cpp

#include <QDateTime>
#include <QFile>
#include <QRegularExpression>
#include <QSharedPointer>

#include <iostream>

namespace QtLogger {

namespace {

/**
 * @brief Replaces the time pattern in the given string with the current date and time.
 *
 * This function searches for a time pattern in the format `%{time <format>}` within the input
 * string. If found, it replaces the pattern with the current date and time formatted according to
 * the specified format. If no format is specified, it defaults to "yyyyMMdd_hhmmss".
 *
 * @param path The input string potentially containing the time pattern.
 * @return A new string with the time pattern replaced by the current date and time.
 */

QTLOGGER_DECL_SPEC
QString replaceTimePattern(const QString &path)
{
    static auto re = QRegularExpression(QStringLiteral("(.*)%{time *(.*?)}(.*)"));
    auto match = re.match(path);

    if (!match.hasMatch())
        return path;

    auto format = match.captured(2);

    if (format.isEmpty()) {
        format = QStringLiteral("yyyyMMdd_hhmmss");
    }

    return match.captured(1) + QDateTime::currentDateTime().toString(format) + match.captured(3);
}

QTLOGGER_DECL_SPEC
QSharedPointer<QFile> createFilePtr(const QString &path)
{
    return QSharedPointer<QFile>::create(replaceTimePattern(path));
}

}

QTLOGGER_DECL_SPEC
FileSink::FileSink(const QString &path) : IODeviceSink(createFilePtr(path))
{
    if (!file()->open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text)) {
        std::cerr << "Logger::FileHandler: Can't open log file: " << path.toStdString()
                  << " error: " << file()->errorString().toStdString() << std::endl;
    }
}

QTLOGGER_DECL_SPEC
FileSink::~FileSink()
{
    file()->close();
}

QTLOGGER_DECL_SPEC
bool FileSink::flush()
{
    return file()->flush();
}

QTLOGGER_DECL_SPEC
QFile *FileSink::file() const
{
    return qobject_cast<QFile *>(device().data());
}

} // namespace QtLogger

// httpsink.cpp

#ifdef QTLOGGER_NETWORK

#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QNetworkRequest>

namespace QtLogger {

QTLOGGER_DECL_SPEC
HttpSink::HttpSink(const QUrl &url) : m_url(url)
{
    m_manager = new QNetworkAccessManager();

#ifndef QTLOGGER_NO_THREAD
    if (m_manager->thread() != Logger::instance()->ownThread()) {
        m_manager->moveToThread(Logger::instance()->ownThread());
    }
#endif

    m_request.setUrl(m_url);
}

QTLOGGER_DECL_SPEC
HttpSink::~HttpSink()
{
    if (!m_manager.isNull()) {
        delete m_manager.data();
    }
}

QTLOGGER_DECL_SPEC
void HttpSink::send(const LogMessage &lmsg)
{
    if (!Logger::instance()->ownThreadIsRunning()) {
        if (!m_manager.isNull() && !m_manager->property("activeReply").isValid())
            m_manager->deleteLater();
        m_manager = new QNetworkAccessManager();
    }

    if (lmsg.hasAttribute("mime_type")) {
        m_request.setHeader(QNetworkRequest::ContentTypeHeader,
                            QStringLiteral("%1; charset=utf-8")
                                    .arg(lmsg.attribute("mime_type").toByteArray()));
    } else {
        m_request.setHeader(QNetworkRequest::ContentTypeHeader,
                            QStringLiteral("text/plain; charset=utf-8"));
    }

    auto reply = m_manager->post(m_request, lmsg.formattedMessage().toUtf8());

    QObject::connect(reply, &QNetworkReply::finished, reply, &QObject::deleteLater);

    if (!Logger::instance()->ownThreadIsRunning()) {
        m_manager->setProperty("activeReply", QVariant::fromValue(reply));
        QObject::connect(reply, &QNetworkReply::finished, m_manager, &QObject::deleteLater);
    }
}

QTLOGGER_DECL_SPEC
void HttpSink::setNetworkAccessManager(QNetworkAccessManager *manager)
{
    if (!m_manager.isNull()) {
        delete m_manager.data();
    }
    m_manager = manager;
}

QTLOGGER_DECL_SPEC
void HttpSink::setRequest(const QNetworkRequest &request)
{
    m_request = request;
}

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// iodevicesink.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
IODeviceSink::IODeviceSink(const QIODevicePtr &device) : m_device(device) { }

QTLOGGER_DECL_SPEC
void IODeviceSink::send(const LogMessage &lmsg)
{
    if (m_device.isNull()) {
        return;
    }

    m_device->write(lmsg.formattedMessage().toLocal8Bit().append("\n"));
}

QTLOGGER_DECL_SPEC
const QIODevicePtr &IODeviceSink::device() const
{
    return m_device;
}

QTLOGGER_DECL_SPEC
void IODeviceSink::setDevice(const QIODevicePtr &device)
{
    m_device = device;
}

} // namespace QtLogger

// oslogsink.cpp

#ifdef QTLOGGER_OSLOG

#include <os/log.h>

#include <QCoreApplication>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void OslogSink::send(const LogMessage &lmsg)
{
    auto customLog = os_log_create(qPrintable(QCoreApplication::applicationName()),
                                   qPrintable(lmsg.category()));

    auto type = OS_LOG_TYPE_DEBUG;
    switch (lmsg.type()) {
    case QtDebugMsg:
        type = OS_LOG_TYPE_DEBUG;
        break;
    case QtInfoMsg:
        type = OS_LOG_TYPE_INFO;
        break;
    case QtWarningMsg:
        type = OS_LOG_TYPE_ERROR;
        break;
    case QtCriticalMsg:
        type = OS_LOG_TYPE_FAULT;
        break;
    case QtFatalMsg:
        type = OS_LOG_TYPE_FAULT;
        break;
    };

    os_log_with_type(customLog, type, "%s", qPrintable(lmsg.message()));
}

} // namespace QtLogger

#endif // QTLOGGER_OSLOG

// rotatingfilesink.cpp

#include <QDir>
#include <QFile>
#include <QFileInfo>
#include <QRegularExpression>

namespace QtLogger {

QTLOGGER_DECL_SPEC
RotatingFileSink::RotatingFileSink(const QString &path, int maxFileSize, int maxFileCount)
    : FileSink(path), m_maxFileSize(maxFileSize), m_maxFileCount(maxFileCount)
{
    if (file()->size() > 0)
        rotate();
}

QTLOGGER_DECL_SPEC
void RotatingFileSink::send(const LogMessage &lmsg)
{
    const auto newFileSize = file()->size() + lmsg.formattedMessage().toLocal8Bit().size();

    if (m_maxFileSize > 0 && file()->size() != 0 && newFileSize > m_maxFileSize) {
        rotate();
    }

    FileSink::send(lmsg);
}

QTLOGGER_DECL_SPEC
QString numberedFileName(const QString &fileName, int i)
{
    return QStringLiteral("%1.%2").arg(fileName).arg(i);
}

QTLOGGER_DECL_SPEC
void RotatingFileSink::rotate()
{
    if (m_maxFileCount == 1)
        return;

    int maxFileCount = m_maxFileCount > 1 ? m_maxFileCount : RotatingFileCountLimit;

    file()->close();

    const auto &fileName = file()->fileName();

    int i = 1;
    for (; i < maxFileCount; ++i) {
        if (!QFile::exists(numberedFileName(fileName, i))) {
            --i;
            break;
        }
    }
    for (; i > 0; --i) {
        const auto &curFileName = numberedFileName(fileName, i);
        const auto &newFileName = numberedFileName(fileName, i + 1);

        QFile::rename(curFileName, newFileName);
    }

    // rename first
    QFile::rename(fileName, numberedFileName(fileName, 1));

    // remove last
    QFile::remove(QStringLiteral("%1.%2").arg(fileName).arg(m_maxFileCount));

    file()->open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text);
}

} // namespace QtLogger

// sdjournalsink.cpp

#ifdef QTLOGGER_SDJOURNAL

#include <systemd/sd-journal.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void SdJournalSink::send(const LogMessage &lmsg)
{
    auto priority = LOG_DEBUG;

    switch (lmsg.type()) {
    case QtDebugMsg:
        priority = LOG_DEBUG;
        break;
    case QtWarningMsg:
        priority = LOG_WARNING;
        break;
    case QtCriticalMsg:
        priority = LOG_ERR;
        break;
    case QtFatalMsg:
        priority = LOG_EMERG;
        break;
    case QtInfoMsg:
        priority = LOG_INFO;
        break;
    default:
        return;
    }

    const auto &file = QByteArrayLiteral("CODE_FILE=") + QByteArray(lmsg.file());
    const auto &line = QByteArrayLiteral("CODE_LINE=") + QByteArray::number(lmsg.line());

    sd_journal_print_with_location(priority, file.constData(), line.constData(), lmsg.function(),
                                   "%s", qPrintable(lmsg.formattedMessage()));

    sd_journal_send_with_location(file.constData(), line.constData(), lmsg.function(), "%s",
                                  qPrintable(lmsg.formattedMessage()), "PRIORITY=%i", priority,
                                  "CATEGORY=%s", lmsg.category(), NULL);
}

} // namespace QtLogger

#endif // QTLOGGER_SDJOURNAL

// signalsink.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
SignalSink::SignalSink(QObject *parent) : QObject(parent) { }

QTLOGGER_DECL_SPEC
void SignalSink::send(const LogMessage &lmsg)
{
    Q_EMIT message(lmsg);
}

} // namespace QtLogger

// stderrsink.cpp

#include <iostream>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void StdErrSink::send(const LogMessage &lmsg)
{
    std::cerr << qPrintable(lmsg.formattedMessage()) << std::endl;
}

QTLOGGER_DECL_SPEC
bool StdErrSink::flush()
{
    std::flush(std::cerr);
    return true;
}

} // namespace QtLogger

// stdoutsink.cpp

#include <iostream>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void StdOutSink::send(const LogMessage &lmsg)
{
    std::cout << qPrintable(lmsg.formattedMessage()) << std::endl;
}

QTLOGGER_DECL_SPEC
bool StdOutSink::flush()
{
    std::flush(std::cout);
    return true;
}

} // namespace QtLogger

// syslogsink.cpp

#ifdef QTLOGGER_SYSLOG

#include <syslog.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
SyslogSink::SyslogSink(const QString &ident, int option, int facility)
{
    openlog(qPrintable(ident), option, facility);
}

QTLOGGER_DECL_SPEC
SyslogSink::~SyslogSink()
{
    closelog();
}

QTLOGGER_DECL_SPEC
void SyslogSink::send(const LogMessage &lmsg)
{
    auto priority = LOG_DEBUG;

    switch (lmsg.type()) {
    case QtDebugMsg:
        priority = LOG_DEBUG;
        break;
    case QtWarningMsg:
        priority = LOG_WARNING;
        break;
    case QtCriticalMsg:
        priority = LOG_ERR;
        break;
    case QtFatalMsg:
        priority = LOG_EMERG;
        break;
    case QtInfoMsg:
        priority = LOG_INFO;
        break;
    default:
        return;
    }

    QString formattedMessage;
    if (qstrcmp(lmsg.category(), "default") == 0) {
        formattedMessage = lmsg.message();
    } else {
        formattedMessage = QStringLiteral("%1: %2").arg(lmsg.category(), lmsg.message());
    }

    syslog(priority, "%s", qPrintable(formattedMessage));
}

} // namespace QtLogger

#endif // QTLOGGER_SYSLOG

// windebugsink.cpp

#ifdef Q_OS_WIN

#include <qt_windows.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void WinDebugSink::send(const LogMessage &lmsg)
{
    auto formattedMessage = lmsg.formattedMessage() + u'\n';
    OutputDebugString(reinterpret_cast<const wchar_t *>(formattedMessage.utf16()));
}

} // namespace QtLogger

#endif

// sortedpipeline.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
void SortedPipeline::insertBetweenNearLeft(const QSet<HandlerType> &leftType,
                                           const QSet<HandlerType> &rightType,
                                           const HandlerPtr &handler)
{
    auto firstRight =
            std::find_if(handlers().begin(), handlers().end(),
                         [&rightType](const auto &x) { return rightType.contains(x->type()); });

    auto lastLeft = std::find_if(firstRight, handlers().begin(), [&leftType](const HandlerPtr &x) {
        return leftType.contains(x->type());
    });

    handlers().insert(lastLeft, handler);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::insertBetweenNearRight(const QSet<HandlerType> &leftType,
                                            const QSet<HandlerType> &rightType,
                                            const HandlerPtr &handler)
{
    auto lastLeft =
            std::find_if(handlers().end(), handlers().begin(),
                         [&leftType](const HandlerPtr &x) { return leftType.contains(x->type()); });

    auto firstRight = std::find_if(lastLeft, handlers().end(), [&rightType](const auto &x) {
        return rightType.contains(x->type());
    });

    handlers().insert(firstRight, handler);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clear(HandlerType type)
{
    QMutableListIterator<HandlerPtr> iter(handlers());

    while (iter.hasNext()) {
        if (iter.next()->type() == type) {
            iter.remove();
        }
    }
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clear()
{
    Pipeline::clear();
}

QTLOGGER_DECL_SPEC
void SortedPipeline::appendAttrHandler(const AttrHandlerPtr &attrHandler)
{
    if (attrHandler.isNull())
        return;

    insertBetweenNearLeft({ HandlerType::AttrHandler },
                          { HandlerType::Filter, HandlerType::Formatter, HandlerType::Sink },
                          attrHandler);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clearAttrHandlers()
{
    clear(HandlerType::AttrHandler);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::appendFilter(const FilterPtr &filter)
{
    if (filter.isNull())
        return;

    insertBetweenNearLeft({ HandlerType::AttrHandler, HandlerType::Filter },
                          { HandlerType::Formatter, HandlerType::Sink }, filter);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clearFilters()
{
    clear(HandlerType::Filter);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::setFormatter(const FormatterPtr &formatter)
{
    if (formatter.isNull())
        return;

    clearFormatters();

    insertBetweenNearRight({ HandlerType::AttrHandler, HandlerType::Filter }, { HandlerType::Sink },
                           formatter);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clearFormatters()
{
    clear(HandlerType::Formatter);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::appendSink(const SinkPtr &sink)
{
    append(sink);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clearSinks()
{
    clear(HandlerType::Sink);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::appendPipeline(const PipelinePtr &pipeline)
{
    append(pipeline);
}

QTLOGGER_DECL_SPEC
void SortedPipeline::clearPipelines()
{
    clear(HandlerType::Pipeline);
}

} // namespace QtLogger

// utils.cpp

#include <QLoggingCategory>
#include <QString>

namespace {

QTLOGGER_DECL_SPEC
QString prevMessagePattern(const QString &messagePattern = {})
{
    static QString __prevMessagePattern { QString::fromUtf8(QtLogger::DefaultMessagePattern) };

    if (!messagePattern.isNull())
        __prevMessagePattern = messagePattern;

    return __prevMessagePattern;
}

}

namespace QtLogger {

QTLOGGER_DECL_SPEC
void setFilterRules(const QString &a_rules)
{
    QString rules = a_rules;
    rules.replace(QChar::fromLatin1(';'), QChar::fromLatin1('\n'));
    rules.replace(QChar::fromLatin1(':'), QChar::fromLatin1('\n'));
    QLoggingCategory::setFilterRules(rules);
}

QTLOGGER_DECL_SPEC
QString setMessagePattern(const QString &a_messagePattern)
{
    QString messagePattern = a_messagePattern;

    if (messagePattern.toLower() == QStringLiteral("default")) {
        messagePattern = QString::fromUtf8(DefaultMessagePattern);
    } else if (messagePattern.toLower() == QStringLiteral("pretty")) {
        messagePattern = QString::fromUtf8(PrettyMessagePattern);
    }

    static QString s_messagePattern { QString::fromUtf8(QtLogger::DefaultMessagePattern) };

    if (s_messagePattern == messagePattern)
        return s_messagePattern;

    prevMessagePattern(s_messagePattern);

    s_messagePattern = messagePattern;

    qSetMessagePattern(s_messagePattern);

    return prevMessagePattern();
}

QTLOGGER_DECL_SPEC
QString restorePreviousMessagePattern()
{
    return setMessagePattern(prevMessagePattern());
}

} // namespace QtLogger

