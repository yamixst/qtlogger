// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2024 Mikhail Yatsenko <mikhail.yatsenko@gmail.com>

// This file is automatically generated. Please don't edit it.

#pragma once

// #define QTLOGGER_NO_THREAD
// #define QTLOGGER_NETWORK
// #define QTLOGGER_IOSLOG
// #define QTLOGGER_ANDROIDLOG
// #define QTLOGGER_SYSLOG
// #define QTLOGGER_JOURNAL

#define QTLOGGER_DECL_SPEC inline

// qtlogger.h

// filter.h

#include <QSharedPointer>

// handler.h

#include <QSharedPointer>

// logger_global.h

#include <QtCore/qglobal.h>

#if defined(QTLOGGER_STATIC)
#    define QTLOGGER_EXPORT
#elif defined(QTLOGGER_LIBRARY)
#    define QTLOGGER_EXPORT Q_DECL_EXPORT
#else
#    define QTLOGGER_EXPORT Q_DECL_IMPORT
#endif

#if !defined(QTLOGGER_DECL_SPEC)
#    define QTLOGGER_DECL_SPEC
#endif

// end logger_global.h

// logmessage.h

#include <QDateTime>
#include <QHash>
#include <QThread>
#include <qlogging.h>

namespace QtLogger {

class QTLOGGER_EXPORT LogMessage
{
public:
    constexpr LogMessage() noexcept = default;

    LogMessage(QtMsgType type, const QMessageLogContext &context, const QString &message) noexcept
        : m_type(type),
          m_context(context.file, context.line, context.function, context.category),
          m_message(message)
    {
    }

    LogMessage(const LogMessage &logMsg) noexcept
        : m_file(logMsg.m_context.file),
          m_function(logMsg.m_context.function),
          m_category(logMsg.m_context.category),
          m_type(logMsg.m_type),
          m_context(m_file.constData(), logMsg.m_context.line, m_function.constData(),
                    m_category.constData()),
          m_message(logMsg.m_message),
          m_time(logMsg.m_time),
          m_threadId(logMsg.m_threadId),
          m_formattedMessage(logMsg.m_formattedMessage),
          m_attributes(logMsg.m_attributes)
    {
    }

    QtMsgType type() const;
    const QMessageLogContext &context() const;
    QString message() const;

    int line() const;
    const char *file() const;
    const char *function() const;
    const char *category() const;

    inline QDateTime time() const { return m_time; }
    inline qintptr threadId() const { return reinterpret_cast<qintptr>(m_threadId); }

    QString formattedMessage() const;
    void setFormattedMessage(const QString &formattedMessage);
    bool isFormatted() const;

    // Custom attributes
    QVariant attribute(const QString &name) const;
    void setAttribute(const QString &name, const QVariant &value);
    bool hasAttribute(const QString &name) const;
    QVariantHash attributes() const { return m_attributes; }

private:
    // context buffers
    const QByteArray m_file;
    const QByteArray m_function;
    const QByteArray m_category;

    const QtMsgType m_type = QtDebugMsg;
    const QMessageLogContext m_context;
    const QString m_message;

    const QDateTime m_time = QDateTime::currentDateTime();
    const Qt::HANDLE m_threadId = QThread::currentThreadId();

    QString m_formattedMessage;
    QVariantHash m_attributes;
};

inline QtMsgType LogMessage::type() const
{
    return m_type;
}

inline const QMessageLogContext &LogMessage::context() const
{
    return m_context;
}

inline QString LogMessage::message() const
{
    return m_message;
}

inline int LogMessage::line() const
{
    return m_context.line;
}

inline const char *LogMessage::file() const
{
    return m_context.file;
}

inline const char *LogMessage::function() const
{
    return m_context.function;
}

inline const char *LogMessage::category() const
{
    return m_context.category;
}

inline QString LogMessage::formattedMessage() const
{
    return isFormatted() ? m_formattedMessage : m_message;
}

inline void LogMessage::setFormattedMessage(const QString &formattedMessage)
{
    m_formattedMessage = formattedMessage;
}

inline bool LogMessage::isFormatted() const
{
    return !m_formattedMessage.isNull();
}

inline QVariant LogMessage::attribute(const QString &name) const
{
    return m_attributes.value(name);
}

inline void LogMessage::setAttribute(const QString &name, const QVariant &value)
{
    m_attributes.insert(name, value);
}

inline bool LogMessage::hasAttribute(const QString &name) const
{
    return m_attributes.contains(name);
}

} // namespace QtLogger

// end logmessage.h

namespace QtLogger {

class QTLOGGER_EXPORT Handler
{
public:
    enum class HandlerType { Handler, Filter, Formatter, Sink, Pipeline, Mixed };

    virtual ~Handler() = default;

    virtual HandlerType type() const { return HandlerType::Handler; }

    virtual bool process(LogMessage &logMsg) = 0;
};

using HandlerPtr = QSharedPointer<Handler>;

} // namespace QtLogger

// end handler.h

namespace QtLogger {

class QTLOGGER_EXPORT Filter : public Handler
{
public:
    virtual ~Filter() = default;

    virtual bool filter(const LogMessage &logMsg) const = 0;

    HandlerType type() const override { return HandlerType::Filter; }

    bool process(LogMessage &logMsg) override final { return filter(logMsg); }
};

using FilterPtr = QSharedPointer<Filter>;

} // namespace QtLogger

// end filter.h

// formatter.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Formatter : public Handler
{
public:
    virtual ~Formatter() = default;

    virtual QString format(const LogMessage &logMsg) const = 0;

    HandlerType type() const override { return HandlerType::Formatter; }

    bool process(LogMessage &logMsg) override final
    {
        logMsg.setFormattedMessage(format(logMsg));
        return true;
    }
};

using FormatterPtr = QSharedPointer<Formatter>;

} // namespace QtLogger

// end formatter.h

// sink.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Sink : public Handler
{
public:
    virtual void send(const LogMessage &logMsg) = 0;
    virtual bool flush() { return true; }

    HandlerType type() const override { return HandlerType::Sink; }

    bool process(LogMessage &logMsg) override final
    {
        send(logMsg);
        return true;
    }
};

using SinkPtr = QSharedPointer<Sink>;

} // namespace QtLogger

// end sink.h

// functionfilter.h

#include <functional>

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT FunctionFilter : public Filter
{
public:
    using Function = std::function<bool(const LogMessage &)>;

    FunctionFilter(const Function &function);

    bool filter(const LogMessage &logMsg) const override;

private:
    Function m_function;
};

using FunctionFilterPtr = QSharedPointer<FunctionFilter>;

inline FunctionFilter::FunctionFilter(const Function &function) : m_function(function) { }

inline bool FunctionFilter::filter(const LogMessage &logMsg) const
{
    return m_function(logMsg);
}

} // namespace QtLogger

// end functionfilter.h

// regexpfilter.h

#include <QRegularExpression>
#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT RegExpFilter : public Filter
{
public:
    explicit RegExpFilter(const QRegularExpression &regExp);
    explicit RegExpFilter(const QString &regExp);

    bool filter(const LogMessage &logMsg) const override;

private:
    QRegularExpression m_regExp;
};

using RegExpFilterPtr = QSharedPointer<RegExpFilter>;

} // namespace QtLogger

// end regexpfilter.h

// functionformatter.h

#include <functional>

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT FunctionFormatter : public Formatter
{
public:
    using Function = std::function<QString(const LogMessage &)>;

    FunctionFormatter(const Function &func) : m_func(func) { }

    QString format(const LogMessage &logMsg) const override { return m_func(logMsg); }

private:
    Function m_func;
};

using FunctionFormatterPtr = QSharedPointer<FunctionFormatter>;

} // namespace QtLogger

// end functionformatter.h

// jsonformatter.h

#include <QSharedPointer>

namespace QtLogger {

using JsonFormatterPtr = QSharedPointer<class JsonFormatter>;

class QTLOGGER_EXPORT JsonFormatter : public Formatter
{
public:
    static JsonFormatterPtr instance()
    {
        static const auto s_instance = JsonFormatterPtr::create();
        return s_instance;
    }

    QString format(const LogMessage &logMsg) const override;
};

} // namespace QtLogger

// end jsonformatter.h

// patternformatter.h

#include <QSharedPointer>

namespace QtLogger {

using PatternFormatterPtr = QSharedPointer<class PatternFormatter>;

class QTLOGGER_EXPORT PatternFormatter : public Formatter
{
public:
    explicit PatternFormatter(const QString &pattern);

    QString format(const LogMessage &logMsg) const override;

private:
    QString m_pattern;
};

} // namespace QtLogger

// end patternformatter.h

// prettyformatter.h

#include <QMap>
#include <QStringList>

namespace QtLogger {

using PrettyFormatterPtr = QSharedPointer<class PrettyFormatter>;

class QTLOGGER_EXPORT PrettyFormatter : public Formatter
{
public:
    static PrettyFormatterPtr instance()
    {
        static const auto s_instance = PrettyFormatterPtr::create(true, 0);
        return s_instance;
    }

    explicit PrettyFormatter(bool showThread = true, int maxCategoryWidth = 15);

    QString format(const LogMessage &logMsg) const override;

    inline bool showThreadId() const { return m_showThreadId; }
    inline void setShowThreadId(bool newShowThreadId) { m_showThreadId = newShowThreadId; }

    inline int maxCategoryWidth() const { return m_maxCategoryWidth; }
    inline void setMaxCategoryWidth(int newMaxCategoryWidth)
    {
        m_maxCategoryWidth = newMaxCategoryWidth;
    }

private:
    bool m_showThreadId = true;
    mutable QMap<int, int> m_threads;
    mutable int m_threadsIndex = 0;

    int m_maxCategoryWidth = 15;
    mutable int m_categoryWidth = 0;
};

} // namespace QtLogger

// end prettyformatter.h

// qtlogmessageformatter.h

#include <QSharedPointer>

namespace QtLogger {

using QtLogMessageFormatterPtr = QSharedPointer<class QtLogMessageFormatter>;

class QTLOGGER_EXPORT QtLogMessageFormatter : public Formatter
{
public:
    static QtLogMessageFormatterPtr instance()
    {
        static const auto s_instance = QtLogMessageFormatterPtr(new QtLogMessageFormatter());
        return s_instance;
    }

    QString format(const LogMessage &logMsg) const override
    {
        return qFormatLogMessage(logMsg.type(), logMsg.context(), logMsg.message());
    }

private:
    QtLogMessageFormatter() { }
};

} // namespace QtLogger

// end qtlogmessageformatter.h

// logger.h

#include <QSettings>

#ifndef QTLOGGER_NO_THREAD
#    include <QEvent>
#    include <QMutex>
#    include <QThread>
#endif

#ifndef QTLOGGER_NO_THREAD

// ownthreadpipeline.h

#include <QPointer>

// typedpipeline.h

// pipeline.h

#include <initializer_list>

#include <QList>
#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT Pipeline : public Handler
{
public:
    Pipeline() = default;
    Pipeline(std::initializer_list<HandlerPtr> handlers);

    HandlerType type() const override { return HandlerType::Pipeline; }

    void append(const HandlerPtr &handler);
    void append(std::initializer_list<HandlerPtr> handlers);
    void remove(const HandlerPtr &handler);
    void clear();

    Pipeline &operator<<(const HandlerPtr &handler);

    bool process(LogMessage &logMsg) override;

protected:
    QList<HandlerPtr> &handlers() { return m_handlers; }

private:
    QList<HandlerPtr> m_handlers;
};

using PipelinePtr = QSharedPointer<Pipeline>;

inline Pipeline &operator<<(Pipeline *pipeline, const HandlerPtr &handler)
{
    return *pipeline << handler;
}

inline Pipeline &operator<<(PipelinePtr pipeline, const HandlerPtr &handler)
{
    return *pipeline << handler;
}

} // namespace QtLogger

// end pipeline.h

namespace QtLogger {

class QTLOGGER_EXPORT TypedPipeline : public Pipeline
{
public:
    TypedPipeline() = default;
    ~TypedPipeline() override;

    void insertAfter(HandlerType type, const HandlerPtr &handler);
    void insertBetween(HandlerType leftType, HandlerType rightType, const HandlerPtr &handler);
    void clearType(HandlerType type);

    void appendFilter(const FilterPtr &filter);
    FunctionFilterPtr appendFilter(const std::function<bool(const LogMessage &)> &function);
    RegExpFilterPtr appendFilter(const QRegularExpression &regExp);
    void clearFilters();

    void setFormatter(const FormatterPtr &formatter);
    FunctionFormatterPtr setFormatter(const std::function<QString(const LogMessage &)> &function);
    PatternFormatterPtr setFormatter(const QString &pattern);
    void clearFormatters();

    void appendSink(const SinkPtr &sink);
    void clearSinks();

    void appendPipeline(const PipelinePtr &pipeline);
    void clearPipelines();

    void flush();
};

using TypedPipelinePtr = QSharedPointer<TypedPipeline>;

} // namespace QtLogger

// end typedpipeline.h

QT_FORWARD_DECLARE_CLASS(QThread)

namespace QtLogger {

class OwnThreadPipelineWorker;

class QTLOGGER_EXPORT OwnThreadPipeline : public TypedPipeline
{
public:
    OwnThreadPipeline();
    ~OwnThreadPipeline() override;

    void moveToOwnThread();
    void moveToMainThread();
    bool ownThreadIsRunning() const;
    QThread *ownThread() const { return m_thread; }

    bool process(LogMessage &logMsg) override;

private:
    QPointer<OwnThreadPipelineWorker> m_worker;
    QPointer<QThread> m_thread;
};

} // namespace QtLogger

// end ownthreadpipeline.h

#else

#endif

#define gQtLogger QtLogger::Logger::instance()

#if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
#    define QRMUTEX QRecursiveMutex
#else
#    define QRMUTEX QMutex
#endif

namespace QtLogger {

class QTLOGGER_EXPORT Logger :
#ifndef QTLOGGER_NO_THREAD
    public OwnThreadPipeline
#else
    public TypedPipeline
#endif
{
public:
    enum class SinkType {
        Unknown = 0x00,
        StdOut = 0x01,
        StdErr = 0x02,
        SysLog = 0x04,
        Journal = 0x8,
        StdLog = 0x10, // For Android and iOS
        NTEventLog = 0x20,
        File = 0x40,
        RotatingFile = 0x80
    };

    Q_DECLARE_FLAGS(SinkTypeFlags, SinkType)

    static Logger *instance();

    Logger() = default;
    ~Logger() override;

    /*
        Format:  "[<category>|*].[debug|info|warning|critical]=true|false;..."
        Example: "app.*.debug=false;app.logger.debug=true"
    */
    static void setFilterRules(const QString &rules);

    /*
       Following placeholders are supported:
       %{appname} %{category} %{file} %{function} %{line} %{message} %{pid} %{threadid}
       %{qthreadptr} %{type} %{time process} %{time boot} %{time [format]} %{backtrace [depth=N]
       [separator="..."]}
    */
    static void setMessagePattern(const QString &pattern);

    Logger &operator<<(const HandlerPtr &handler);

    void configure(std::initializer_list<HandlerPtr> handlers, bool async = false);
    void configure(const SinkTypeFlags &types = SinkType::StdLog, const QString &path = {},
                   int maxFileSize = 0, int maxFileCount = 0, bool async = false);
    void configure(int types, const QString &path = {}, int maxFileSize = 0, int maxFileCount = 0,
                   bool async = false);

    /*
       logger/filter_rules = [<category>|*][.debug|.info|.warning|.critical]=true|false;...
       logger/message_pattern = <string>
       logger/regexp_filter = <regexp>
       logger/stdout = true|false
       logger/stderr = true|false
       logger/stdlog = true|false
       logger/syslog_ident = <string>
       logger/journal = true|false
       logger/path = <string>
       logger/max_file_size = <int>
       logger/max_file_count = <int>
       logger/async = true|false
    */
    void configure(const QSettings &settings, const QString &group = QStringLiteral("logger"));
    void configure(const QString &path, const QString &group = QStringLiteral("logger"));

#ifndef QTLOGGER_NO_THREAD
public:
    void lock() const;
    void unlock() const;
    QRMUTEX *mutex() const;
#endif

public:
    void installMessageHandler();
    static void restorePreviousMessageHandler();

    void processMessage(QtMsgType type, const QMessageLogContext &context, const QString &message);

    static void messageHandler(QtMsgType type, const QMessageLogContext &context,
                               const QString &message);

private:
#ifndef QTLOGGER_NO_THREAD
#    if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
    mutable QRecursiveMutex m_mutex;
#    else
    mutable QMutex m_mutex { QMutex::Recursive };
#    endif
#endif
};

inline Logger &operator<<(Logger *logger, const HandlerPtr &handler)
{
    return *logger << handler;
}

inline Logger &operator<<(Logger *logger, const Pipeline &pipeline)
{
    return *logger << PipelinePtr::create(pipeline);
}

} // namespace QtLogger

// end logger.h

// messagepatterns.h

namespace QtLogger {

constexpr char DefaultMessagePattern[] = "%{if-category}%{category}: %{endif}"
                                         "%{message}";

constexpr char PrettyMessagePattern[] = "%{time dd.MM.yyyy hh:mm:ss.zzz} "
                                        "%{if-debug} %{endif}"
                                        "%{if-info}I%{endif}"
                                        "%{if-warning}W%{endif}"
                                        "%{if-critical}E%{endif}"
                                        "%{if-fatal}F%{endif} "
                                        "[%{category}] %{message}";

} // namespace QtLogger

// end messagepatterns.h

// setmessagepattern.h

#include <qlogging.h>

namespace QtLogger {

QTLOGGER_EXPORT QString setMessagePattern(const QString &messagePattern);

QTLOGGER_EXPORT QString restorePreviousMessagePattern();

} // namespace QtLogger

// end setmessagepattern.h

// filesink.h

#include <QSharedPointer>

// iodevicesink.h

#include <QIODevice>
#include <QSharedPointer>

namespace QtLogger {

using QIODevicePtr = QSharedPointer<QIODevice>;

class QTLOGGER_EXPORT IODeviceSink : public Sink
{
public:
    explicit IODeviceSink(const QIODevicePtr &device);

    void send(const LogMessage &logMsg) override;

protected:
    const QIODevicePtr &device() const;
    void setDevice(const QIODevicePtr &device);

private:
    QIODevicePtr m_device;
};

using IODeviceSinkPtr = QSharedPointer<IODeviceSink>;

} // namespace QtLogger

// end iodevicesink.h

QT_FORWARD_DECLARE_CLASS(QFile)

namespace QtLogger {

class QTLOGGER_EXPORT FileSink : public IODeviceSink
{
public:
    explicit FileSink(const QString &path);
    ~FileSink() override;

    bool flush() override;

protected:
    QFile *file() const;
};

using FileSinkPtr = QSharedPointer<FileSink>;

} // namespace QtLogger

// end filesink.h

// rotatingfilesink.h

#include <QSharedPointer>

namespace QtLogger {

constexpr int RotatingFileDefaultMaxFileSize = 1024 * 1024;
constexpr int RotatingFileDefaultMaxFileCount = 3;
constexpr int RotatingFileCountLimit = 1024;

class QTLOGGER_EXPORT RotatingFileSink : public FileSink
{
public:
    explicit RotatingFileSink(const QString &path, int maxFileSize = RotatingFileDefaultMaxFileSize,
                              int maxFileCount = RotatingFileDefaultMaxFileCount);

    void send(const LogMessage &logMsg) override;

private:
    void rotate();

private:
    int m_maxFileSize = RotatingFileDefaultMaxFileSize;
    int m_maxFileCount = RotatingFileDefaultMaxFileCount;
};

using RotatingFileSinkPtr = QSharedPointer<RotatingFileSink>;

} // namespace QtLogger

// end rotatingfilesink.h

// signalsink.h

#include <QObject>

namespace QtLogger {

class QTLOGGER_EXPORT SignalSink : public QObject, Sink
{
    Q_OBJECT

public:
    explicit SignalSink(QObject *parent = nullptr);

    void send(const LogMessage &logMsg) override;

Q_SIGNALS:
    void message(const QtLogger::LogMessage &logMsg);
};

using SignalSinkPtr = QSharedPointer<SignalSink>;

} // namespace QtLogger

// end signalsink.h

// stderrsink.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT StdErrSink : public Sink
{
public:
    void send(const LogMessage &logMsg) override;
};

using StdErrSinkPtr = QSharedPointer<StdErrSink>;

} // namespace QtLogger

// end stderrsink.h

// stdlogsink.h

#include <QSharedPointer>

#if defined(QTLOGGER_ANDROIDLOG)

// androidlogsink.h

#ifdef QTLOGGER_ANDROIDLOG

#include <QSharedPointer>

#include "../abstractmessagesink.h"

namespace QtLogger {

class QTLOGGER_EXPORT AndroidLogSink : public Sink
{
public:
    void send(const LogMessage &logMsg) override;
};

using AndroidLogSinkPtr = QSharedPointer<AndroidLogSink>;

} // namespace QtLogger

#endif // QTLOGGER_ANDROIDLOG

// end androidlogsink.h

#elif defined(QTLOGGER_IOSLOG)

// ioslogsink.h

#ifdef QTLOGGER_IOSLOG

#include <QSharedPointer>

#include "../abstractmessagesink.h"

namespace QtLogger {

class QTLOGGER_EXPORT IosLogSink : public Sink
{
public:
    void send(const LogMessage &logMsg);
};

using IosLogSinkPtr = QSharedPointer<IosLogSink>;

} // namespace QtLogger

#endif // QTLOGGER_IOSLOG

// end ioslogsink.h

#else

#endif

namespace QtLogger {

#if defined(QTLOGGER_ANDROIDLOG)
using StdLogSink = AndroidLogSink;
#elif defined(QTLOGGER_IOSLOG)
using StdLogSink = IosLogSink;
#else
using StdLogSink = StdErrSink;
#endif

using StdLogSinkPtr = QSharedPointer<StdLogSink>;

}

// end stdlogsink.h

// stdoutsink.h

#include <QSharedPointer>

namespace QtLogger {

class QTLOGGER_EXPORT StdOutSink : public Sink
{
public:
    void send(const LogMessage &logMsg) override;
};

using StdOutSinkPtr = QSharedPointer<StdOutSink>;

} // namespace QtLogger

// end stdoutsink.h

// version.h

#define QTLOGGER_VERSION 0.4.0

// end version.h

using QtLoggerFilter = QtLogger::Filter;
using QtLoggerFormatter = QtLogger::Formatter;
using QtLoggerHandler = QtLogger::Handler;
using QtLoggerSink = QtLogger::Sink;
using QtLoggerLogMessage = QtLogger::LogMessage;
using QtLoggerFileSink = QtLogger::FileSink;
using QtLoggerFunctionFilter = QtLogger::FunctionFilter;
using QtLoggerFunctionFormatter = QtLogger::FunctionFormatter;
using QtLoggerIODeviceSink = QtLogger::IODeviceSink;
using QtLoggerJsonFormatter = QtLogger::JsonFormatter;
using QtLoggerLogger = QtLogger::Logger;
using QtLoggerPipeline = QtLogger::Pipeline;
using QtLoggerPatternFormatter = QtLogger::PatternFormatter;
using QtLoggerPrettyFormatter = QtLogger::PrettyFormatter;
using QtLoggerQtLogMessageFormatter = QtLogger::QtLogMessageFormatter;
using QtLoggerRegExpFilter = QtLogger::RegExpFilter;
using QtLoggerRotatingFileSink = QtLogger::RotatingFileSink;
using QtLoggerSignalSink = QtLogger::SignalSink;
using QtLoggerStdErrSink = QtLogger::StdErrSink;
using QtLoggerStdLogSink = QtLogger::StdLogSink;
using QtLoggerStdOutSink = QtLogger::StdOutSink;

using QtLoggerFilterPtr = QtLogger::FilterPtr;
using QtLoggerFormatterPtr = QtLogger::FormatterPtr;
using QtLoggerHandlerPtr = QtLogger::HandlerPtr;
using QtLoggerSinkPtr = QtLogger::SinkPtr;
using QtLoggerFileSinkPtr = QtLogger::FileSinkPtr;
using QtLoggerFunctionFilterPtr = QtLogger::FunctionFilterPtr;
using QtLoggerFunctionFormatterPtr = QtLogger::FunctionFormatterPtr;
using QtLoggerIODeviceSinkPtr = QtLogger::IODeviceSinkPtr;
using QtLoggerJsonFormatterPtr = QtLogger::JsonFormatterPtr;
using QtLoggerPipelinePtr = QtLogger::PipelinePtr;
using QtLoggerPatternFormatterPtr = QtLogger::PatternFormatterPtr;
using QtLoggerPrettyFormatterPtr = QtLogger::PrettyFormatterPtr;
using QtLoggerQtLogMessageFormatterPtr = QtLogger::QtLogMessageFormatterPtr;
using QtLoggerRegExpFilterPtr = QtLogger::RegExpFilterPtr;
using QtLoggerRotatingFileSinkPtr = QtLogger::RotatingFileSinkPtr;
using QtLoggerSignalSinkPtr = QtLogger::SignalSinkPtr;
using QtLoggerStdErrSinkPtr = QtLogger::StdErrSinkPtr;
using QtLoggerStdLogSinkPtr = QtLogger::StdLogSinkPtr;
using QtLoggerStdOutSinkPtr = QtLogger::StdOutSinkPtr;

#ifdef QTLOGGER_NETWORK

// httpsink.h

#ifdef QTLOGGER_NETWORK

#include <QNetworkRequest>
#include <QSharedPointer>
#include <QPointer>
#include <QUrl>

QT_FORWARD_DECLARE_CLASS(QNetworkAccessManager)

namespace QtLogger {

class QTLOGGER_EXPORT HttpSink : public Sink
{
public:
    explicit HttpSink(const QUrl &url);
    ~HttpSink();

    void send(const LogMessage &logMsg) override;

    void setNetworkAccessManager(QNetworkAccessManager *manager);
    void setRequest(const QNetworkRequest &request);

private:
    QUrl m_url;
    QPointer<QNetworkAccessManager> m_manager;
    QNetworkRequest m_request;
};

using HttpSinkPtr = QSharedPointer<HttpSink>;

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// end httpsink.h

using QtLoggerHttpSink = QtLogger::HttpSink;
using QtLoggerHttpSinkPtr = QtLogger::HttpSinkPtr;
#endif

#ifdef QTLOGGER_IOSLOG

using QtLoggerIosLogSink = QtLogger::IosLogSink;
using QtLoggerIosLogSinkPtr = QtLogger::IosLogSinkPtr;
#endif

#ifdef QTLOGGER_ANDROIDLOG

using QtLoggerAndroidLogSink = QtLogger::AndroidLogSink;
using QtLoggerAndroidLogSinkPtr = QtLogger::AndroidLogSinkPtr;
#endif

#ifdef QTLOGGER_SYSLOG

// syslogsink.h

#ifdef QTLOGGER_SYSLOG

#include <QSharedPointer>

// Syslog options
// See syslog.h for more information
#define QTLOGGER_SYSLOG_LOG_PID  0x01
#define QTLOGGER_SYSLOG_LOG_USER (1 << 3)

namespace QtLogger {

class QTLOGGER_EXPORT SysLogSink : public Sink
{
public:
    explicit SysLogSink(const QString &ident, int option = QTLOGGER_SYSLOG_LOG_PID,
                        int facility = QTLOGGER_SYSLOG_LOG_USER);
    ~SysLogSink();

    void send(const LogMessage &logMsg) override;
};

using SysLogSinkPtr = QSharedPointer<SysLogSink>;

} // namespace QtLogger

#endif // QTLOGGER_SYSLOG

// end syslogsink.h

using QtLoggerSysLogSink = QtLogger::SysLogSink;
using QtLoggerSysLogSinkPtr = QtLogger::SysLogSinkPtr;
#endif

#ifdef QTLOGGER_JOURNAL

// journalsink.h

#ifdef QTLOGGER_JOURNAL

#include <QSharedPointer>

#include "../abstractmessagesink.h"

namespace QtLogger {

class QTLOGGER_EXPORT JournalSink : public Sink
{
public:
    void send(const LogMessage &logMsg) override;
};

using JournalSinkPtr = QSharedPointer<JournalSink>;

} // namespace QtLogger

#endif // QTLOGGER_JOURNAL

// end journalsink.h

using QtLoggerJournalSink = QtLogger::JournalSink;
using QtLoggerJournalSinkPtr = QtLogger::JournalSinkPtr;
#endif

// regexpfilter.cpp

#include <QRegularExpression>

namespace QtLogger {

QTLOGGER_DECL_SPEC
RegExpFilter::RegExpFilter(const QRegularExpression &regExp) : m_regExp(regExp) { }

QTLOGGER_DECL_SPEC
QtLogger::RegExpFilter::RegExpFilter(const QString &regExp) : m_regExp(QRegularExpression(regExp))
{
}

QTLOGGER_DECL_SPEC
bool RegExpFilter::filter(const LogMessage &logMsg) const
{
    return m_regExp.match(logMsg.message()).hasMatch();
}

} // namespace QtLogger

// jsonformatter.cpp

#include <QCoreApplication>
#include <QJsonDocument>
#include <QJsonObject>

#ifdef QTLOGGER_NETWORK
#    include <QHostInfo>
#endif

namespace QtLogger {

QTLOGGER_DECL_SPEC
QString JsonFormatter::format(const LogMessage &logMsg) const
{
    static QStringList types { QStringLiteral("debug"),    QStringLiteral("warning"),
                               QStringLiteral("critical"), QStringLiteral("fatal"),
                               QStringLiteral("info"),     QStringLiteral("system") };

    QJsonObject obj;

    obj[QStringLiteral("message")] = logMsg.message();
    obj[QStringLiteral("type")] = types.value(logMsg.type(), QStringLiteral("debug"));
    obj[QStringLiteral("line")] = logMsg.line();
    obj[QStringLiteral("file")] = QString::fromUtf8(logMsg.file());
    obj[QStringLiteral("function")] = QString::fromUtf8(logMsg.function());
    obj[QStringLiteral("category")] = QString::fromUtf8(logMsg.category());
    obj[QStringLiteral("time")] = logMsg.time().toString(QStringLiteral("yyyy-MM-ddThh:mm:ss.zZ"));
    obj[QStringLiteral("thread")] = logMsg.threadId();

    for (const auto &key : logMsg.attributes().keys()) {
        obj[key] = QJsonValue::fromVariant(logMsg.attribute(key));
    }

    if (qApp) {
        obj[QStringLiteral("pid")] = qApp->applicationPid();
        obj[QStringLiteral("app_path")] = qApp->applicationFilePath();
        obj[QStringLiteral("app_name")] = qApp->applicationName();
        obj[QStringLiteral("app_version")] = qApp->applicationVersion();
#ifdef QTLOGGER_NETWORK
        obj[QStringLiteral("host_name")] = QHostInfo::localHostName();
#endif
    }

    return QString::fromUtf8(QJsonDocument(obj).toJson());
}

} // namespace QtLogger

// patternformatter.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
PatternFormatter::PatternFormatter(const QString &pattern) : m_pattern(pattern) { }

QTLOGGER_DECL_SPEC
QString PatternFormatter::format(const LogMessage &logMsg) const
{
    // TODO: write own implementation

    QtLogger::setMessagePattern(m_pattern);

    auto result = qFormatLogMessage(logMsg.type(), logMsg.context(), logMsg.message());

    QtLogger::restorePreviousMessagePattern();

    return result;
}

} // namespace QtLogger

// prettyformatter.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
PrettyFormatter::PrettyFormatter(bool showThread, int maxCategoryWidth)
    : m_showThreadId(showThread), m_maxCategoryWidth(maxCategoryWidth)
{
}

QTLOGGER_DECL_SPEC
QString PrettyFormatter::format(const LogMessage &logMsg) const
{
    static const QString msg_f { QStringLiteral("%1 %2 %3%4%5%6") };
    static const QString time_f { QStringLiteral("dd.MM.yyyy hh:mm:ss.zzz") };
    static const QStringList type_l {
        QStringLiteral(" "), QStringLiteral("W"), QStringLiteral("E"),
        QStringLiteral("F"), QStringLiteral("I"), QStringLiteral("S")
    };
    static const QString thread_f { QStringLiteral("#%1 ") };
    static const QString category_f { QStringLiteral("[%1] ") };

    QString thread;
    if (m_showThreadId) {
        if (!m_threads.contains(logMsg.threadId())) {
            m_threads[logMsg.threadId()] = m_threadsIndex++;
        }
        if (m_threads.count() > 1) {
            const auto index = m_threads.value(logMsg.threadId());
            thread = thread_f.arg(index);
            if (index == 0) {
                thread.fill(QChar::fromLatin1(' '));
            }
        }
    }

    QString category;
    if (qstrcmp(logMsg.category(), "default") != 0) {
        category = category_f.arg(QString::fromUtf8(logMsg.category()));
    }

    QString space;
    if (m_maxCategoryWidth > 0) {
        int categoryLength = category.length();
        if (categoryLength > m_categoryWidth && categoryLength <= m_maxCategoryWidth) {
            m_categoryWidth = categoryLength;
        }
        space.fill(QChar::fromLatin1(' '), qMax(m_categoryWidth - categoryLength, 0));
    }

    auto result = msg_f.arg(logMsg.time().toString(time_f), type_l.at(logMsg.type()), thread,
                            category, space, logMsg.message());

    return result;
}

} // namespace QtLogger

// logger.cpp

#include <QFileInfo>
#include <QLoggingCategory>
#include <QScopedPointer>

#ifndef QTLOGGER_NO_THREAD
#    include <QAtomicPointer>
#    include <QCoreApplication>
#    include <QMutexLocker>
#endif

#include <iostream>

#ifdef QTLOGGER_NETWORK

#endif

#ifdef QTLOGGER_SYSLOG

#endif

#ifdef QTLOGGER_JOURNAL

#endif

#ifdef QTLOGGER_IOSLOG

#endif

#ifdef QTLOGGER_ANDROIDLOG

#endif

namespace QtLogger {

namespace {

#ifndef QTLOGGER_NO_THREAD
QAtomicPointer<Logger> g_activeLogger;
#else
Logger *g_activeLogger = nullptr;
#endif

QtMessageHandler g_previousMessageHandler = nullptr;

}

QTLOGGER_DECL_SPEC
Logger *Logger::instance()
{
    static QScopedPointer<Logger> s_instance;

    if (!s_instance) {
        s_instance.reset(new Logger);
        s_instance->installMessageHandler();
    }

    return s_instance.data();
}

QTLOGGER_DECL_SPEC
Logger::~Logger()
{
#ifndef QTLOGGER_NO_THREAD
    g_activeLogger.testAndSetOrdered(this, nullptr);
#else
    if (g_activeLogger == this) {
        g_activeLogger = nullptr;
    }
#endif
}

QTLOGGER_DECL_SPEC
void Logger::setFilterRules(const QString &rules)
{
    QLoggingCategory::setFilterRules(
            QString(rules).replace(QChar::fromLatin1(';'), QChar::fromLatin1('\n')));
}

QTLOGGER_DECL_SPEC
void Logger::setMessagePattern(const QString &pattern)
{
    if (pattern.toLower() == QStringLiteral("default")) {
        QtLogger::setMessagePattern(QString::fromUtf8(DefaultMessagePattern));
        return;
    }

    if (pattern.toLower() == QStringLiteral("default")) {
        QtLogger::setMessagePattern(QString::fromUtf8(PrettyMessagePattern));
        return;
    }

    QtLogger::setMessagePattern(pattern);
}

QTLOGGER_DECL_SPEC
Logger &Logger::operator<<(const HandlerPtr &handler)
{
    append(handler);
    return *this;
}

QTLOGGER_DECL_SPEC
void Logger::configure(std::initializer_list<HandlerPtr> handlers, bool async)
{
#ifndef QTLOGGER_NO_THREAD
    QMutexLocker locker(&m_mutex);
#endif

    clear();

    for (const auto &handler : handlers) {
        append(handler);
    }

#ifndef QTLOGGER_NO_THREAD
    if (async) {
        moveToOwnThread();
    }
#else
    Q_UNUSED(async)
#endif
}

QTLOGGER_DECL_SPEC
void Logger::configure(const SinkTypeFlags &types, const QString &path, int maxFileSize,
                       int maxFileCount, bool async)
{
#ifndef QTLOGGER_NO_THREAD
    QMutexLocker locker(&m_mutex);
#endif

    clear();

    setFormatter(PrettyFormatter::instance());

    if (types.testFlag(SinkType::StdOut)) {
        appendSink(StdOutSinkPtr::create());
    }

    if (types.testFlag(SinkType::StdErr)) {
        appendSink(StdErrSinkPtr::create());
    }

    if (types.testFlag(SinkType::StdLog)) {
        appendSink(StdLogSinkPtr::create());
    }

#ifdef QTLOGGER_SYSLOG
    if (types.testFlag(SinkType::SysLog)) {
        appendSink(SysLogSinkPtr::create(QFileInfo(path).baseName()));
    }
#endif

#ifdef QTLOGGER_JOURNAL
    if (types.testFlag(SinkType::Journal)) {
        appendSink(JournalSinkPtr::create());
    }
#endif

    if (types.testFlag(SinkType::File) && !path.isEmpty()) {
        appendSink(FileSinkPtr::create(path));
    }

    if (types.testFlag(SinkType::RotatingFile) && !path.isEmpty()) {
        appendSink(RotatingFileSinkPtr::create(path, maxFileSize, maxFileCount));
    }

#ifndef QTLOGGER_NO_THREAD
    if (async) {
        moveToOwnThread();
    }
#else
    Q_UNUSED(async)
#endif
}

QTLOGGER_DECL_SPEC
void Logger::configure(int types, const QString &path, int maxFileSize, int maxFileCount,
                       bool async)
{
    configure(SinkTypeFlags(QFlag(types)), path, maxFileSize, maxFileCount, async);
}

QTLOGGER_DECL_SPEC
void Logger::configure(const QSettings &settings, const QString &group)
{
#ifndef QTLOGGER_NO_THREAD
    QMutexLocker locker(&m_mutex);
#endif

    clear();

    setFormatter(PrettyFormatter::instance());

    const auto filterRules = settings.value(group + QStringLiteral("/filter_rules")).toString();
    if (!filterRules.isEmpty()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: filterRules: " << filterRules.toStdString() << std::endl;
#endif
        setFilterRules(filterRules);
    }

    const auto messagePattern =
            settings.value(group + QStringLiteral("/message_pattern")).toString();
    if (!messagePattern.isEmpty()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: messagePattern: " << messagePattern.toStdString()
                  << std::endl;
#endif
        setFormatter(PatternFormatterPtr::create(messagePattern));
    }

    const auto regExpFilter = settings.value(group + QStringLiteral("/regexp_filter")).toString();
    if (!regExpFilter.isEmpty()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: filter: " << regExpFilter.toStdString() << std::endl;
#endif
        appendFilter(RegExpFilterPtr::create(regExpFilter));
    }

    if (settings.value(group + QStringLiteral("/stdout"), false).toBool()) {
        std::cerr << "Logger::configure: stdout" << std::endl;
        appendSink(StdOutSinkPtr::create());
    }

    if (settings.value(group + QStringLiteral("/stderr"), false).toBool()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: stderr" << std::endl;
#endif
        appendSink(StdErrSinkPtr::create());
    }

    if (settings.value(group + QStringLiteral("/stdlog"), true).toBool()) {
#ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: stdlog" << std::endl;
#endif
        appendSink(StdLogSinkPtr::create());
    }

#ifdef QTLOGGER_SYSLOG
    const auto sysLogIdent = settings.value(group + QStringLiteral("/syslog_ident")).toString();
    if (!sysLogIdent.isEmpty()) {
#    ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: sysLogIdent: " << sysLogIdent.toStdString() << std::endl;
#    endif
        appendSink(SysLogSinkPtr::create(sysLogIdent));
    }
#endif

#ifdef QTLOGGER_JOURNAL
    if (settings.value(group + QStringLiteral("/journal"), false).toBool()) {
#    ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: journal" << std::endl;
#    endif
        appendSink(JournalSinkPtr::create());
    }
#endif

    const auto path = settings.value(group + QStringLiteral("/path")).toString();
    if (!path.isEmpty()) {
        const auto maxFileSize = settings.value(group + QStringLiteral("/max_file_size"),
                                                RotatingFileDefaultMaxFileSize)
                                         .toInt();

        const auto maxFileCount = settings.value(group + QStringLiteral("/max_file_count"),
                                                 RotatingFileDefaultMaxFileCount)
                                          .toInt();

#ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: path: " << path.toStdString()
                  << " maxFileSize: " << maxFileSize << " maxFileCount: " << maxFileCount
                  << std::endl;
#endif

        appendSink(RotatingFileSinkPtr::create(path, maxFileSize, maxFileCount));
    }

#ifdef QTLOGGER_NETWORK
    const auto httpUrl = settings.value(group + QStringLiteral("/http_url")).toString();
    if (!httpUrl.isEmpty()) {
        const auto httpMsgFormat = settings.value(group + QStringLiteral("/http_msg_format"),
                                                  QStringLiteral("default"))
                                           .toString();
        // TODO: add support for http_msg_format (json)
        appendSink(HttpSinkPtr::create(QUrl(httpUrl)));
    }
#endif

#ifndef QTLOGGER_NO_THREAD
    if (settings.value(group + QStringLiteral("/async"), false).toBool()) {
#    ifdef QTLOGGER_DEBUG
        std::cerr << "Logger::configure: async" << std::endl;
#    endif
        moveToOwnThread();
    }
#endif
}

QTLOGGER_DECL_SPEC
void Logger::configure(const QString &path, const QString &group)
{
    configure(QSettings(path, QSettings::IniFormat), group);
}

#ifndef QTLOGGER_NO_THREAD

QTLOGGER_DECL_SPEC
void Logger::lock() const
{
    m_mutex.lock();
}

QTLOGGER_DECL_SPEC
void Logger::unlock() const
{
    m_mutex.unlock();
}

QTLOGGER_DECL_SPEC
QRMUTEX *Logger::mutex() const
{
    return &m_mutex;
}

#endif

QTLOGGER_DECL_SPEC
void Logger::processMessage(QtMsgType type, const QMessageLogContext &context,
                            const QString &message)
{
    LogMessage logMsg(type, context, message);

    process(logMsg);
}

QTLOGGER_DECL_SPEC
void Logger::messageHandler(QtMsgType type, const QMessageLogContext &context,
                            const QString &message)
{
#ifndef QTLOGGER_NO_THREAD
    auto logger = g_activeLogger.loadAcquire();
#else
    auto logger = g_activeLogger;
#endif

    if (!logger)
        return;

#ifndef QTLOGGER_NO_THREAD
    QMutexLocker locker(logger->mutex());
#endif

    logger->processMessage(type, context, message);
}

QTLOGGER_DECL_SPEC
void Logger::installMessageHandler()
{
#ifndef QTLOGGER_NO_THREAD
    g_activeLogger.storeRelease(this);
#else
    g_activeLogger = this;
#endif

    auto prev = qInstallMessageHandler(messageHandler);

    if (prev != messageHandler) {
        g_previousMessageHandler = prev;
    }
}

QTLOGGER_DECL_SPEC
void Logger::restorePreviousMessageHandler()
{
    if (!g_previousMessageHandler)
        return;

    auto prev = qInstallMessageHandler(g_previousMessageHandler);

    if (prev != messageHandler) {
        qInstallMessageHandler(prev);
    }

    g_previousMessageHandler = nullptr;
}

} // namespace QtLogger

// ownthreadpipeline.cpp

#include <QCoreApplication>
#include <QEvent>
#include <QThread>

namespace QtLogger {

namespace {

static QEvent::Type __processLogMessageEventType = static_cast<QEvent::Type>(QEvent::User + 2000);

struct QTLOGGER_EXPORT ProcessLogMessageEvent : public QEvent
{
    LogMessage logMsg;
    ProcessLogMessageEvent(const LogMessage &logMsg)
        : QEvent(__processLogMessageEventType), logMsg(logMsg)
    {
    }
};

}

class QTLOGGER_EXPORT OwnThreadPipelineWorker : public QObject
{
public:
    explicit OwnThreadPipelineWorker(OwnThreadPipeline *handler, QObject *parent = nullptr)
        : QObject(parent), m_handler(handler)
    {
    }

    void customEvent(QEvent *event) override
    {
        if (event->type() == __processLogMessageEventType) {
            auto _event = dynamic_cast<ProcessLogMessageEvent *>(event);
            if (_event) {
                m_handler->TypedPipeline::process(_event->logMsg);
            }
        }
    }

private:
    OwnThreadPipeline *m_handler;
};

QTLOGGER_DECL_SPEC
OwnThreadPipeline::OwnThreadPipeline()
{
    qRegisterMetaType<QtLogger::LogMessage>("QtLogger::LogMessage");
}

QTLOGGER_DECL_SPEC
OwnThreadPipeline::~OwnThreadPipeline()
{
#ifndef QTLOGGER_NO_THREAD
    if (m_thread) {
        m_thread->quit();
        m_thread->wait(1000);
        if (m_thread)
            delete m_thread;
    }

    if (m_worker) {
        delete m_worker;
    }
#endif
}

QTLOGGER_DECL_SPEC
void OwnThreadPipeline::moveToOwnThread()
{
    if (!m_worker) {
        m_worker = new OwnThreadPipelineWorker(this);
    }

    if (!m_thread) {
        m_thread = new QThread;

        if (qApp) {
            if (qApp->thread() != m_thread->thread())
                m_thread->moveToThread(qApp->thread());
            QObject::connect(qApp, &QCoreApplication::aboutToQuit, m_thread, &QThread::quit);
        }

        QObject::connect(m_thread, &QThread::finished, m_thread, &QThread::deleteLater);
        QObject::connect(m_thread, &QThread::finished, m_worker, &QThread::deleteLater);

        m_thread->start();
    }

    m_worker->moveToThread(m_thread);
}

QTLOGGER_DECL_SPEC
void OwnThreadPipeline::moveToMainThread()
{
    m_worker->moveToThread(qApp->thread());

    if (m_thread) {
        m_thread->quit();
    }
}

QTLOGGER_DECL_SPEC
bool OwnThreadPipeline::ownThreadIsRunning() const
{
    return m_thread && m_thread->isRunning();
}

QTLOGGER_DECL_SPEC
bool OwnThreadPipeline::process(LogMessage &logMsg)
{
    if (!ownThreadIsRunning()) {
        TypedPipeline::process(logMsg);
    } else {
        QCoreApplication::postEvent(m_worker, new ProcessLogMessageEvent(logMsg));
    }
    return true;
}

} // namespace QtLogger

// pipeline.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
Pipeline::Pipeline(std::initializer_list<HandlerPtr> handlers) : m_handlers(handlers) { }

QTLOGGER_DECL_SPEC
void Pipeline::append(const HandlerPtr &handler)
{
    if (handler.isNull())
        return;

    m_handlers.append(handler);
}

QTLOGGER_DECL_SPEC
void Pipeline::append(std::initializer_list<HandlerPtr> handlers)
{
    m_handlers.append(handlers);
}

QTLOGGER_DECL_SPEC
void Pipeline::remove(const HandlerPtr &handler)
{
    if (handler.isNull())
        return;

    m_handlers.removeAll(handler);
}

QTLOGGER_DECL_SPEC
void Pipeline::clear()
{
    m_handlers.clear();
}

QTLOGGER_DECL_SPEC
Pipeline &Pipeline::operator<<(const HandlerPtr &handler)
{
    append(handler);
    return *this;
}

QTLOGGER_DECL_SPEC
bool Pipeline::process(LogMessage &logMsg)
{
    for (auto &handler : m_handlers) {
        if (!handler)
            continue;
        if (!handler->process(logMsg))
            break;
    }

    return true;
}

} // namespace QtLogger

// setmessagepattern.cpp

#include <QString>

namespace {

QTLOGGER_DECL_SPEC
QString prevMessagePattern(const QString &messagePattern = {})
{
    static QString __prevMessagePattern { QString::fromUtf8(QtLogger::DefaultMessagePattern) };

    if (!messagePattern.isNull())
        __prevMessagePattern = messagePattern;

    return __prevMessagePattern;
}

}

namespace QtLogger {

QTLOGGER_DECL_SPEC
QString setMessagePattern(const QString &messagePattern)
{
    static QString __messagePattern { QString::fromUtf8(QtLogger::DefaultMessagePattern) };

    if (__messagePattern == messagePattern)
        return __messagePattern;

    prevMessagePattern(__messagePattern);

    __messagePattern = messagePattern;

    qSetMessagePattern(__messagePattern);

    return prevMessagePattern();
}

QTLOGGER_DECL_SPEC
QString restorePreviousMessagePattern()
{
    return setMessagePattern(prevMessagePattern());
}

} // namespace QtLogger

// androidlogsink.cpp

#ifdef QTLOGGER_ANDROIDLOG

#include <android/log.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void AndroidLogSink::send(const LogMessage &logMsg)
{
    android_LogPriority priority = ANDROID_LOG_DEBUG;

    switch (logMsg.type()) {
    case QtDebugMsg:
        priority = ANDROID_LOG_DEBUG;
        break;
    case QtInfoMsg:
        priority = ANDROID_LOG_INFO;
        break;
    case QtWarningMsg:
        priority = ANDROID_LOG_WARN;
        break;
    case QtCriticalMsg:
        priority = ANDROID_LOG_ERROR;
        break;
    case QtFatalMsg:
        priority = ANDROID_LOG_FATAL;
        break;
    };

    __android_log_print(priority, logMsg.category(), "%s\n", qPrintable(logMsg.message()));
}

} // namespace QtLogger

#endif // QTLOGGER_ANDROIDLOG

// filesink.cpp

#include <QDateTime>
#include <QFile>
#include <QRegularExpression>
#include <QSharedPointer>

#include <iostream>

namespace QtLogger {

namespace {

/**
 * @brief Replaces the time pattern in the given string with the current date and time.
 *
 * This function searches for a time pattern in the format `%{time <format>}` within the input
 * string. If found, it replaces the pattern with the current date and time formatted according to
 * the specified format. If no format is specified, it defaults to "yyyyMMdd_hhmmss".
 *
 * @param path The input string potentially containing the time pattern.
 * @return A new string with the time pattern replaced by the current date and time.
 */

QTLOGGER_DECL_SPEC
QString replaceTimePattern(const QString &path)
{
    static auto re = QRegularExpression(QStringLiteral("(.*)%{time *(.*?)}(.*)"));
    auto match = re.match(path);

    if (!match.hasMatch())
        return path;

    auto format = match.captured(2);

    if (format.isEmpty()) {
        format = QStringLiteral("yyyyMMdd_hhmmss");
    }

    return match.captured(1) + QDateTime::currentDateTime().toString(format) + match.captured(3);
}

QTLOGGER_DECL_SPEC
QSharedPointer<QFile> createFilePtr(const QString &path)
{
    return QSharedPointer<QFile>::create(replaceTimePattern(path));
}

}

QTLOGGER_DECL_SPEC
FileSink::FileSink(const QString &path) : IODeviceSink(createFilePtr(path))
{
    if (!file()->open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text)) {
        std::cerr << "Logger::FileHandler: Can't open log file: " << path.toStdString()
                  << " error: " << file()->errorString().toStdString() << std::endl;
    }
}

QTLOGGER_DECL_SPEC
FileSink::~FileSink()
{
    file()->close();
}

QTLOGGER_DECL_SPEC
bool FileSink::flush()
{
    return file()->flush();
}

QTLOGGER_DECL_SPEC
QFile *FileSink::file() const
{
    return qobject_cast<QFile *>(device().data());
}

} // namespace QtLogger

// httpsink.cpp

#ifdef QTLOGGER_NETWORK

#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QNetworkRequest>

namespace QtLogger {

QTLOGGER_DECL_SPEC
HttpSink::HttpSink(const QUrl &url) : m_url(url)
{
    m_manager = new QNetworkAccessManager;

#ifndef QTLOGGER_NO_THREAD
    if (m_manager->thread() != Logger::instance()->ownThread()) {
        m_manager->moveToThread(Logger::instance()->ownThread());
    }
#endif

    m_request.setUrl(m_url);
}

QTLOGGER_DECL_SPEC
HttpSink::~HttpSink()
{
    if (!m_manager.isNull()) {
        delete m_manager.data();
    }
}

QTLOGGER_DECL_SPEC
void HttpSink::send(const LogMessage &logMsg)
{
    if (!Logger::instance()->ownThreadIsRunning()) {
        if (!m_manager.isNull() && !m_manager->property("activeReply").isValid())
            m_manager->deleteLater();
        m_manager = new QNetworkAccessManager;
    }

    if (logMsg.hasAttribute("mime_type")) {
        m_request.setHeader(QNetworkRequest::ContentTypeHeader,
                            QStringLiteral("%1; charset=utf-8")
                                    .arg(logMsg.attribute("mime_type").toByteArray()));
    } else {
        m_request.setHeader(QNetworkRequest::ContentTypeHeader,
                            QStringLiteral("text/plain; charset=utf-8"));
    }

    auto reply = m_manager->post(m_request, logMsg.formattedMessage().toUtf8());

    QObject::connect(reply, &QNetworkReply::finished, reply, &QObject::deleteLater);

    if (!Logger::instance()->ownThreadIsRunning()) {
        m_manager->setProperty("activeReply", QVariant::fromValue(reply));
        QObject::connect(reply, &QNetworkReply::finished, m_manager, &QObject::deleteLater);
    }
}

QTLOGGER_DECL_SPEC
void HttpSink::setNetworkAccessManager(QNetworkAccessManager *manager)
{
    if (!m_manager.isNull()) {
        delete m_manager.data();
    }
    m_manager = manager;
}

QTLOGGER_DECL_SPEC
void HttpSink::setRequest(const QNetworkRequest &request)
{
    m_request = request;
}

} // namespace QtLogger

#endif // QTLOGGER_NETWORK

// iodevicesink.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
IODeviceSink::IODeviceSink(const QIODevicePtr &device) : m_device(device) { }

QTLOGGER_DECL_SPEC
void IODeviceSink::send(const LogMessage &logMsg)
{
    if (m_device.isNull()) {
        return;
    }

    m_device->write(logMsg.formattedMessage().toLocal8Bit().append("\n"));
}

QTLOGGER_DECL_SPEC
const QIODevicePtr &IODeviceSink::device() const
{
    return m_device;
}

QTLOGGER_DECL_SPEC
void IODeviceSink::setDevice(const QIODevicePtr &device)
{
    m_device = device;
}

} // namespace QtLogger

// ioslogsink.cpp

#ifdef QTLOGGER_IOSLOG

#include <os/log.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void IosLogSink::send(const LogMessage &logMsg)
{
    QString formattedMessage;

    if (qstrcmp(logMsg.category(), "default") == 0) {
        formattedMessage = logMsg.message();
    } else {
        formattedMessage = QStringLiteral("%1: %2").arg(logMsg.category(), logMsg.message());
    }

    os_log_type_t type = OS_LOG_TYPE_DEBUG;
    switch (logMsg.type()) {
    case QtDebugMsg:
        type = OS_LOG_TYPE_DEBUG;
        break;
    case QtInfoMsg:
        type = OS_LOG_TYPE_INFO;
        break;
    case QtWarningMsg:
        type = OS_LOG_TYPE_ERROR;
        break;
    case QtCriticalMsg:
        type = OS_LOG_TYPE_FAULT;
        break;
    case QtFatalMsg:
        type = OS_LOG_TYPE_FAULT;
        break;
    };

    os_log_with_type(OS_LOG_DEFAULT, type, "%s\n", qPrintable(logMsg.message()));
}

} // namespace QtLogger

#endif // QTLOGGER_IOSLOG

// journalsink.cpp

#ifdef QTLOGGER_JOURNAL

#include <systemd/sd-journal.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void JournalSink::send(const LogMessage &logMsg)
{
    int priority = LOG_DEBUG;

    switch (logMsg.type()) {
    case QtDebugMsg:
        priority = LOG_DEBUG;
        break;
    case QtWarningMsg:
        priority = LOG_WARNING;
        break;
    case QtCriticalMsg:
        priority = LOG_ERR;
        break;
    case QtFatalMsg:
        priority = LOG_EMERG;
        break;
    case QtInfoMsg:
        priority = LOG_INFO;
        break;
    default:
        return;
    }

    const auto &file = QByteArrayLiteral("CODE_FILE=") + QByteArray(logMsg.file());
    const auto &line = QByteArrayLiteral("CODE_LINE=") + QByteArray::number(logMsg.line());

    sd_journal_print_with_location(priority, file.constData(), line.constData(), logMsg.function(),
                                   "%s", qPrintable(logMsg.formattedMessage()));

    sd_journal_send_with_location(file.constData(), line.constData(), logMsg.function(), "%s",
                                  qPrintable(logMsg.formattedMessage()), "PRIORITY=%i", priority,
                                  "CATEGORY=%s", logMsg.category(), NULL);
}

} // namespace QtLogger

#endif // QTLOGGER_JOURNAL

// rotatingfilesink.cpp

#include <QDir>
#include <QFile>
#include <QFileInfo>
#include <QRegularExpression>

namespace QtLogger {

QTLOGGER_DECL_SPEC
RotatingFileSink::RotatingFileSink(const QString &path, int maxFileSize, int maxFileCount)
    : FileSink(path), m_maxFileSize(maxFileSize), m_maxFileCount(maxFileCount)
{
    if (file()->size() > 0)
        rotate();
}

QTLOGGER_DECL_SPEC
void RotatingFileSink::send(const LogMessage &logMsg)
{
    const auto newFileSize = file()->size() + logMsg.formattedMessage().toLocal8Bit().size();

    if (m_maxFileSize > 0 && file()->size() != 0 && newFileSize > m_maxFileSize) {
        rotate();
    }

    FileSink::send(logMsg);
}

QTLOGGER_DECL_SPEC
QString numberedFileName(const QString &fileName, int i)
{
    return QStringLiteral("%1.%2").arg(fileName).arg(i);
}

QTLOGGER_DECL_SPEC
void RotatingFileSink::rotate()
{
    if (m_maxFileCount == 1)
        return;

    int maxFileCount = m_maxFileCount > 1 ? m_maxFileCount : RotatingFileCountLimit;

    file()->close();

    const auto &fileName = file()->fileName();

    int i = 1;
    for (; i < maxFileCount; ++i) {
        if (!QFile::exists(numberedFileName(fileName, i))) {
            --i;
            break;
        }
    }
    for (; i > 0; --i) {
        const auto &curFileName = numberedFileName(fileName, i);
        const auto &newFileName = numberedFileName(fileName, i + 1);

        QFile::rename(curFileName, newFileName);
    }

    // rename first
    QFile::rename(fileName, numberedFileName(fileName, 1));

    // remove last
    QFile::remove(QStringLiteral("%1.%2").arg(fileName).arg(m_maxFileCount));

    file()->open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text);
}

} // namespace QtLogger

// signalsink.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
SignalSink::SignalSink(QObject *parent) : QObject(parent) { }

QTLOGGER_DECL_SPEC
void SignalSink::send(const LogMessage &logMsg)
{
    Q_EMIT message(logMsg);
}

} // namespace QtLogger

// stderrsink.cpp

#include <iostream>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void StdErrSink::send(const LogMessage &logMsg)
{
    std::cerr << qPrintable(logMsg.formattedMessage()) << std::endl;
}

} // namespace QtLogger

// stdoutsink.cpp

#include <iostream>

namespace QtLogger {

QTLOGGER_DECL_SPEC
void StdOutSink::send(const LogMessage &logMsg)
{
    std::cout << qPrintable(logMsg.formattedMessage()) << std::endl;
}

} // namespace QtLogger

// syslogsink.cpp

#ifdef QTLOGGER_SYSLOG

#include <syslog.h>

namespace QtLogger {

QTLOGGER_DECL_SPEC
SysLogSink::SysLogSink(const QString &ident, int option, int facility)
{
    openlog(qPrintable(ident), option, facility);
}

QTLOGGER_DECL_SPEC
SysLogSink::~SysLogSink()
{
    closelog();
}

QTLOGGER_DECL_SPEC
void SysLogSink::send(const LogMessage &logMsg)
{
    QString formattedMessage;

    if (qstrcmp(logMsg.category(), "default") == 0) {
        formattedMessage = logMsg.message();
    } else {
        formattedMessage = QStringLiteral("%1: %2").arg(logMsg.category(), logMsg.message());
    }

    int priority = LOG_DEBUG;

    switch (logMsg.type()) {
    case QtDebugMsg:
        priority = LOG_DEBUG;
        break;
    case QtWarningMsg:
        priority = LOG_WARNING;
        break;
    case QtCriticalMsg:
        priority = LOG_ERR;
        break;
    case QtFatalMsg:
        priority = LOG_EMERG;
        break;
    case QtInfoMsg:
        priority = LOG_INFO;
        break;
    default:
        return;
    }

    syslog(priority, "%s", qPrintable(formattedMessage));
}

} // namespace QtLogger

#endif // QTLOGGER_SYSLOG

// typedpipeline.cpp

namespace QtLogger {

QTLOGGER_DECL_SPEC
TypedPipeline::~TypedPipeline()
{
    flush();
}

QTLOGGER_DECL_SPEC
void TypedPipeline::insertAfter(HandlerType type, const HandlerPtr &handler)
{
    auto first = std::find_if(handlers().begin(), handlers().end(),
                              [type](const HandlerPtr &x) { return x->type() == type; });

    if (first == handlers().end()) {
        handlers().prepend(handler);
        return;
    }

    auto last = std::find_if(first, handlers().end(),
                             [type](const HandlerPtr &x) { return x->type() != type; });

    handlers().insert(last, handler);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::insertBetween(HandlerType leftType, HandlerType rightType,
                                  const HandlerPtr &handler)
{
    auto firstLeft =
            std::find_if(handlers().begin(), handlers().end(),
                         [leftType](const HandlerPtr &x) { return x->type() == leftType; });

    if (firstLeft == handlers().end()) {

        auto firstRight =
                std::find_if(handlers().begin(), handlers().end(),
                             [rightType](const auto &x) { return x->type() == rightType; });

        if (firstRight != handlers().end()) {
            handlers().insert(firstRight, handler);
        } else {
            handlers().prepend(handler);
        }

        return;
    }

    auto lastLeft = std::find_if(firstLeft, handlers().end(),
                                 [leftType](const HandlerPtr &x) { return x->type() != leftType; });

    handlers().insert(lastLeft, handler);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::clearType(HandlerType type)
{
    QMutableListIterator<HandlerPtr> iter(handlers());

    while (iter.hasNext()) {
        if (iter.next()->type() == type) {
            iter.remove();
        }
    }
}

QTLOGGER_DECL_SPEC
void TypedPipeline::appendFilter(const FilterPtr &filter)
{
    if (filter.isNull())
        return;

    insertAfter(HandlerType::Filter, filter);
}

QTLOGGER_DECL_SPEC
FunctionFilterPtr
TypedPipeline::appendFilter(const std::function<bool(const LogMessage &)> &function)
{
    const auto f = FunctionFilterPtr::create(function);

    appendFilter(f);

    return f;
}

QTLOGGER_DECL_SPEC
RegExpFilterPtr TypedPipeline::appendFilter(const QRegularExpression &regExp)
{
    const auto f = RegExpFilterPtr::create(regExp);

    appendFilter(f);

    return f;
}

QTLOGGER_DECL_SPEC
void TypedPipeline::clearFilters()
{
    clearType(HandlerType::Filter);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::setFormatter(const FormatterPtr &formatter)
{
    if (formatter.isNull())
        return;

    clearFormatters();

    insertAfter(HandlerType::Filter, formatter);
}

QTLOGGER_DECL_SPEC
FunctionFormatterPtr TypedPipeline::setFormatter(const FunctionFormatter::Function &function)
{
    const auto f = FunctionFormatterPtr::create(function);

    setFormatter(f);

    return f;
}

QTLOGGER_DECL_SPEC
PatternFormatterPtr TypedPipeline::setFormatter(const QString &pattern)
{
    const auto f = PatternFormatterPtr::create(pattern);

    setFormatter(f);

    return f;
}

QTLOGGER_DECL_SPEC
void TypedPipeline::clearFormatters()
{
    clearType(HandlerType::Formatter);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::appendSink(const SinkPtr &sink)
{
    append(sink);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::clearSinks()
{
    clearType(HandlerType::Sink);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::appendPipeline(const PipelinePtr &pipeline)
{
    append(pipeline);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::clearPipelines()
{
    clearType(HandlerType::Pipeline);
}

QTLOGGER_DECL_SPEC
void TypedPipeline::flush()
{
    for (auto &handler : handlers()) {
        switch (handler->type()) {
        case HandlerType::Sink: {
            auto sink = handler.dynamicCast<Sink>();
            if (sink)
                sink->flush();
            break;
        }
        case HandlerType::Pipeline: {
            auto pipeline = handler.dynamicCast<TypedPipeline>();
            if (pipeline)
                pipeline->flush();
            break;
        }
        default:
            break;
        }
    }
}

} // namespace QtLogger

